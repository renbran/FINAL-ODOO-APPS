)]}'
{"version": 3, "sources": ["/web_editor/static/src/js/editor/snippets.editor.js", "/web_editor/static/src/js/editor/snippets.options.js", "/mass_mailing/static/src/js/snippets.editor.js"], "mappings": "AAAA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACprJA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACx+SA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA", "sourcesContent": ["/** @odoo-module **/\n\nimport { Mutex } from \"@web/core/utils/concurrency\";\nimport { clamp } from \"@web/core/utils/numbers\";\nimport { ConfirmationDialog } from \"@web/core/confirmation_dialog/confirmation_dialog\";\nimport dom from \"@web/legacy/js/core/dom\";\nimport { session } from \"@web/session\";\nimport Widget from \"@web/legacy/js/core/widget\";\nimport { useDragAndDrop } from \"@web_editor/js/editor/drag_and_drop\";\nimport options from \"@web_editor/js/editor/snippets.options\";\nimport weUtils from \"@web_editor/js/common/utils\";\nimport * as gridUtils from \"@web_editor/js/common/grid_layout_utils\";\nimport { escape } from \"@web/core/utils/strings\";\nimport { closestElement, isUnremovable } from \"@web_editor/js/editor/odoo-editor/src/utils/utils\";\nimport { debounce, throttleForAnimation } from \"@web/core/utils/timing\";\nimport { uniqueId } from \"@web/core/utils/functions\";\nimport { sortBy, unique } from \"@web/core/utils/arrays\";\nimport { browser } from \"@web/core/browser/browser\";\nimport { attachComponent } from \"@web/legacy/utils\";\nimport { Toolbar } from \"@web_editor/js/editor/toolbar\";\nimport {\n    Component,\n    markup,\n    xml,\n} from \"@odoo/owl\";\nimport { LinkTools } from '@web_editor/js/wysiwyg/widgets/link_tools';\nimport { touching, closest, isVisible } from \"@web/core/utils/ui\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { pyToJsLocale } from \"@web/core/l10n/utils\";\nimport { renderToElement } from \"@web/core/utils/render\";\nimport { RPCError } from \"@web/core/network/rpc_service\";\nimport { ColumnLayoutMixin } from \"@web_editor/js/common/column_layout_mixin\";\n\nlet cacheSnippetTemplate = {};\n\nvar globalSelector = {\n    closest: () => $(),\n    all: () => $(),\n    is: () => false,\n};\n\n/**\n * Management of the overlay and option list for a snippet.\n */\nvar SnippetEditor = Widget.extend({\n    template: 'web_editor.snippet_overlay',\n    events: {\n        'click .oe_snippet_remove': '_onRemoveClick',\n        'wheel': '_onMouseWheel',\n        'click .o_send_back': '_onSendBackClick',\n        'click .o_bring_front': '_onBringFrontClick',\n    },\n    custom_events: {\n        'option_update': '_onOptionUpdate',\n        'user_value_widget_request': '_onUserValueWidgetRequest',\n        'snippet_option_visibility_update': '_onSnippetOptionVisibilityUpdate',\n    },\n    layoutElementsSelector: [\n        '.o_we_shape',\n        '.o_we_bg_filter',\n    ].join(','),\n\n    /**\n     * @constructor\n     * @param {Widget} parent\n     * @param {Element} target\n     * @param {Object} templateOptions\n     * @param {jQuery} $editable\n     * @param {Object} options\n     */\n    init: function (parent, target, templateOptions, $editable, options) {\n        this._super.apply(this, arguments);\n        this.options = options;\n        // This is possible to have a snippet editor not inside an editable area\n        // (data-no-check=\"true\") and it is possible to not have editable areas\n        // at all (restricted editor), in that case we just suppose this is the\n        // body so related code can still be executed without crash (as we still\n        // need to instantiate instances of editors even if nothing is really\n        // editable (data-no-check=\"true\" / navigation options / ...)).\n        // TODO this should probably be reviewed in master: do we need a\n        // reference to the editable area? There should be workarounds.\n        this.$editable = $editable && $editable.length ? $editable : $(document.body);\n        this.ownerDocument = this.$editable[0].ownerDocument;\n        this.$body = $(this.ownerDocument.body);\n        this.$target = $(target);\n        this.$target.data('snippet-editor', this);\n        this.templateOptions = templateOptions;\n        this.isTargetParentEditable = false;\n        this.isTargetMovable = false;\n        this.$scrollingElement = $().getScrollingElement(this.$editable[0].ownerDocument);\n        if (!this.$scrollingElement[0]) {\n            this.$scrollingElement = $(this.ownerDocument).find('.o_editable');\n        }\n        this.displayOverlayOptions = false;\n        this._$toolbarContainer = $();\n\n        this.__isStarted = new Promise(resolve => {\n            this.__isStartedResolveFunc = resolve;\n        });\n    },\n    /**\n     * @override\n     */\n    start: function () {\n        var defs = [this._super.apply(this, arguments)];\n\n        // Initialize the associated options (see snippets.options.js)\n        defs.push(this._initializeOptions());\n        var $customize = this._customize$Elements[this._customize$Elements.length - 1];\n\n        this.isTargetParentEditable = this.$target.parent().is(':o_editable');\n        this.isTargetMovable = this.isTargetParentEditable && this.isTargetMovable && !this.$target.hasClass('oe_unmovable');\n        this.isTargetRemovable = this.isTargetParentEditable && !this.$target.parent().is('[data-oe-type=\"image\"]') && !isUnremovable(this.$target[0]);\n        this.displayOverlayOptions = this.displayOverlayOptions || this.isTargetMovable || !this.isTargetParentEditable;\n\n        // Initialize move/clone/remove buttons\n        if (this.isTargetMovable) {\n            this.dropped = false;\n            this.draggableComponent = this._initDragAndDrop(\".o_move_handle\", \".oe_overlay\", this.el);\n            if (!this.$target[0].matches(\"section\")) {\n                // Allow the user to drag the image itself to move the target.\n                // Note that the o_draggable class will be added by the\n                // _initDragAndDrop function. So adding it here is probably\n                // useless. To check. The fact that that class is added in any\n                // case should probably reviewed in master anyway (TODO).\n                this.$target[0].classList.add(\"o_draggable\");\n                this.draggableComponentImgs = this._initDragAndDrop(\"img\", \".o_draggable\", this.$target[0]);\n            }\n        } else {\n            this.$('.o_overlay_move_options').addClass('d-none');\n            const cloneButtonEl = $customize[0].querySelector(\".oe_snippet_clone\");\n            cloneButtonEl.classList.toggle(\"d-none\", !this.forceDuplicateButton);\n        }\n\n        if (!this.isTargetRemovable) {\n            this.$el.add($customize).find('.oe_snippet_remove').addClass('d-none');\n        }\n\n        var _animationsCount = 0;\n        this.postAnimationCover = throttleForAnimation(() => {\n            this.trigger_up('cover_update', {\n                overlayVisible: true,\n            });\n        });\n        this.$target.on('transitionstart.snippet_editor, animationstart.snippet_editor', () => {\n            // We cannot rely on the fact each transition/animation start will\n            // trigger a transition/animation end as the element may be removed\n            // from the DOM before or it could simply be an infinite animation.\n            //\n            // By simplicity, for each start, we add a delayed operation that\n            // will decrease the animation counter after a fixed duration and\n            // do the post animation cover if none is registered anymore.\n            _animationsCount++;\n            setTimeout(() => {\n                if (!--_animationsCount) {\n                    this.postAnimationCover();\n                }\n            }, 500); // This delay have to be huge enough to take care of long\n                     // animations which will not trigger an animation end event\n                     // but if it is too small for some, this is the job of the\n                     // animation creator to manually ask for a re-cover\n        });\n        // On top of what is explained above, do the post animation cover for\n        // each detected transition/animation end so that the user does not see\n        // a flickering when not needed.\n        this.$target.on('transitionend.snippet_editor, animationend.snippet_editor', this.postAnimationCover);\n\n        return Promise.all(defs).then(() => {\n            this.__isStartedResolveFunc(this);\n        });\n    },\n    /**\n     * @override\n     */\n    destroy: function () {\n        // Before actually destroying a snippet editor, notify the parent\n        // about it so that it can update its list of alived snippet editors.\n        this.trigger_up('snippet_editor_destroyed');\n        this.draggableComponent && this.draggableComponent.destroy();\n        this.draggableComponentImgs?.destroy();\n        if (this.$optionsSection) {\n            this.$optionsSection.remove();\n        }\n        if (this.postAnimationCover) {\n            this.postAnimationCover.cancel();\n        }\n        this._super(...arguments);\n        this.$target.removeData('snippet-editor');\n        this.$target.off('.snippet_editor');\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * Checks whether the snippet options are shown or not.\n     *\n     * @returns {boolean}\n     */\n    areOptionsShown: function () {\n        const lastIndex = this._customize$Elements.length - 1;\n        return !!this._customize$Elements[lastIndex].parent().length;\n    },\n    /**\n     * Notifies all the associated snippet options that the snippet has just\n     * been dropped in the page.\n     *\n     * @param {HTMLElement} targetEl the snippet dropped in the page\n     */\n    async buildSnippet(targetEl) {\n        for (var i in this.styles) {\n            await this.styles[i].onBuilt({\n                isCurrent: targetEl === this.$target[0],\n            });\n        }\n        // TODO In master differentiate device-based visibility.\n        this._toggleVisibilityStatusIgnoreDeviceVisibility = true;\n        await this.toggleTargetVisibility(true);\n        this._toggleVisibilityStatusIgnoreDeviceVisibility = false;\n    },\n    /**\n     * Notifies all the associated snippet options that the template which\n     * contains the snippet is about to be saved.\n     */\n    cleanForSave: async function () {\n        if (this.isDestroyed()) {\n            return;\n        }\n        await this.toggleTargetVisibility(!this.$target.hasClass('o_snippet_invisible')\n            && !this.$target.hasClass('o_snippet_mobile_invisible')\n            && !this.$target.hasClass('o_snippet_desktop_invisible'));\n        const proms = Object.values(this.styles).map((option) => {\n            return option.cleanForSave();\n        });\n        await Promise.all(proms);\n        await this.cleanUI();\n    },\n    /**\n     * Notifies all the associated snippet options that the snippet UI needs to\n     * be cleaned.\n     */\n    async cleanUI() {\n        const proms = Object.values(this.styles).map((option) => {\n            return option.cleanUI();\n        });\n        await Promise.all(proms);\n    },\n    /**\n     * Closes all widgets of all options.\n     */\n    closeWidgets: function () {\n        if (!this.styles || !this.areOptionsShown()) {\n            return;\n        }\n        Object.keys(this.styles).forEach(key => {\n            this.styles[key].closeWidgets();\n        });\n    },\n    /**\n     * Makes the editor overlay cover the associated snippet.\n     */\n    cover: function () {\n        if (!this.isShown() || !this.$target.length) {\n            return;\n        }\n\n        const $modal = this.$target.find('.modal:visible');\n        const $target = $modal.length ? $modal : this.$target;\n        const targetEl = $target[0];\n\n        // Check first if the target is still visible, otherwise we have to\n        // hide it. When covering all element after scroll for instance it may\n        // have been hidden (part of an affixed header for example) or it may\n        // be outside of the viewport (the whole header during an effect for\n        // example).\n        const rect = targetEl.getBoundingClientRect();\n        // TODO: At that point, targetEl.ownerDocument.defaultView should not be\n        // null. However, there is a non-deterministic race condition that can\n        // result in the document being unloaded from the iframe before the handlers\n        // of the snippets menu are removed, thus triggering a traceback if the\n        // optional chaining operator is removed. This can be reproduced\n        // non-deterministically on runbot by running the edit_menus tour.\n        const vpWidth = targetEl.ownerDocument.defaultView?.innerWidth || document.documentElement.clientWidth;\n        const vpHeight = targetEl.ownerDocument.defaultView?.innerHeight || document.documentElement.clientHeight;\n        const isInViewport = (\n            rect.bottom > -0.1 &&\n            rect.right > -0.1 &&\n            (vpHeight - rect.top) > -0.1 &&\n            (vpWidth - rect.left) > -0.1\n        );\n        const hasSize = ( // :visible not enough for images\n            Math.abs(rect.bottom - rect.top) > 0.01 &&\n            Math.abs(rect.right - rect.left) > 0.01\n        );\n        if (!isInViewport || !hasSize || !this.$target.is(`:visible`)) {\n            this.toggleOverlayVisibility(false);\n            return;\n        }\n\n        const transform = window.getComputedStyle(targetEl).getPropertyValue('transform');\n        const transformOrigin = window.getComputedStyle(targetEl).getPropertyValue('transform-origin');\n        targetEl.classList.add('o_transform_removal');\n\n        // Now cover the element\n        const offset = $target.offset();\n\n        // The manipulator is supposed to follow the scroll of the content\n        // naturally without any JS recomputation.\n        const manipulatorOffset = this.$el.parent().offset();\n        offset.top -= manipulatorOffset.top;\n        offset.left -= manipulatorOffset.left;\n        this.$el.css({\n            width: $target.outerWidth(),\n            height: $target.outerHeight(),\n            left: offset.left,\n            top: offset.top,\n            transform,\n            'transform-origin': transformOrigin,\n        });\n        this.$('.o_handles').css('height', $target.outerHeight());\n\n        targetEl.classList.remove('o_transform_removal');\n\n        const editableOffsetTop = this.$editable.offset().top - manipulatorOffset.top;\n        this.$el.toggleClass('o_top_cover', offset.top - editableOffsetTop < 25);\n        // If the element covered by the overlay has a scrollbar, we remove its\n        // right border as it interferes with proper scrolling. (e.g. modal)\n        const handleEReadonlyEl = this.$el[0].querySelector('.o_handle.e.readonly');\n        if (handleEReadonlyEl) {\n            handleEReadonlyEl.style.width = $(targetEl).hasScrollableContent() ? 0 : '';\n        }\n    },\n    /**\n     * DOMElements have a default name which appears in the overlay when they\n     * are being edited. This method retrieves this name; it can be defined\n     * directly in the DOM thanks to the `data-translated-name` or `data-name` attribute.\n     */\n    getName: function () {\n        if (this.$target.data('translated-name') !== undefined) {\n            return this.$target.data('translated-name');\n        }\n        if (this.$target.data('name') !== undefined) {\n            return this.$target.data('name');\n        }\n        if (this.$target.is('img')) {\n            return _t(\"Image\");\n        }\n        if (this.$target.is('.fa')) {\n            return _t(\"Icon\");\n        }\n        if (this.$target.is('.media_iframe_video')) {\n            return _t(\"Video\");\n        }\n        if (this.$target.parent('.row').length) {\n            return _t(\"Column\");\n        }\n        if (this.$target.is('#wrapwrap > main')) {\n            return _t(\"Page Options\");\n        }\n        if (this.$target[0].matches(\".btn\")) {\n            return _t(\"Button\");\n        }\n        return _t(\"Block\");\n    },\n    /**\n     * @return {boolean}\n     */\n    isShown: function () {\n        return this.$el && this.$el.parent().length && this.$el.hasClass('oe_active');\n    },\n    /**\n     * @returns {boolean}\n     */\n    isSticky: function () {\n        return this.$el && this.$el.hasClass('o_we_overlay_sticky');\n    },\n    /**\n     * @returns {boolean}\n     */\n    isTargetVisible: function () {\n        return (this.$target[0].dataset.invisible !== '1');\n    },\n    /**\n     * Removes the associated snippet from the DOM and destroys the associated\n     * editor (itself).\n     *\n     * @param {boolean} [shouldRecordUndo=true]\n     * @returns {Promise}\n     */\n    removeSnippet: async function (shouldRecordUndo = true) {\n        this.options.wysiwyg.odooEditor.unbreakableStepUnactive();\n        this.toggleOverlay(false);\n        await this.toggleOptions(false);\n        // If it is an invisible element, we must close it before deleting it\n        // (e.g. modal).\n        await this.toggleTargetVisibility(!this.$target.hasClass('o_snippet_invisible'));\n        this.trigger_up('will_remove_snippet', {$target: this.$target});\n\n        // Call the onRemove of all internal options\n        await new Promise(resolve => {\n            this.trigger_up('call_for_each_child_snippet', {\n                $snippet: this.$target,\n                callback: async function (editor, $snippet) {\n                    for (var i in editor.styles) {\n                        await editor.styles[i].onRemove();\n                    }\n                },\n                onSuccess: resolve,\n            });\n        });\n\n        // TODO this should probably be awaited but this is not possible right\n        // now as removeSnippet can be called in a locked editor mutex context\n        // and would thus produce a deadlock. Also, this awaited\n        // 'activate_snippet' call would allow to remove the 'toggleOverlay' and\n        // 'toggleOptions' calls at the start of this function.\n        // TODO also to be checked: this not being awaited, the DOM is removed\n        // first, destroying the related editors and not calling onBlur... to\n        // check if this has always been like this or not and this should be\n        // unit tested.\n        let parent = this.$target[0].parentElement;\n        let nextSibling = this.$target[0].nextElementSibling;\n        while (nextSibling && !isVisible(nextSibling)) {\n            nextSibling = nextSibling.nextElementSibling;\n        }\n        let previousSibling = this.$target[0].previousElementSibling;\n        while (previousSibling && !isVisible(previousSibling)) {\n            previousSibling = previousSibling.previousElementSibling;\n        }\n        if ($(parent).is('.o_editable:not(body)')) {\n            // If we target the editable, we want to reset the selection to the\n            // body. If the editable has options, we do not want to show them.\n            parent = $(parent).closest('body');\n        }\n        const activateSnippetProm = new Promise(resolve => {\n            this.trigger_up('activate_snippet', {\n                $snippet: $(previousSibling || nextSibling || parent),\n                onSuccess: resolve,\n            });\n        });\n\n        // Actually remove the snippet and its option UI.\n        var $parent = this.$target.parent();\n        this.$target.find('*').addBack().each((index, el) => {\n            const tooltip = Tooltip.getInstance(el);\n            if (tooltip) {\n                tooltip.dispose();\n            }\n        });\n        this.$target.remove();\n        this.$el.remove();\n\n        // Resize the grid to have the correct row count.\n        // Must be done here and not in a dedicated onRemove method because\n        // onRemove is called before actually removing the element and it\n        // should be the case in order to resize the grid.\n        if (this.$target[0].classList.contains('o_grid_item')) {\n            gridUtils._resizeGrid($parent[0]);\n        }\n\n        var node = $parent[0];\n        if (node && node.firstChild) {\n            if (!node.firstChild.tagName && node.firstChild.textContent === ' ') {\n                node.removeChild(node.firstChild);\n            }\n        }\n\n        // Potentially remove ancestors (like when removing the last column of a\n        // snippet).\n        if ($parent.closest(':data(\"snippet-editor\")').length) {\n            const isEmptyAndRemovable = ($el, editor) => {\n                editor = editor || $el.data('snippet-editor');\n\n                // Consider a <figure> element as empty if it only contains a\n                // <figcaption> element (e.g., when its image has just been\n                // removed).\n                const isEmptyFigureEl = $el[0].matches(\"figure\")\n                    && $el[0].children.length === 1\n                    && $el[0].children[0].matches(\"figcaption\");\n\n                const isEmpty = isEmptyFigureEl || ($el.text().trim() === ''\n                    && $el.children().toArray().every(el => {\n                        // Consider layout-only elements (like bg-shapes) as empty\n                        return el.matches(this.layoutElementsSelector);\n                    }));\n                return isEmpty && !$el.hasClass('oe_structure')\n                    && !$el.parent().hasClass('carousel-item')\n                    && (!editor || editor.isTargetParentEditable)\n                    && !isUnremovable($el[0]);\n            };\n\n            var editor = $parent.data('snippet-editor');\n            while (!editor) {\n                var $nextParent = $parent.parent();\n                if (isEmptyAndRemovable($parent)) {\n                    $parent.remove();\n                }\n                $parent = $nextParent;\n                editor = $parent.data('snippet-editor');\n            }\n            if (isEmptyAndRemovable($parent, editor)) {\n                // TODO maybe this should be part of the actual Promise being\n                // returned by the function ?\n                setTimeout(() => editor.removeSnippet());\n            }\n        }\n\n        // Clean editor if they are image or table in deleted content\n        this.$body.find('.note-control-selection').hide();\n        this.$body.find('.o_table_handler').remove();\n\n        this.trigger_up('snippet_removed');\n        // FIXME that whole Promise should be awaited before the DOM removal etc\n        // as explained above where it is defined. However, it is critical to at\n        // least await it before destroying the snippet editor instance\n        // otherwise the logic of activateSnippet gets messed up.\n        // FIXME should not this call _destroyEditor ?\n        activateSnippetProm.then(() => this.destroy());\n        $parent.trigger('content_changed');\n\n        // TODO Page content changed, some elements may need to be adapted\n        // according to it. While waiting for a better way to handle that this\n        // window trigger will handle most cases.\n        $(window).trigger('resize');\n\n        if (shouldRecordUndo) {\n            this.options.wysiwyg.odooEditor.historyStep();\n        }\n    },\n    /**\n     * Displays/Hides the editor overlay.\n     *\n     * @param {boolean} show\n     * @param {boolean} [previewMode=false]\n     */\n    toggleOverlay: function (show, previewMode) {\n        if (!this.$el) {\n            return;\n        }\n\n        if (previewMode) {\n            // In preview mode, the sticky classes are left untouched, we only\n            // add/remove the preview class when toggling/untoggling\n            this.$el.toggleClass('o_we_overlay_preview', show);\n        } else {\n            // In non preview mode, the preview class is always removed, and the\n            // sticky class is added/removed when toggling/untoggling\n            this.$el.removeClass('o_we_overlay_preview');\n            this.$el.toggleClass('o_we_overlay_sticky', show);\n            if (!this.displayOverlayOptions) {\n                this.$el.find('.o_overlay_options_wrap').addClass('o_we_hidden_overlay_options');\n            }\n        }\n\n        // Show/hide overlay in preview mode or not\n        this.$el.toggleClass('oe_active', show);\n        this.cover();\n        this.toggleOverlayVisibility(show);\n    },\n    /**\n     * Updates the UI of the editor (+ parent) options and call onFocus/onBlur\n     * if necessary. The UI jquery elements to display are returned, it is up\n     * to the caller to actually display them or not.\n     *\n     * @param {boolean} show\n     * @returns {Promise<jQuery[]>}\n     */\n    async toggleOptions(show) {\n        if (!this.$el) {\n            return [];\n        }\n\n        if (this.areOptionsShown() === show) {\n            return null;\n        }\n\n        // All onFocus before all ui updates as the onFocus of an option might\n        // affect another option (like updating the $target)\n        const editorUIsToUpdate = [];\n        const focusOrBlur = show\n            ? async (editor, options) => {\n                for (const opt of options) {\n                    await opt.onFocus();\n                }\n                editorUIsToUpdate.push(editor);\n            }\n            : async (editor, options) => {\n                for (const opt of options) {\n                    await opt.onBlur();\n                }\n            };\n        for (const $el of this._customize$Elements) {\n            const editor = $el.data('editor');\n            const styles = sortBy(Object.values(editor.styles || {}), \"__order\");\n            await focusOrBlur(editor, styles);\n        }\n        await Promise.all(editorUIsToUpdate.map(editor => editor.updateOptionsUI()));\n        await Promise.all(editorUIsToUpdate.map(editor => editor.updateOptionsUIVisibility()));\n\n        // As the 'd-none' class is added to option sections that have no visible\n        // options with 'updateOptionsUIVisibility', if no option section is\n        // visible, we prevent the activation of the options.\n        // Special case: For now, we only allow activating text options in\n        // translate mode (with no parent editors). These text options have a\n        // special way to be displayed in the editor: We add the options in the\n        // toolbar `onFocus()` and set them back `onBlur()`. Which means the\n        // options section will be empty and get a `d-none` class, while\n        // actually it has visible options (they are just added in the toolbar\n        // DOM). We need to take them into consideration to display options in\n        // translate mode correctly.\n        const optionsSectionVisible = editorUIsToUpdate.some(editor =>\n            !editor.$optionsSection[0].classList.contains(\"d-none\") ||\n            Object.keys(editor.styles).some(key =>\n                editor.styles[key].el.closest(\".oe-toolbar\")\n            )\n        );\n        if (editorUIsToUpdate.length > 0 && !optionsSectionVisible) {\n            return null;\n        }\n        return this._customize$Elements;\n    },\n    /**\n     * @param {boolean} [show]\n     * @returns {Promise<boolean>}\n     */\n    toggleTargetVisibility: async function (show) {\n        show = this._toggleVisibilityStatus(show);\n        var styles = Object.values(this.styles);\n        const proms = sortBy(styles, \"__order\").map((style) => {\n            return show ? style.onTargetShow() : style.onTargetHide();\n        });\n        await Promise.all(proms);\n        return show;\n    },\n    /**\n     * @param {boolean} [show=false]\n     */\n    toggleOverlayVisibility: function (show) {\n        if (this.$el && !this.scrollingTimeout) {\n            this.$el.toggleClass('o_overlay_hidden', (!show || this.$target[0].matches('.o_animating:not(.o_animate_on_scroll)')) && this.isShown());\n        }\n    },\n    /**\n     * Updates the UI of all the options according to the status of their\n     * associated editable DOM. This does not take care of options *visibility*.\n     * For that @see updateOptionsUIVisibility, which should called when the UI\n     * is up-to-date thanks to the function here, as the visibility depends on\n     * the UI's status.\n     *\n     * @param {boolean} [assetsChanged=false]\n     * @returns {Promise}\n     */\n    async updateOptionsUI(assetsChanged) {\n        const proms = Object.values(this.styles).map(opt => {\n            return opt.updateUI({noVisibility: true, assetsChanged: assetsChanged});\n        });\n        return Promise.all(proms);\n    },\n    /**\n     * Updates the visibility of the UI of all the options according to the\n     * status of their associated dependencies and related editable DOM status.\n     *\n     * @returns {Promise}\n     */\n    async updateOptionsUIVisibility() {\n        const proms = Object.values(this.styles).map(opt => {\n            return opt.updateUIVisibility();\n        });\n        await Promise.all(proms);\n        // Hide the snippetEditor if none of its options are visible\n        // This cannot be done using the visibility of the options' UI\n        // because some options can be located in the overlay.\n        const $visibleOptions = this.$optionsSection.find('we-top-button-group, we-customizeblock-option')\n                .children(':not(.d-none)');\n        this.$optionsSection.toggleClass('d-none', !$visibleOptions.length);\n    },\n    /**\n     * Clones the current snippet.\n     *\n     * @param {boolean} recordUndo\n     */\n    clone: async function (recordUndo) {\n        this.trigger_up('snippet_will_be_cloned', {$target: this.$target});\n\n        await new Promise(resolve => {\n            this.trigger_up(\"clean_ui_request\", {\n                targetEl: this.$target[0],\n                onSuccess: resolve,\n            });\n        });\n\n        var $clone = this.$target.clone(false);\n\n        this.$target.after($clone);\n\n        if (recordUndo) {\n            this.options.wysiwyg.odooEditor.historyStep(true);\n        }\n        await new Promise(resolve => {\n            this.trigger_up('call_for_each_child_snippet', {\n                $snippet: $clone,\n                callback: function (editor, $snippet) {\n                    for (var i in editor.styles) {\n                        editor.styles[i].onClone({\n                            isCurrent: ($snippet.is($clone)),\n                        });\n                    }\n                },\n                onSuccess: resolve,\n            });\n        });\n        this.trigger_up('snippet_cloned', {$target: $clone, $origin: this.$target});\n\n        $clone.trigger('content_changed');\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Instantiates the snippet's options.\n     *\n     * @private\n     */\n    _initializeOptions: function () {\n        this._customize$Elements = [];\n        this.styles = {};\n        this.selectorSiblings = [];\n        this.selectorChildren = [];\n        this.selectorLockWithin = new Set();\n        const selectorExcludeAncestor = new Set();\n\n        var $element = this.$target.parent();\n        while ($element.length) {\n            var parentEditor = $element.data('snippet-editor');\n            if (parentEditor) {\n                this._customize$Elements = this._customize$Elements\n                    .concat(parentEditor._customize$Elements);\n                break;\n            }\n            $element = $element.parent();\n        }\n\n        var $optionsSection = $(renderToElement('web_editor.customize_block_options_section', {\n            name: this.getName(),\n        })).data('editor', this);\n        const $optionsSectionBtnGroup = $optionsSection.find('we-top-button-group');\n        $optionsSectionBtnGroup.contents().each((i, node) => {\n            if (node.nodeType === Node.TEXT_NODE) {\n                node.parentNode.removeChild(node);\n            }\n        });\n        this.$optionsSection = $optionsSection;\n        $optionsSection.on('mouseenter', this._onOptionsSectionMouseEnter.bind(this));\n        $optionsSection.on('mouseleave', this._onOptionsSectionMouseLeave.bind(this));\n        $optionsSection.on('click', 'we-title > span', this._onOptionsSectionClick.bind(this));\n        $optionsSection.on('click', '.oe_snippet_clone', this._onCloneClick.bind(this));\n        $optionsSection.on('click', '.oe_snippet_remove', this._onRemoveClick.bind(this));\n        this._customize$Elements.push($optionsSection);\n\n        // TODO get rid of this when possible (made as a fix to support old\n        // theme options)\n        this.$el.data('$optionsSection', $optionsSection);\n\n        var i = 0;\n        var defs = this.templateOptions.map((val) => {\n            if (!val.selector.is(this.$target)) {\n                return;\n            }\n            if (val.data.string) {\n                $optionsSection[0].querySelector('we-title > span').textContent = val.data.string;\n            }\n            if (val['drop-near']) {\n                this.selectorSiblings.push(val['drop-near']);\n            }\n            if (val['drop-in']) {\n                this.selectorChildren.push(val['drop-in']);\n            }\n            if (val['drop-lock-within']) {\n                this.selectorLockWithin.add(val['drop-lock-within']);\n            }\n            if (val['drop-exclude-ancestor']) {\n                selectorExcludeAncestor.add(val['drop-exclude-ancestor']);\n            }\n\n            var optionName = val.option;\n            var option = new (options.registry[optionName] || options.Class)(\n                this,\n                val.$el.children(),\n                val.base_target ? this.$target.find(val.base_target).eq(0) : this.$target,\n                this.$el,\n                Object.assign({\n                    optionName: optionName,\n                    snippetName: this.getName(),\n                }, val.data),\n                this.options\n            );\n            var key = optionName || uniqueId(\"option\");\n            if (this.styles[key]) {\n                // If two snippet options use the same option name (and so use\n                // the same JS option), store the subsequent ones with a unique\n                // ID (TODO improve)\n                key = uniqueId(key);\n            }\n            this.styles[key] = option;\n            option.__order = i++;\n\n            if (option.forceNoDeleteButton) {\n                this.$el.add($optionsSection).find('.oe_snippet_remove').addClass('d-none');\n                this.$el.add($optionsSection).find('.oe_snippet_clone').addClass('d-none');\n            }\n\n            if (option.displayOverlayOptions) {\n                this.displayOverlayOptions = true;\n            }\n\n            if (option.forceDuplicateButton) {\n                this.forceDuplicateButton = true;\n            }\n\n            return option.appendTo(document.createDocumentFragment());\n        });\n\n        if (selectorExcludeAncestor.size) {\n            // Prevents dropping an element into another one.\n            // (E.g. ToC inside another ToC)\n            const excludedAncestorSelector = [...selectorExcludeAncestor].join(\", \");\n            this.excludeAncestors = (i, el) => !el.closest(excludedAncestorSelector);\n        }\n\n        this.isTargetMovable = (this.selectorSiblings.length > 0 || this.selectorChildren.length > 0);\n\n        this.$el.find('[data-bs-toggle=\"dropdown\"]').dropdown();\n\n        return Promise.all(defs).then(async () => {\n            const options = sortBy(Object.values(this.styles), \"__order\");\n            const firstOptions = [];\n            options.forEach(option => {\n                if (option.isTopOption) {\n                    if (option.isTopFirstOption) {\n                        firstOptions.push(option);\n                    } else {\n                        $optionsSectionBtnGroup.prepend(option.$el);\n                    }\n                } else {\n                    $optionsSection.append(option.$el);\n                }\n            });\n            firstOptions.forEach(option => {\n                $optionsSectionBtnGroup.prepend(option.$el);\n            });\n            $optionsSection.toggleClass('d-none', options.length === 0);\n        });\n    },\n    /**\n     * Initialize drag and drop handlers.\n     *\n     * @private\n     * @param {String} handle css selector for grabble element\n     * @param {String} elementsSelector selector for elements that will be dragged.\n     * @param {HTMLElement} element element to listen for drag events.\n     * @returns {Object} the drag state.\n     */\n    _initDragAndDrop(handle, elementsSelector, element) {\n        const modalAncestorEl = this.$target[0].closest('.modal');\n        const $scrollable = modalAncestorEl && $(modalAncestorEl)\n            || (this.options.wysiwyg.snippetsMenu && this.options.wysiwyg.snippetsMenu.$scrollable)\n            || (this.$scrollingElement.length && this.$scrollingElement)\n            || $().getScrollingElement(this.ownerDocument);\n        const dragAndDropOptions = {\n            ref: { el: element },\n            elements: elementsSelector,\n            handle: handle,\n            scrollingElement: $scrollable[0],\n            enable: () => !!this.$el.find('.o_move_handle:visible').length || this.dragStarted,\n            helper: () => {\n                const cloneEl = this.$el[0].cloneNode(true);\n                cloneEl.style.width = \"24px\";\n                cloneEl.style.height = \"24px\";\n                cloneEl.style.border = \"0\";\n                this.$el[0].ownerDocument.body.appendChild(cloneEl);\n                cloneEl.classList.remove(\"d-none\");\n                cloneEl.classList.remove(\"o_dragged\");\n                return cloneEl;\n            },\n            onDragStart: (args) => {\n                this.dragStarted = true;\n                const targetRect = this.$target[0].getBoundingClientRect();\n                // Bound the Y mouse position to the element height minus one\n                // grid row, to be able to drag from the bottom in a grid.\n                const gridRowSize = gridUtils.rowSize;\n                const boundedYMousePosition = Math.min(args.y, targetRect.bottom - gridRowSize);\n                this.mousePositionYOnElement = boundedYMousePosition - targetRect.y;\n                this.mousePositionXOnElement = args.x - targetRect.x;\n                this._onDragAndDropStart(args);\n            },\n            onDragEnd: (...args) => {\n                if (!this.dragStarted) {\n                    return false;\n                }\n                this.dragStarted = false;\n                // Delay our stop handler so that some wysiwyg handlers\n                // which occur on mouseup (and are themself delayed) are\n                // executed first (this prevents the library to crash\n                // because our stop handler may change the DOM).\n                setTimeout(() => {\n                    this._onDragAndDropStop(...args);\n                }, 0);\n            },\n            onDrag: this._onDragMove.bind(this),\n            dropzoneOver: this.dropzoneOver.bind(this),\n            dropzoneOut: this.dropzoneOut.bind(this),\n            dropzones: () => this.$dropZones?.toArray() || [],\n        };\n        const finalOptions = this.options.getDragAndDropOptions(dragAndDropOptions);\n        return useDragAndDrop(finalOptions);\n    },\n    /**\n     * @private\n     * @param {boolean} [show]\n     */\n    _toggleVisibilityStatus: function (show) {\n        // TODO In master differentiate device-based visibility.\n        if (this._toggleVisibilityStatusIgnoreDeviceVisibility) {\n            if (this.$target[0].matches(\".o_snippet_mobile_invisible, .o_snippet_desktop_invisible\")) {\n                const isMobilePreview = weUtils.isMobileView(this.$target[0]);\n                const isMobileHidden = this.$target[0].classList.contains(\"o_snippet_mobile_invisible\");\n                if (isMobilePreview === isMobileHidden) {\n                    // Preview mode and hidden type are the same.\n                    show = false;\n                }\n            }\n        }\n        if (show === undefined) {\n            show = !this.isTargetVisible();\n        }\n        if (show) {\n            delete this.$target[0].dataset.invisible;\n        } else {\n            this.$target[0].dataset.invisible = '1';\n        }\n        return show;\n    },\n    /**\n     * Returns false if the element matches a snippet block that cannot be\n     * dropped in a sanitized HTML field or a string representing a specific\n     * reason. Returns true if no such issue exists.\n     *\n     * @param {Element} el\n     * @return {boolean|str} str indicates a specific type of forbidden sanitization\n     */\n    _canBeSanitizedUnless(el) {\n        let result = true;\n        for (const snippetEl of [el, ...el.querySelectorAll('[data-snippet]')]) {\n            this.trigger_up('find_snippet_template', {\n                snippet: snippetEl,\n                callback: function (snippetTemplate) {\n                    const forbidSanitize = snippetTemplate.dataset.oeForbidSanitize;\n                    if (forbidSanitize) {\n                        result = forbidSanitize === 'form' ? 'form' : false;\n                    }\n                },\n            });\n            // If some element in the block is already fully non-sanitizable,\n            // the whole block cannot be sanitized.\n            if (!result) {\n                break;\n            }\n        }\n        return result;\n    },\n    /**\n     * Called when an \"over\" dropzone event happens after an other \"over\"\n     * without an \"out\" between them. It escapes the previous dropzone.\n     *\n     * @private\n     * @param {Object} self\n     *      the same `self` variable as when we are in `_onDragAndDropStart`\n     * @param {Element} currentDropzoneEl\n     *      the dropzone over which we are currently dragging\n     */\n    _outPreviousDropzone(self, currentDropzoneEl) {\n        const previousDropzoneEl = this;\n        const rowEl = previousDropzoneEl.parentNode;\n\n        if (rowEl.classList.contains('o_grid_mode')) {\n            self.dragState.gridMode = false;\n            const fromGridToGrid = currentDropzoneEl.classList.contains('oe_grid_zone');\n            if (fromGridToGrid) {\n                // If we went from a grid dropzone to an other grid one.\n                rowEl.style.removeProperty('position');\n            } else {\n                // If we went from a grid dropzone to a normal one.\n                gridUtils._gridCleanUp(rowEl, self.$target[0]);\n                self.$target[0].style.removeProperty('z-index');\n            }\n\n            // Removing the drag helper and the background grid and\n            // resizing the grid and the dropzone.\n            self.dragState.dragHelperEl.remove();\n            self.dragState.backgroundGridEl.remove();\n            self.options.wysiwyg.odooEditor.observerActive('dragAndDropMoveSnippet');\n            gridUtils._resizeGrid(rowEl);\n            self.options.wysiwyg.odooEditor.observerUnactive('dragAndDropMoveSnippet');\n            const rowCount = parseInt(rowEl.dataset.rowCount);\n            previousDropzoneEl.style.gridRowEnd = Math.max(rowCount + 1, 1);\n        }\n        previousDropzoneEl.classList.remove('invisible');\n    },\n    /**\n     * Changes some behaviors before the drag and drop.\n     *\n     * @private\n     * @returns {Function} a function that restores what was changed when the\n     *  drag and drop is over.\n     */\n    _prepareDrag() {\n        return () => {};\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Called when the 'clone' button is clicked.\n     *\n     * @private\n     * @param {Event} ev\n     */\n    _onCloneClick: function (ev) {\n        ev.preventDefault();\n        this.clone(true);\n    },\n    /**\n     * Called when the snippet is starting to be dragged thanks to the 'move'\n     * button.\n     *\n     * @private\n     */\n    _onDragAndDropStart({ helper, addStyle }) {\n        this.options.wysiwyg.odooEditor.observerUnactive('dragAndDropMoveSnippet');\n        this.trigger_up('drag_and_drop_start');\n        this.options.wysiwyg.odooEditor.automaticStepUnactive();\n        var self = this;\n        this.dragState = {};\n        const rowEl = this.$target[0].parentNode;\n        this.dragState.overFirstDropzone = true;\n\n        this.dragState.restore = this._prepareDrag();\n\n        // Allow the grid mode if the option is present in the right panel or\n        // if the grid mode is already activated.\n        let hasGridLayoutOption = false;\n        this.trigger_up('user_value_widget_request', {\n            name: 'grid_mode',\n            allowParentOption: true,\n            onSuccess: (widget) => {\n                // The grid option is considered as present only if the\n                // container element having it is the same as the container of\n                // the column we are dragging.\n                if (widget.$target[0] === rowEl.parentElement) {\n                    hasGridLayoutOption = true;\n                }\n            },\n        });\n        const allowGridMode = hasGridLayoutOption || rowEl.classList.contains('o_grid_mode');\n\n        // Number of grid columns and rows in the grid item (BS column).\n        if (rowEl.classList.contains('row') && this.options.isWebsite) {\n            if (allowGridMode) {\n                // Toggle grid mode if it is not already on.\n                if (!rowEl.classList.contains('o_grid_mode')) {\n                    this.options.wysiwyg.odooEditor.observerActive('dragAndDropMoveSnippet');\n                    const containerEl = rowEl.parentNode;\n                    gridUtils._toggleGridMode(containerEl);\n                    this.options.wysiwyg.odooEditor.observerUnactive('dragAndDropMoveSnippet');\n                }\n\n                // Computing the moving column width and height in terms of columns\n                // and rows.\n                const columnStart = self.$target[0].style.gridColumnStart;\n                const columnEnd = self.$target[0].style.gridColumnEnd;\n                const rowStart = self.$target[0].style.gridRowStart;\n                const rowEnd = self.$target[0].style.gridRowEnd;\n\n                this.dragState.columnColCount = columnEnd - columnStart;\n                this.dragState.columnRowCount = rowEnd - rowStart;\n\n                // Storing the current grid and grid area to use them for the\n                // history.\n                this.dragState.startingGrid = rowEl;\n                this.dragState.prevGridArea = self.$target[0].style.gridArea;\n\n                this.dragState.startingZIndex = self.$target[0].style.zIndex;\n\n                // Reload the images.\n                gridUtils._reloadLazyImages(this.$target[0]);\n            } else {\n                // If the column comes from a snippet that doesn't toggle the\n                // grid mode on drag, store its width and height to use them\n                // when the column goes over a grid dropzone.\n                const isImageColumn = gridUtils._checkIfImageColumn(this.$target[0]);\n                if (isImageColumn) {\n                    // Store the image width and height if the column only\n                    // contains an image.\n                    const imageEl = this.$target[0].querySelector('img');\n                    this.dragState.columnWidth = parseFloat(imageEl.scrollWidth);\n                    this.dragState.columnHeight = parseFloat(imageEl.scrollHeight);\n                } else {\n                    this.dragState.columnWidth = parseFloat(this.$target[0].scrollWidth);\n                    this.dragState.columnHeight = parseFloat(this.$target[0].scrollHeight);\n                }\n                // Taking the column borders into account.\n                const style = window.getComputedStyle(this.$target[0]);\n                this.dragState.columnWidth += parseFloat(style.borderLeft) + parseFloat(style.borderRight);\n                this.dragState.columnHeight += parseFloat(style.borderTop) + parseFloat(style.borderBottom);\n            }\n            // Storing the starting top position of the column.\n            this.dragState.columnTop = this.$target[0].getBoundingClientRect().top;\n            this.dragState.isColumn = true;\n            // Deactivate the snippet so the overlay doesn't show.\n            this.trigger_up('deactivate_snippet', {$snippet: self.$target});\n        }\n\n        // If the target has a mobile order class, store its parent and order.\n        const targetMobileOrder = this.$target[0].style.order;\n        if (targetMobileOrder) {\n            this.dragState.startingParent = this.$target[0].parentNode;\n            this.dragState.mobileOrder = parseInt(targetMobileOrder);\n        }\n\n        const toInsertInline = window.getComputedStyle(this.$target[0]).display.includes('inline');\n\n        this.dropped = false;\n        this._dropSiblings = {\n            prev: self.$target.prev()[0],\n            next: self.$target.next()[0],\n        };\n        self.size = {\n            width: self.$target.width(),\n            height: self.$target.height()\n        };\n        const dropCloneEl = document.createElement(\"div\");\n        dropCloneEl.classList.add(\"oe_drop_clone\");\n        dropCloneEl.style.setProperty(\"display\", \"none\");\n        self.$target[0].after(dropCloneEl);\n        self.$target.detach();\n        self.$el.addClass('d-none');\n\n        var $selectorSiblings;\n        for (var i = 0; i < self.selectorSiblings.length; i++) {\n            let $siblings = self.selectorSiblings[i].all();\n            if (this.excludeAncestors) {\n                $siblings = $siblings.filter(this.excludeAncestors);\n            }\n            $selectorSiblings = $selectorSiblings ? $selectorSiblings.add($siblings) : $siblings;\n        }\n        var $selectorChildren;\n        for (i = 0; i < self.selectorChildren.length; i++) {\n            let $children = self.selectorChildren[i].all();\n            if (this.excludeAncestors) {\n                $children = $children.filter(this.excludeAncestors);\n            }\n            $selectorChildren = $selectorChildren ? $selectorChildren.add($children) : $children;\n        }\n        // Disallow dropping an element outside a given direct or\n        // indirect parent. (E.g. form field must remain within its own form)\n        for (const lockedParentSelector of this.selectorLockWithin) {\n            const closestLockedParentEl = dropCloneEl.closest(lockedParentSelector);\n            const filterFunc = (i, el) => el.closest(lockedParentSelector) === closestLockedParentEl;\n            if ($selectorSiblings) {\n                $selectorSiblings = $selectorSiblings.filter(filterFunc);\n            }\n            if ($selectorChildren) {\n                $selectorChildren = $selectorChildren.filter(filterFunc);\n            }\n        }\n\n        const canBeSanitizedUnless = this._canBeSanitizedUnless(this.$target[0]);\n\n        // Remove the siblings/children that would add a dropzone as direct\n        // child of a grid area and make a dedicated set out of the identified\n        // grid areas.\n        const selectorGrids = new Set();\n        const filterOutSelectorGrids = ($selectorItems, getDropzoneParent) => {\n            if (!$selectorItems) {\n                return;\n            }\n            // Looping backwards because elements are removed, so the\n            // indexes are not lost.\n            for (let i = $selectorItems.length - 1; i >= 0; i--) {\n                const el = getDropzoneParent($selectorItems[i]);\n                if (el.classList.contains('o_grid_mode')) {\n                    $selectorItems.splice(i, 1);\n                    selectorGrids.add(el);\n                }\n            }\n        };\n        filterOutSelectorGrids($selectorSiblings, el => el.parentElement);\n        filterOutSelectorGrids($selectorChildren, el => el);\n\n        this.trigger_up('activate_snippet', {$snippet: this.$target.parent()});\n        this.trigger_up('activate_insertion_zones', {\n            $selectorSiblings: $selectorSiblings,\n            $selectorChildren: $selectorChildren,\n            canBeSanitizedUnless: canBeSanitizedUnless,\n            toInsertInline: toInsertInline,\n            selectorGrids: selectorGrids,\n            fromIframe: true,\n        });\n\n        this.$body.addClass('move-important');\n\n        this.$dropZones = this.$editable.find('.oe_drop_zone');\n        if (!canBeSanitizedUnless) {\n            this.$dropZones = this.$dropZones.not('[data-oe-sanitize] .oe_drop_zone');\n        } else if (canBeSanitizedUnless === 'form') {\n            this.$dropZones = this.$dropZones.not('[data-oe-sanitize][data-oe-sanitize!=\"allow_form\"] .oe_drop_zone');\n        }\n    },\n    dropzoneOver({ dropzone }) {\n        if (this.dropped) {\n            this.$target.detach();\n        }\n\n        // Prevent a column to be trapped in an upper grid dropzone at\n        // the start of the drag.\n        if (this.dragState.isColumn && this.dragState.overFirstDropzone) {\n            this.dragState.overFirstDropzone = false;\n\n            // The column is considered as glued to the dropzone if the\n            // dropzone is above and if the space between them is less\n            // than 25px (the move handle height is 22px so 25 is a\n            // safety margin).\n            const columnTop = this.dragState.columnTop;\n            const dropzoneBottom = dropzone.el.getBoundingClientRect().bottom;\n            const areDropzonesGlued = (columnTop >= dropzoneBottom) && (columnTop - dropzoneBottom < 25);\n\n            if (areDropzonesGlued && dropzone.el.classList.contains('oe_grid_zone')) {\n                return;\n            }\n        }\n\n        this.dropped = true;\n        const $dropzone = $(dropzone.el).first().after(this.$target);\n        $dropzone.addClass('invisible');\n\n        // Checking if the \"out\" event happened before dropzone.el \"over\": if\n        // `this.dragState.currentDropzoneEl` exists, \"out\" didn't\n        // happen because it deletes it. We are therefore in the case\n        // of an \"over\" after an \"over\" and we need to escape the\n        // previous dropzone first.\n        if (this.dragState.currentDropzoneEl) {\n            this._outPreviousDropzone.apply(this.dragState.currentDropzoneEl, [this, $dropzone[0]]);\n        }\n        this.dragState.currentDropzoneEl = $dropzone[0];\n\n        if ($dropzone[0].classList.contains('oe_grid_zone')) {\n            // Case where the column we are dragging is over a grid\n            // dropzone.\n            const rowEl = $dropzone[0].parentNode;\n\n            // If the column doesn't come from a grid mode snippet.\n            if (!this.$target[0].classList.contains('o_grid_item')) {\n                // Converting the column to grid.\n                this.options.wysiwyg.odooEditor.observerActive('dragAndDropMoveSnippet');\n                const spans = gridUtils._convertColumnToGrid(rowEl, this.$target[0], this.dragState.columnWidth, this.dragState.columnHeight);\n                this.options.wysiwyg.odooEditor.observerUnactive('dragAndDropMoveSnippet');\n                this.dragState.columnColCount = spans.columnColCount;\n                this.dragState.columnRowCount = spans.columnRowCount;\n\n                // Storing the column spans.\n            }\n\n            const columnColCount = this.dragState.columnColCount;\n            const columnRowCount = this.dragState.columnRowCount;\n            // Creating the drag helper.\n            const dragHelperEl = document.createElement('div');\n            dragHelperEl.classList.add('o_we_drag_helper');\n            dragHelperEl.style.gridArea = `1 / 1 / ${1 + columnRowCount} / ${1 + columnColCount}`;\n            rowEl.append(dragHelperEl);\n\n            // Creating the background grid and updating the dropzone\n            // (in the case where the column over the dropzone is\n            // bigger than the grid).\n            const backgroundGridEl = gridUtils._addBackgroundGrid(rowEl, columnRowCount);\n            const rowCount = Math.max(rowEl.dataset.rowCount, columnRowCount);\n            $dropzone[0].style.gridRowEnd = rowCount + 1;\n\n            this.options.wysiwyg.odooEditor.observerActive('dragAndDropMoveSnippet');\n            // Setting the moving grid item, the background grid and\n            // the drag helper z-indexes. The grid item z-index is set\n            // to its original one if we are in its starting grid, or\n            // to the maximum z-index of the grid otherwise.\n            if (rowEl === this.dragState.startingGrid) {\n                this.$target[0].style.zIndex = this.dragState.startingZIndex;\n            } else {\n                gridUtils._setElementToMaxZindex(this.$target[0], rowEl);\n            }\n            gridUtils._setElementToMaxZindex(backgroundGridEl, rowEl);\n            gridUtils._setElementToMaxZindex(dragHelperEl, rowEl);\n\n            // Setting the column height and width to keep its size\n            // when the grid-area is removed (as it prevents it from\n            // moving with the mouse).\n            const gridProp = gridUtils._getGridProperties(rowEl);\n            const columnHeight = columnRowCount * (gridProp.rowSize + gridProp.rowGap) - gridProp.rowGap;\n            const columnWidth = columnColCount * (gridProp.columnSize + gridProp.columnGap) - gridProp.columnGap;\n            this.$target[0].style.height = columnHeight + 'px';\n            this.$target[0].style.width = columnWidth + 'px';\n            this.$target[0].style.position = 'absolute';\n            this.$target[0].style.removeProperty('grid-area');\n            rowEl.style.position = 'relative';\n            this.options.wysiwyg.odooEditor.observerUnactive('dragAndDropMoveSnippet');\n\n            // Storing useful information and adding an event listener.\n            this.dragState.startingHeight = rowEl.clientHeight;\n            this.dragState.currentHeight = rowEl.clientHeight;\n            this.dragState.dragHelperEl = dragHelperEl;\n            this.dragState.backgroundGridEl = backgroundGridEl;\n            this.dragState.gridMode = true;\n        }\n    },\n    dropzoneOut({ dropzone }) {\n        const rowEl = dropzone.el.parentNode;\n\n        // Checking if the \"out\" event happens right after the \"over\"\n        // of the same dropzone. If it is not the case, we don't do\n        // anything since the previous dropzone was already escaped (at\n        // the start of the over).\n        const sameDropzoneAsCurrent = this.dragState.currentDropzoneEl === dropzone.el;\n\n        if (sameDropzoneAsCurrent) {\n            if (rowEl.classList.contains('o_grid_mode')) {\n                // Removing the listener + cleaning.\n                this.dragState.gridMode = false;\n                gridUtils._gridCleanUp(rowEl, this.$target[0]);\n                this.$target[0].style.removeProperty('z-index');\n\n                // Removing the drag helper and the background grid and\n                // resizing the grid and the dropzone.\n                this.dragState.dragHelperEl.remove();\n                this.dragState.backgroundGridEl.remove();\n                this.options.wysiwyg.odooEditor.observerActive('dragAndDropMoveSnippet');\n                gridUtils._resizeGrid(rowEl);\n                this.options.wysiwyg.odooEditor.observerUnactive('dragAndDropMoveSnippet');\n                const rowCount = parseInt(rowEl.dataset.rowCount);\n                dropzone.el.style.gridRowEnd = Math.max(rowCount + 1, 1);\n            }\n\n            var prev = this.$target.prev();\n            if (dropzone.el === prev[0]) {\n                this.dropped = false;\n                this.$target.detach();\n                $(dropzone.el).removeClass('invisible');\n            }\n\n            delete this.dragState.currentDropzoneEl;\n        }\n    },\n    /**\n     * Called when the snippet is dropped after being dragged thanks to the\n     * 'move' button.\n     *\n     * @private\n     * @param {Event} ev\n     * @param {Object} ui\n     */\n    _onDragAndDropStop({ x, y }) {\n        this.options.wysiwyg.odooEditor.automaticStepActive();\n        this.options.wysiwyg.odooEditor.automaticStepSkipStack();\n        this.options.wysiwyg.odooEditor.unbreakableStepUnactive();\n\n        const rowEl = this.$target[0].parentNode;\n        if (rowEl && rowEl.classList.contains('o_grid_mode')) {\n            // Case when dropping the column in a grid.\n\n            // Disable dragMove handler\n            this.dragState.gridMode = false;\n\n            // Defining the column grid area with its position.\n            const gridProp = gridUtils._getGridProperties(rowEl);\n\n            const style = window.getComputedStyle(this.$target[0]);\n            const top = parseFloat(style.top);\n            const left = parseFloat(style.left);\n\n            const rowStart = Math.round(top / (gridProp.rowSize + gridProp.rowGap)) + 1;\n            const columnStart = Math.round(left / (gridProp.columnSize + gridProp.columnGap)) + 1;\n            const rowEnd = rowStart + this.dragState.columnRowCount;\n            const columnEnd = columnStart + this.dragState.columnColCount;\n\n            this.$target[0].style.gridArea = `${rowStart} / ${columnStart} / ${rowEnd} / ${columnEnd}`;\n\n            // Cleaning, removing the drag helper and the background grid and\n            // resizing the grid.\n            gridUtils._gridCleanUp(rowEl, this.$target[0]);\n            this.dragState.dragHelperEl.remove();\n            this.dragState.backgroundGridEl.remove();\n            this.options.wysiwyg.odooEditor.observerActive('dragAndDropMoveSnippet');\n            gridUtils._resizeGrid(rowEl);\n            this.options.wysiwyg.odooEditor.observerUnactive('dragAndDropMoveSnippet');\n        } else if (this.$target[0].classList.contains('o_grid_item') && this.dropped) {\n            // Case when dropping a grid item in a non-grid dropzone.\n            this.options.wysiwyg.odooEditor.observerActive('dragAndDropMoveSnippet');\n            gridUtils._convertToNormalColumn(this.$target[0]);\n            this.options.wysiwyg.odooEditor.observerUnactive('dragAndDropMoveSnippet');\n        }\n\n        // TODO lot of this is duplicated code of the d&d feature of snippets\n        if (!this.dropped) {\n            let $el = $(closest(this.$body[0].querySelectorAll('.oe_drop_zone'), {x, y}));\n            // Some drop zones might have been disabled.\n            $el = $el.filter(this.$dropZones);\n            if ($el.length) {\n                $el.after(this.$target);\n                // If the column is not dropped inside a dropzone.\n                if ($el[0].classList.contains('oe_grid_zone')) {\n                    // Case when a column is dropped near a grid.\n                    const rowEl = $el[0].parentNode;\n\n                    // If the column doesn't come from a snippet in grid mode,\n                    // convert it.\n                    if (!this.$target[0].classList.contains('o_grid_item')) {\n                        this.options.wysiwyg.odooEditor.observerActive('dragAndDropMoveSnippet');\n                        const spans = gridUtils._convertColumnToGrid(rowEl, this.$target[0], this.dragState.columnWidth, this.dragState.columnHeight);\n                        this.options.wysiwyg.odooEditor.observerUnactive('dragAndDropMoveSnippet');\n                        this.dragState.columnColCount = spans.columnColCount;\n                        this.dragState.columnRowCount = spans.columnRowCount;\n                    }\n\n                    // Placing it in the top left corner.\n                    this.options.wysiwyg.odooEditor.observerActive('dragAndDropMoveSnippet');\n                    this.$target[0].style.gridArea = `1 / 1 / ${1 + this.dragState.columnRowCount} / ${1 + this.dragState.columnColCount}`;\n                    const rowCount = Math.max(rowEl.dataset.rowCount, this.dragState.columnRowCount);\n                    rowEl.dataset.rowCount = rowCount;\n                    this.options.wysiwyg.odooEditor.observerUnactive('dragAndDropMoveSnippet');\n\n                    // Setting the grid item z-index.\n                    if (rowEl === this.dragState.startingGrid) {\n                        this.$target[0].style.zIndex = this.dragState.startingZIndex;\n                    } else {\n                        gridUtils._setElementToMaxZindex(this.$target[0], rowEl);\n                    }\n                } else {\n                    if (this.$target[0].classList.contains('o_grid_item')) {\n                        // Case when a grid column is dropped near a non-grid\n                        // dropzone.\n                        this.options.wysiwyg.odooEditor.observerActive('dragAndDropMoveSnippet');\n                        gridUtils._convertToNormalColumn(this.$target[0]);\n                        this.options.wysiwyg.odooEditor.observerUnactive('dragAndDropMoveSnippet');\n                    }\n                }\n\n                this.dropped = true;\n            }\n        }\n\n        // Resize the grid from where the column came from (if any), as it may\n        // have not been resized if the column did not go over it.\n        if (this.dragState.startingGrid) {\n            this.options.wysiwyg.odooEditor.observerActive('dragAndDropMoveSnippet');\n            gridUtils._resizeGrid(this.dragState.startingGrid);\n            this.options.wysiwyg.odooEditor.observerUnactive('dragAndDropMoveSnippet');\n        }\n\n        this.$editable.find('.oe_drop_zone').remove();\n\n        var prev = this.$target.first()[0].previousSibling;\n        var next = this.$target.last()[0].nextSibling;\n        var $parent = this.$target.parent();\n\n        var $clone = this.$editable.find('.oe_drop_clone');\n        if (prev === $clone[0]) {\n            prev = $clone[0].previousSibling;\n        } else if (next === $clone[0]) {\n            next = $clone[0].nextSibling;\n        }\n        $clone.after(this.$target);\n        var $from = $clone.parent();\n\n        this.$el.removeClass('d-none');\n        this.$body.removeClass('move-important');\n        $clone.remove();\n\n        this.options.wysiwyg.odooEditor.observerActive('dragAndDropMoveSnippet');\n        if (this.dropped) {\n            if (prev) {\n                this.$target.insertAfter(prev);\n            } else if (next) {\n                this.$target.insertBefore(next);\n            } else {\n                $parent.prepend(this.$target);\n            }\n\n            for (var i in this.styles) {\n                this.styles[i].onMove();\n            }\n\n            // If the target has a mobile order class, and if it was dropped in\n            // another snippet, fill the gap left in the starting snippet.\n            if (this.dragState.mobileOrder !== undefined\n                && this.$target[0].parentNode !== this.dragState.startingParent) {\n                ColumnLayoutMixin._fillRemovedItemGap(this.dragState.startingParent, this.dragState.mobileOrder);\n            }\n\n            this.$target.trigger('content_changed');\n            $from.trigger('content_changed');\n        }\n\n        this.trigger_up('drag_and_drop_stop', {\n            $snippet: this.$target,\n        });\n        const samePositionAsStart = this.$target[0].classList.contains('o_grid_item')\n            ? (this.$target[0].parentNode === this.dragState.startingGrid\n                && this.$target[0].style.gridArea === this.dragState.prevGridArea)\n            : this._dropSiblings.prev === this.$target.prev()[0] && this._dropSiblings.next === this.$target.next()[0];\n        if (!samePositionAsStart) {\n            this.options.wysiwyg.odooEditor.historyStep();\n        }\n\n        this.dragState.restore();\n\n        delete this.$dropZones;\n        delete this.dragState;\n    },\n    /**\n     * @private\n     */\n    _onOptionsSectionMouseEnter: function (ev) {\n        if (!this.$target.is(':visible')) {\n            return;\n        }\n        this.trigger_up('activate_snippet', {\n            $snippet: this.$target,\n            previewMode: true,\n        });\n    },\n    /**\n     * @private\n     */\n    _onOptionsSectionMouseLeave: function (ev) {\n        this.trigger_up('activate_snippet', {\n            $snippet: false,\n            previewMode: true,\n        });\n    },\n    /**\n     * @private\n     */\n    _onOptionsSectionClick: function (ev) {\n        this.trigger_up('activate_snippet', {\n            $snippet: this.$target,\n            previewMode: false,\n        });\n    },\n    /**\n     * Called when a child editor/option asks for another option to perform a\n     * specific action/react to a specific event.\n     *\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onOptionUpdate: function (ev) {\n        var self = this;\n\n        // If multiple option names are given, we suppose it should not be\n        // propagated to parent editor\n        if (ev.data.optionNames) {\n            ev.stopPropagation();\n            ev.data.optionNames.forEach((name) => {\n                notifyForEachMatchedOption(name);\n            });\n        }\n        // If one option name is given, we suppose it should be handle by the\n        // first parent editor which can do it\n        if (ev.data.optionName) {\n            if (notifyForEachMatchedOption(ev.data.optionName)) {\n                ev.stopPropagation();\n            }\n        }\n\n        function notifyForEachMatchedOption(name) {\n            var regex = new RegExp('^' + name + '\\\\d+$');\n            var hasOption = false;\n            for (var key in self.styles) {\n                if (key === name || regex.test(key)) {\n                    self.styles[key].notify(ev.data.name, ev.data.data);\n                    hasOption = true;\n                }\n            }\n            return hasOption;\n        }\n    },\n    /**\n     * Called when the 'remove' button is clicked.\n     *\n     * @private\n     * @param {Event} ev\n     */\n    _onRemoveClick: function (ev) {\n        ev.preventDefault();\n        ev.stopPropagation();\n        this.trigger_up('snippet_edition_request', {exec: this.removeSnippet.bind(this)});\n    },\n    /**\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onSnippetOptionVisibilityUpdate: function (ev) {\n        if (this.options.wysiwyg.isSaving()) {\n            // Do not update the option visibilities if we are destroying them.\n            return;\n        }\n        ev.data.show = this._toggleVisibilityStatus(ev.data.show);\n        // Toggle the value of ev.data.show so that when trigger_up is called,\n        // it passes the value `true` to its parent. Additionally, in this\n        // block, we are calling `trigger_up` with `activate_snippet` to false,\n        // which disables options for that specific block.\n        if (this.$target[0] === ev.target.$target[0] && !ev.data.show) {\n            this.trigger_up(\"activate_snippet\", { $snippet: false });\n            ev.data.show = true;\n        }\n    },\n    /**\n     * @private\n     * @param {Event} ev\n     */\n    _onUserValueWidgetRequest: function (ev) {\n        for (const key of Object.keys(this.styles)) {\n            const widget = this.styles[key].findWidget(ev.data.name);\n            if (widget) {\n                ev.stopPropagation();\n                ev.data.onSuccess(widget);\n                return;\n            }\n        }\n        if (!ev.data.allowParentOption) {\n            ev.stopPropagation();\n        }\n    },\n    /**\n     * Called when the 'mouse wheel' is used when hovering over the overlay.\n     * Disable the pointer events to prevent page scrolling from stopping.\n     *\n     * @private\n     * @param {Event} ev\n     */\n    _onMouseWheel: function (ev) {\n        ev.stopPropagation();\n        this.$el.css('pointer-events', 'none');\n        clearTimeout(this.wheelTimeout);\n        this.wheelTimeout = setTimeout(() => {\n            this.$el.css('pointer-events', '');\n        }, 250);\n    },\n    /**\n     * Called when the \"send to back\" overlay button is clicked.\n     *\n     * @private\n     * @param {Event} ev\n     */\n    _onSendBackClick(ev) {\n        ev.stopPropagation();\n        const rowEl = this.$target[0].parentNode;\n        const columnEls = [...rowEl.children].filter(el => el !== this.$target[0]);\n        const minZindex = Math.min(...columnEls.map(el => el.style.zIndex));\n\n        // While the minimum z-index is not 0, it is OK to decrease it and to\n        // set the column to it. Otherwise, the column is set to 0 and the\n        // other columns z-index are increased by one.\n        if (minZindex > 0) {\n            this.$target[0].style.zIndex = minZindex - 1;\n        } else {\n            for (const columnEl of columnEls) {\n                columnEl.style.zIndex++;\n            }\n            this.$target[0].style.zIndex = 0;\n        }\n    },\n    /**\n     * Called when the \"bring to front\" overlay button is clicked.\n     *\n     * @private\n     * @param {Event} ev\n     */\n    _onBringFrontClick(ev) {\n        ev.stopPropagation();\n        const rowEl = this.$target[0].parentNode;\n        gridUtils._setElementToMaxZindex(this.$target[0], rowEl);\n    },\n    /**\n     * Called when the mouse is moved to place a column in a grid.\n     *\n     * @private\n     * @param {Event} ev\n     */\n    _onDragMove({ x, y }) {\n        if (!this.dragState.gridMode || !this.dragState.currentDropzoneEl) {\n            return;\n        }\n        const columnEl = this.$target[0];\n        const rowEl = columnEl.parentNode;\n\n        // Computing the rowEl position.\n        const rowElTop = rowEl.getBoundingClientRect().top;\n        const rowElLeft = rowEl.getBoundingClientRect().left;\n\n        // Getting the column dimensions.\n        const borderWidth = parseFloat(window.getComputedStyle(columnEl).borderWidth);\n        const columnHeight = columnEl.clientHeight + 2 * borderWidth;\n        const columnWidth = columnEl.clientWidth + 2 * borderWidth;\n\n        // Placing the column where the mouse is.\n        let top = y - rowElTop - this.mousePositionYOnElement;\n        const bottom = top + columnHeight;\n        let left = x - rowElLeft - this.mousePositionXOnElement;\n\n        // Horizontal and top overflow.\n        left = clamp(left, 0, rowEl.clientWidth - columnWidth);\n        top = top < 0 ? 0 : top;\n\n        columnEl.style.top = top + 'px';\n        columnEl.style.left = left + 'px';\n\n        // Computing the drag helper corresponding grid area.\n        const gridProp = gridUtils._getGridProperties(rowEl);\n\n        const rowStart = Math.round(top / (gridProp.rowSize + gridProp.rowGap)) + 1;\n        const columnStart = Math.round(left / (gridProp.columnSize + gridProp.columnGap)) + 1;\n        const rowEnd = rowStart + this.dragState.columnRowCount;\n        const columnEnd = columnStart + this.dragState.columnColCount;\n\n        const dragHelperEl = this.dragState.dragHelperEl;\n        if (parseInt(dragHelperEl.style.gridRowStart) !== rowStart) {\n            dragHelperEl.style.gridRowStart = rowStart;\n            dragHelperEl.style.gridRowEnd = rowEnd;\n        }\n\n        if (parseInt(dragHelperEl.style.gridColumnStart) !== columnStart) {\n            dragHelperEl.style.gridColumnStart = columnStart;\n            dragHelperEl.style.gridColumnEnd = columnEnd;\n        }\n\n        // Vertical overflow/underflow.\n        // Updating the reference heights, the dropzone and the background grid.\n        const startingHeight = this.dragState.startingHeight;\n        const currentHeight = this.dragState.currentHeight;\n        const backgroundGridEl = this.dragState.backgroundGridEl;\n        const dropzoneEl = this.dragState.currentDropzoneEl;\n        const rowOverflow = Math.round((bottom - currentHeight) / (gridProp.rowSize + gridProp.rowGap));\n        const updateRows = bottom > currentHeight || bottom <= currentHeight && bottom > startingHeight;\n        const rowCount = Math.max(rowEl.dataset.rowCount, this.dragState.columnRowCount);\n        const maxRowEnd = rowCount + gridUtils.additionalRowLimit + 1;\n        if (Math.abs(rowOverflow) >= 1 && updateRows) {\n            if (rowEnd <= maxRowEnd) {\n                const dropzoneEnd = parseInt(dropzoneEl.style.gridRowEnd);\n                dropzoneEl.style.gridRowEnd = dropzoneEnd + rowOverflow;\n                backgroundGridEl.style.gridRowEnd = dropzoneEnd + rowOverflow;\n                this.dragState.currentHeight += rowOverflow * (gridProp.rowSize + gridProp.rowGap);\n            } else {\n                // Don't add new rows if we have reached the limit.\n                dropzoneEl.style.gridRowEnd = maxRowEnd;\n                backgroundGridEl.style.gridRowEnd = maxRowEnd;\n                this.dragState.currentHeight = (maxRowEnd - 1) * (gridProp.rowSize + gridProp.rowGap) - gridProp.rowGap;\n            }\n        }\n    }\n});\n\n/**\n * Management of drag&drop menu and snippet related behaviors in the page.\n */\nvar SnippetsMenu = Widget.extend({\n    id: 'oe_snippets',\n    cacheSnippetTemplate: {},\n    events: {\n        'click .oe_snippet': '_onSnippetClick',\n        'click .o_install_btn': '_onInstallBtnClick',\n        'click .o_we_add_snippet_btn': '_onBlocksTabClick',\n        'click .o_we_customize_snippet_btn': '_onOptionsTabClick',\n        'click .o_we_invisible_entry': '_onInvisibleEntryClick',\n        'click #snippet_custom .o_rename_btn': '_onRenameBtnClick',\n        'click #snippet_custom .o_delete_btn': '_onDeleteBtnClick',\n        'pointerdown': '_onMouseDown',\n        'pointerup': '_onMouseUp',\n        'input .o_snippet_search_filter_input': '_onSnippetSearchInput',\n        'click .o_snippet_search_filter_reset': '_onSnippetSearchResetClick',\n        'click .o_we_website_top_actions button[data-action=save]': '_onSaveRequest',\n        'click .o_we_website_top_actions button[data-action=cancel]': '_onDiscardClick',\n        'click .o_we_website_top_actions button[data-action=mobile]': '_onMobilePreviewClick',\n        'click .o_we_website_top_actions button[data-action=undo]': '_onUndo',\n        'click .o_we_website_top_actions button[data-action=redo]': '_onRedo',\n    },\n    custom_events: {\n        'activate_insertion_zones': '_onActivateInsertionZones',\n        'activate_snippet': '_onActivateSnippet',\n        'call_for_each_child_snippet': '_onCallForEachChildSnippet',\n        'clone_snippet': '_onCloneSnippet',\n        \"clean_ui_request\": \"_onCleanUIRequest\",\n        'cover_update': '_onOverlaysCoverUpdate',\n        'deactivate_snippet': '_onDeactivateSnippet',\n        'drag_and_drop_stop': '_onSnippetDragAndDropStop',\n        'drag_and_drop_start': '_onSnippetDragAndDropStart',\n        'get_snippet_versions': '_onGetSnippetVersions',\n        'find_snippet_template': '_onFindSnippetTemplate',\n        'remove_snippet': '_onRemoveSnippet',\n        'snippet_edition_request': '_onSnippetEditionRequest',\n        'snippet_editor_destroyed': '_onSnippetEditorDestroyed',\n        'snippet_removed': '_onSnippetRemoved',\n        'snippet_cloned': '_onSnippetCloned',\n        'snippet_option_update': '_onSnippetOptionUpdate',\n        'snippet_option_visibility_update': '_onSnippetOptionVisibilityUpdate',\n        'snippet_thumbnail_url_request': '_onSnippetThumbnailURLRequest',\n        'request_save': '_onSaveRequest',\n        'hide_overlay': '_onHideOverlay',\n        'block_preview_overlays': '_onBlockPreviewOverlays',\n        'unblock_preview_overlays': '_onUnblockPreviewOverlays',\n        'user_value_widget_opening': '_onUserValueWidgetOpening',\n        'user_value_widget_closing': '_onUserValueWidgetClosing',\n        'reload_snippet_template': '_onReloadSnippetTemplate',\n        'request_editable': '_onRequestEditable',\n        'disable_loading_effect': '_onDisableLoadingEffect',\n        'enable_loading_effect': '_onEnableLoadingEffect',\n        \"update_invisible_dom\": \"_onUpdateInvisibleDom\",\n    },\n    // enum of the SnippetsMenu's tabs.\n    tabs: {\n        BLOCKS: 'blocks',\n        OPTIONS: 'options',\n        CUSTOM: 'custom',\n    },\n\n    /**\n     * @param {Widget} parent\n     * @param {Object} [options]\n     * @param {string} [options.snippets]\n     *      URL of the snippets template. This URL might have been set\n     *      in the global 'snippets' variable, otherwise this function\n     *      assigns a default one.\n     *      default: 'web_editor.snippets'\n     *\n     * @constructor\n     */\n    init: function (parent, options) {\n        this._super.apply(this, arguments);\n        options = options || {};\n        this.$body = $((options.document || document).body);\n\n        this.options = options;\n        if (!this.options.snippets) {\n            this.options.snippets = 'web_editor.snippets';\n        }\n        this.snippetEditors = [];\n        this._enabledEditorHierarchy = [];\n\n        this._mutex = new Mutex();\n\n        this._notActivableElementsSelector = [\n            '#web_editor-top-edit',\n            '.o_we_website_top_actions',\n            '#oe_snippets',\n            '#oe_manipulators',\n            '.o_technical_modal',\n            '.oe_drop_zone',\n            '.o_notification_manager',\n            '.o_we_no_overlay',\n            '.ui-autocomplete',\n            '.modal .btn-close',\n            '.o_we_crop_widget',\n            '.transfo-container',\n            '.o_datetime_picker',\n        ].join(', ');\n\n        this.loadingTimers = {};\n        this.loadingElements = {};\n        this._loadingEffectDisabled = false;\n        this._onClick = this._onClick.bind(this);\n\n        this.orm = this.bindService(\"orm\");\n        this.notification = this.bindService(\"notification\");\n        this.dialog = this.bindService(\"dialog\");\n    },\n    /**\n     * @override\n     */\n    willStart: function () {\n        // Preload colorpalette dependencies without waiting for them. The\n        // widget have huge chances of being used by the user (clicking on any\n        // text will load it). The colorpalette itself will do the actual\n        // waiting of the loading completion.\n        this.options.wysiwyg.getColorpickerTemplate();\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    async start() {\n        var defs = [this._super.apply(this, arguments)];\n        this.ownerDocument = this.$el[0].ownerDocument;\n        this.$document = $(this.ownerDocument);\n        this.window = this.ownerDocument.defaultView;\n        this.$window = $(this.window);\n        // In an iframe, we need to make sure the element is using jquery on its\n        // own window and not on the top window lest jquery behave unexpectedly.\n        this.$el = this.window.$(this.$el);\n        this.$el.data('snippetMenu', this);\n\n        // TODO somehow this attribute is not on the HTML element of the backend\n        // ... it probably should be.\n        const context = this.options.context || session.user_context || {};\n        const userLang = context.user_lang || context.lang || 'en_US';\n        this.el.setAttribute('lang', pyToJsLocale(userLang));\n\n        // We need to activate the touch events to be able to drag and drop\n        // snippets on devices with a touch screen.\n        this.__onTouchEvent = this._onTouchEvent.bind(this);\n        document.addEventListener(\"touchstart\", this.__onTouchEvent, true);\n        document.addEventListener(\"touchmove\", this.__onTouchEvent, true);\n        document.addEventListener(\"touchend\", this.__onTouchEvent, true);\n\n        this.customizePanel = document.createElement('div');\n        this.customizePanel.classList.add('o_we_customize_panel', 'd-none');\n\n        this.options.wysiwyg.toolbarEl.classList.add('d-none');\n        this._toolbarWrapperEl = document.createElement('div');\n        this._toolbarWrapperEl.classList.add('o_we_toolbar_wrapper');\n        class WebsiteToolbar extends Component {\n            static components = { Toolbar, LinkTools };\n            static template = xml`\n                <Toolbar t-props=\"props.wysiwygState.toolbarProps\">\n                    <t t-if=\"props.wysiwygState.linkToolProps\">\n                        <LinkTools t-props=\"props.wysiwygState.linkToolProps\" />\n                    </t>\n                </Toolbar>\n            `;\n            static props = {\n                wysiwygState: Object,\n            };\n        }\n        // Add the toolbarWrapperEl to the dom for owl to properly mount the\n        // Toolbar.\n        document.body.append(this._toolbarWrapperEl);\n        this._toolbarWrapperEl.style.display = 'none';\n        await attachComponent(this, this._toolbarWrapperEl, WebsiteToolbar, {\n            wysiwygState: this.options.wysiwyg.state,\n        });\n        this._toolbarWrapperEl.style.display = 'contents';\n\n        const toolbarEl = this._toolbarWrapperEl.firstChild;\n        toolbarEl.classList.remove('oe-floating');\n        this.options.wysiwyg.setupToolbar(toolbarEl);\n        this._addToolbar();\n        this._checkEditorToolbarVisibilityCallback = this._checkEditorToolbarVisibility.bind(this);\n        $(this.options.wysiwyg.odooEditor.document.body).on('click', this._checkEditorToolbarVisibilityCallback);\n\n        this.invisibleDOMPanelEl = document.createElement('div');\n        this.invisibleDOMPanelEl.classList.add('o_we_invisible_el_panel');\n        this.invisibleDOMPanelEl.appendChild(\n            $('<div/>', {\n                text: _t('Invisible Elements'),\n                class: 'o_panel_header',\n            })[0]\n        );\n\n        // Prepare snippets editor environment\n        this.$snippetEditorArea = $('<div/>', {\n            id: 'oe_manipulators',\n        });\n        this.$body.prepend(this.$snippetEditorArea);\n        this.options.getDragAndDropOptions = this._getDragAndDropOptions.bind(this);\n\n        // Add tooltips on we-title elements whose text overflows and on all\n        // elements with available tooltip text. Note that the tooltips of the\n        // blocks should not be taken into account here because they have\n        // tooltips with a particular behavior (see _showSnippetTooltip).\n        this.tooltips = new Tooltip(this.el, {\n            selector: 'we-title, [title]:not(.oe_snippet)',\n            placement: 'bottom',\n            delay: 100,\n            // Ensure the tooltips have a good position when in iframe.\n            container: this.el,\n            // Prevent horizontal scroll when tooltip is displayed.\n            boundary: this.el.ownerDocument.body,\n            title: function () {\n                const el = this;\n                if (el.tagName !== 'WE-TITLE') {\n                    return el.title;\n                }\n                // On Firefox, el.scrollWidth is equal to el.clientWidth when\n                // overflow: hidden, so we need to update the style before to\n                // get the right values.\n                el.style.setProperty('overflow', 'scroll', 'important');\n                const tipContent = el.scrollWidth > el.clientWidth ? el.innerHTML : '';\n                el.style.removeProperty('overflow');\n                return tipContent;\n            },\n        });\n\n        // Active snippet editor on click in the page\n        this.$document.on('click.snippets_menu', '*', this._onClick);\n        // Needed as bootstrap stop the propagation of click events for dropdowns\n        this.$document.on('mouseup.snippets_menu', '.dropdown-toggle', this._onClick);\n\n        // Adapt overlay covering when the window is resized / content changes\n        this.debouncedCoverUpdate = throttleForAnimation(() => {\n            this.updateCurrentSnippetEditorOverlay();\n        });\n        this.$window.on(\"resize.snippets_menu\", this.debouncedCoverUpdate);\n        this.$body.on(\"content_changed.snippets_menu\", this.debouncedCoverUpdate);\n        $(this.$body[0].ownerDocument.defaultView).on(\n            \"resize.snippets_menu\",\n            this.debouncedCoverUpdate\n        );\n\n        // On keydown add a class on the active overlay to hide it and show it\n        // again when the mouse moves\n        this.$body.on('keydown.snippets_menu', () => {\n            this.__overlayKeyWasDown = true;\n            this.snippetEditors.forEach(editor => {\n                editor.toggleOverlayVisibility(false);\n            });\n        });\n        this.$body.on('mousemove.snippets_menu, mousedown.snippets_menu', throttleForAnimation(() => {\n            if (!this.__overlayKeyWasDown) {\n                return;\n            }\n            this.__overlayKeyWasDown = false;\n            this.snippetEditors.forEach(editor => {\n                editor.toggleOverlayVisibility(true);\n                editor.cover();\n            });\n        }));\n\n        // Hide the active overlay when scrolling.\n        // Show it again and recompute all the overlays after the scroll.\n        this.$scrollingElement = $().getScrollingElement(this.$body[0].ownerDocument);\n        if (!this.$scrollingElement[0]) {\n            this.$scrollingElement = $(this.ownerDocument).find('.o_editable');\n        }\n        this.$scrollingTarget = $().getScrollingTarget(this.$scrollingElement);\n        this._onScrollingElementScroll = throttleForAnimation(() => {\n            for (const editor of this.snippetEditors) {\n                editor.toggleOverlayVisibility(false);\n            }\n            clearTimeout(this.scrollingTimeout);\n            this.scrollingTimeout = setTimeout(() => {\n                this._scrollingTimeout = null;\n                for (const editor of this.snippetEditors) {\n                    editor.toggleOverlayVisibility(true);\n                    editor.cover();\n                }\n            }, 250);\n        });\n        // We use addEventListener instead of jQuery because we need 'capture'.\n        // Setting capture to true allows to take advantage of event bubbling\n        // for events that otherwise don\u2019t support it. (e.g. useful when\n        // scrolling a modal)\n        this.$scrollingTarget[0].addEventListener('scroll', this._onScrollingElementScroll, {capture: true});\n\n        if (this.options.enableTranslation) {\n            // Load the sidebar with the style tab only.\n            await this._loadSnippetsTemplates();\n            defs.push(this._updateInvisibleDOM());\n            this.$el.find('.o_we_website_top_actions').removeClass('d-none');\n            this.$('.o_snippet_search_filter').addClass('d-none');\n            this.$('#o_scroll').addClass('d-none');\n            this.$('button[data-action=\"mobilePreview\"]').addClass('d-none');\n            this.$('#snippets_menu button').removeClass('active').prop('disabled', true);\n            this.$('.o_we_customize_snippet_btn').addClass('active').prop('disabled', false);\n            this.$('o_we_ui_loading').addClass('d-none');\n            $(this.customizePanel).removeClass('d-none');\n            this.$('#o_we_editor_toolbar_container').hide();\n            this.$('#o-we-editor-table-container').addClass('d-none');\n            return Promise.all(defs).then(() => {});\n        }\n\n        this.emptyOptionsTabContent = document.createElement('div');\n        this.emptyOptionsTabContent.classList.add('text-center', 'pt-5');\n        this.emptyOptionsTabContent.append(_t(\"Select a block on your page to style it.\"));\n\n        // Fetch snippet templates and compute it\n        defs.push((async () => {\n            await this._loadSnippetsTemplates(this.options.invalidateSnippetCache);\n            await this._updateInvisibleDOM();\n        })());\n\n        // Auto-selects text elements with a specific class and remove this\n        // on text changes\n        const alreadySelectedElements = new Set();\n        this.$body.on('click.snippets_menu', '.o_default_snippet_text', ev => {\n            const el = ev.currentTarget;\n            if (alreadySelectedElements.has(el)) {\n                // If the element was already selected in such a way before, we\n                // don't reselect it. This actually allows to have the first\n                // click on an element to select its text, but the second click\n                // to place the cursor inside of that text.\n                return;\n            }\n            alreadySelectedElements.add(el);\n            $(el).selectContent();\n        });\n        this.$body.on('keyup.snippets_menu', () => {\n            // Note: we cannot listen to keyup in .o_default_snippet_text\n            // elements via delegation because keyup only bubbles from focusable\n            // elements which contenteditable are not.\n            const selection = this.$body[0].ownerDocument.getSelection();\n            if (!selection.rangeCount) {\n                return;\n            }\n            const range = selection.getRangeAt(0);\n            const $defaultTextEl = $(range.startContainer).closest('.o_default_snippet_text');\n            $defaultTextEl.removeClass('o_default_snippet_text');\n            alreadySelectedElements.delete($defaultTextEl[0]);\n        });\n        const refreshSnippetEditors = debounce(() => {\n            for (const snippetEditor of this.snippetEditors) {\n                this._mutex.exec(() => snippetEditor.destroy());\n            }\n            // FIXME should not the snippetEditors list be emptied here ?\n            const selection = this.$body[0].ownerDocument.getSelection();\n            if (selection.rangeCount) {\n                const target = selection.getRangeAt(0).startContainer.parentElement;\n                this._activateSnippet($(target));\n            }\n\n            this._updateInvisibleDOM();\n        }, 500);\n        this.options.wysiwyg.odooEditor.addEventListener('historyUndo', refreshSnippetEditors);\n        this.options.wysiwyg.odooEditor.addEventListener('historyRedo', refreshSnippetEditors);\n\n        const $autoFocusEls = $('.o_we_snippet_autofocus');\n        this._activateSnippet($autoFocusEls.length ? $autoFocusEls.first() : false);\n\n        return Promise.all(defs).then(() => {\n            const $undoButton = this.$('.o_we_external_history_buttons button[data-action=\"undo\"]');\n            const $redoButton = this.$('.o_we_external_history_buttons button[data-action=\"redo\"]');\n            if ($undoButton.length) {\n                const updateHistoryButtons = () => {\n                    $undoButton.attr('disabled', !this.options.wysiwyg.odooEditor.historyCanUndo());\n                    $redoButton.attr('disabled', !this.options.wysiwyg.odooEditor.historyCanRedo());\n                };\n                this.options.wysiwyg.odooEditor.addEventListener('historyStep', updateHistoryButtons);\n                this.options.wysiwyg.odooEditor.addEventListener('observerApply', () => {\n                    $(this.options.wysiwyg.odooEditor.editable).trigger('content_changed');\n                });\n            }\n\n            // Trigger a resize event once entering edit mode as the snippets\n            // menu will take part of the screen width (delayed because of\n            // animation). (TODO wait for real animation end)\n            setTimeout(() => {\n                this.$window[0].dispatchEvent(new Event(\"resize\"));\n            }, 1000);\n        });\n    },\n    /**\n     * @override\n     */\n    destroy: function () {\n        this._super.apply(this, arguments);\n        // Remove listeners for touch events.\n        document.removeEventListener(\"touchstart\", this.__onTouchEvent, true);\n        document.removeEventListener(\"touchmove\", this.__onTouchEvent, true);\n        document.removeEventListener(\"touchend\", this.__onTouchEvent, true);\n        this.draggableComponent && this.draggableComponent.destroy();\n        if (this.$window) {\n            if (this.$snippetEditorArea) {\n                this.$snippetEditorArea.remove();\n            }\n            this.$window.off('.snippets_menu');\n            this.$document.off('.snippets_menu');\n\n            if (this.$scrollingTarget) {\n                this.$scrollingTarget[0].removeEventListener('scroll', this._onScrollingElementScroll, {capture: true});\n            }\n        }\n        if (this.debouncedCoverUpdate) {\n            this.debouncedCoverUpdate.cancel();\n        }\n        $(document.body).off('click', this._checkEditorToolbarVisibilityCallback);\n        this.el.ownerDocument.body.classList.remove('editor_has_snippets');\n        // Dispose BS tooltips.\n        this.tooltips.dispose();\n        options.clearServiceCache();\n        options.clearControlledSnippets();\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * Prepares the page so that it may be saved:\n     * - Asks the snippet editors to clean their associated snippet\n     * - Remove the 'contentEditable' attributes\n     */\n    cleanForSave: async function () {\n        // Wait for snippet post-drop code here, since sometimes we save very\n        // quickly after a snippet drop during automated testing, which breaks\n        // some options code (executed while destroying the editor).\n        // TODO we should find a better way, by better locking the drag and drop\n        // code inside the edition mutex... which unfortunately cannot be done\n        // given the state of the code, as internal operations of that drag and\n        // drop code need to use the mutex themselves.\n        await this.postSnippetDropPromise;\n\n        // First disable the snippet selection, calling options onBlur, closing\n        // widgets, etc. Then wait for full resolution of the mutex as widgets\n        // may have triggered some final edition requests that need to be\n        // processed before actual \"clean for save\" and saving.\n        await this._activateSnippet(false);\n        await this._mutex.getUnlockedDef();\n\n        // Next, notify that we want the DOM to be cleaned (e.g. in website this\n        // may be the moment where the public widgets need to be destroyed).\n        this.trigger_up('ready_to_clean_for_save');\n        // Wait for the mutex a second time as some options do editor actions when\n        // their snippets are destroyed. (E.g. s_popup triggers visibility updates\n        // when hidden, destroying the widget hides it.)\n        await this._mutex.getUnlockedDef();\n\n        // Then destroy all snippet editors, making them call their own\n        // \"clean for save\" methods (and options ones).\n        await this._destroyEditors();\n\n        // Final editor cleanup\n        this.getEditableArea().find('[contentEditable]')\n            .removeAttr('contentEditable')\n            .removeProp('contentEditable');\n        this.getEditableArea().find('.o_we_selected_image')\n            .removeClass('o_we_selected_image');\n        [...this.getEditableArea()].forEach(editableAreaEl => {\n            editableAreaEl.querySelectorAll(\"[data-visibility='conditional']\")\n                            .forEach(invisibleEl => delete invisibleEl.dataset.invisible);\n        });\n    },\n    /**\n     * Load snippets.\n     * @param {boolean} invalidateCache\n     */\n    loadSnippets: function (invalidateCache) {\n        if (!invalidateCache && cacheSnippetTemplate[this.options.snippets]) {\n            this._defLoadSnippets = cacheSnippetTemplate[this.options.snippets];\n            return this._defLoadSnippets;\n        }\n        let context = Object.assign({}, this.options.context);\n        if (context.user_lang) {\n            context.lang = this.options.context.user_lang;\n            context.snippet_lang = this.options.context.lang;\n        }\n        this._defLoadSnippets = this.orm.silent.call(\n            \"ir.ui.view\",\n            \"render_public_asset\",\n            [this.options.snippets, {}],\n            { context }\n        );\n        cacheSnippetTemplate[this.options.snippets] = this._defLoadSnippets;\n        return this._defLoadSnippets;\n    },\n    /**\n     * Visually hide or display this snippet menu\n     * @param {boolean} foldState\n     */\n    setFolded: function (foldState = true) {\n        this.el.classList.toggle('d-none', foldState);\n        this.el.ownerDocument.body.classList.toggle('editor_has_snippets', !foldState);\n        this.folded = !!foldState;\n    },\n    /**\n     * Get the editable area.\n     *\n     * @returns {JQuery}\n     */\n    getEditableArea: function () {\n        return this.options.wysiwyg.$editable.find(this.options.selectorEditableArea)\n            .add(this.options.wysiwyg.$editable.filter(this.options.selectorEditableArea));\n    },\n    /**\n     * Updates the cover dimensions of the current snippet editor.\n     */\n    updateCurrentSnippetEditorOverlay: function () {\n        if (this.snippetEditorDragging) {\n            return;\n        }\n        for (const snippetEditor of this.snippetEditors) {\n            if (snippetEditor.$target.closest('body').length) {\n                snippetEditor.cover();\n                continue;\n            }\n            // Destroy options whose $target are not in the DOM anymore but\n            // only do it once all options executions are done.\n            this._mutex.exec(() => this._destroyEditor(snippetEditor));\n        }\n        this._mutex.exec(() => {\n            if (this._currentTab === this.tabs.OPTIONS && !this.snippetEditors.length) {\n                const selection = this.$body[0].ownerDocument.getSelection();\n                const range = selection?.rangeCount && selection.getRangeAt(0);\n                const currentlySelectedNode = range?.commonAncestorContainer;\n                // In some cases (e.g. in translation mode) it's possible to have\n                // all snippet editors destroyed after disabling text options.\n                // We still want to keep the toolbar available in this case.\n                const isEditableTextElementSelected =\n                    currentlySelectedNode?.nodeType === Node.TEXT_NODE &&\n                    !!currentlySelectedNode?.parentNode?.isContentEditable;\n                if (!isEditableTextElementSelected) {\n                    this._activateEmptyOptionsTab();\n                }\n            }\n        });\n    },\n    activateCustomTab: function (content) {\n        this._updateRightPanelContent({content: content, tab: this.tabs.CUSTOM});\n    },\n    /**\n     * Public method to activate a snippet.\n     *\n     * @see this._activateSnippet\n     * @param {jQuery} $snippet\n     * @returns {Promise}\n     */\n    activateSnippet: async function ($snippet) {\n        return this._activateSnippet($snippet);\n    },\n\n    /**\n     * Postprocesses a snippet node when it has been inserted in the dom.\n     *\n     * @param {jQuery} $target\n     * @returns {Promise}\n     */\n    callPostSnippetDrop: async function ($target) {\n        this.postSnippetDropPromise = new Promise(resolve => {\n            this._postSnippetDropResolver = resolve;\n        });\n\n        // First call the onBuilt of all options of each item in the snippet\n        // (and so build their editor instance first).\n        await this._callForEachChildSnippet($target, function (editor, $snippet) {\n            return editor.buildSnippet($target[0]);\n        });\n        // The snippet is now fully built, notify the editor for changed\n        // content.\n        $target.trigger('content_changed');\n\n        // Now notifies that a snippet was dropped (at the moment, useful to\n        // start public widgets for instance (no saved content)).\n        await this._mutex.exec(() => {\n            const proms = [];\n            this.trigger_up('snippet_dropped', {\n                $target: $target,\n                addPostDropAsync: prom => proms.push(prom),\n            });\n            return Promise.all(proms);\n        });\n\n        // Lastly, ensure that the snippets or its related parts are added to\n        // the invisible DOM list if needed.\n        await this._updateInvisibleDOM();\n\n        if (this.__postSnippetDropExtraActions) {\n            this.__postSnippetDropExtraActions();\n            delete this.__postSnippetDropExtraActions;\n        }\n        this._postSnippetDropResolver();\n    },\n    /**\n     * Public implementation of _execWithLoadingEffect.\n     *\n     * @see this._execWithLoadingEffect for parameters\n     */\n    execWithLoadingEffect(action, contentLoading = true, delay = 500) {\n        return this._execWithLoadingEffect(...arguments);\n    },\n    reload_snippet_dropzones() {\n        this._disableUndroppableSnippets();\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates drop zones in the DOM (locations where snippets may be dropped).\n     * Those locations are determined thanks to the two types of given DOM.\n     *\n     * @private\n     * @param {jQuery} [$selectorSiblings]\n     *        elements which must have siblings drop zones\n     * @param {jQuery} [$selectorChildren]\n     *        elements which must have child drop zones between each of existing\n     *        child\n     * @param {string or boolean} canBeSanitizedUnless\n     *        true: always allows,\n     *        false: always forbid,\n     *        string: specific type of forbidden sanitization\n     * @param {Boolean} [toInsertInline=false]\n     *        elements which are inline as the \"s_badge\" snippet for example\n     * @param {Object} [selectorGrids = []]\n     *        elements which are in grid mode and for which a grid dropzone\n     *        needs to be inserted\n     */\n    _activateInsertionZones($selectorSiblings, $selectorChildren, canBeSanitizedUnless, toInsertInline, selectorGrids = [], fromIframe = false) {\n        var self = this;\n\n        // If a modal or a dropdown is open, the drop zones must be created\n        // only in this element.\n        const $editableArea = self.getEditableArea();\n        let $open = $editableArea.find('.modal:visible');\n        if (!$open.length) {\n            $open = $editableArea.find('.dropdown-menu.show').addBack('.dropdown-menu.show').parent();\n        }\n        if ($open.length) {\n            $selectorSiblings = $open.find($selectorSiblings);\n            $selectorChildren = $open.find($selectorChildren);\n            selectorGrids = new Set([...selectorGrids].filter(rowEl => $open[0].contains(rowEl)));\n        }\n\n        // Check if the drop zone should be horizontal or vertical\n        function setDropZoneDirection($elem, $parent, toInsertInline, $sibling) {\n            let vertical = false;\n            let style = {};\n            $sibling = $sibling || $elem;\n            const css = window.getComputedStyle($elem[0]);\n            const parentCss = window.getComputedStyle($parent[0]);\n            const float = css.float || css.cssFloat;\n            const display = parentCss.display;\n            const flex = parentCss.flexDirection;\n            if (toInsertInline || float === 'left' || float === 'right' || (display === 'flex' && flex === 'row')) {\n                if (!toInsertInline) {\n                    style['float'] = float;\n                }\n                if ((parseInt($sibling.parent().width()) !== parseInt($sibling.outerWidth(true)))) {\n                    vertical = true;\n                    style['height'] = Math.max($sibling.outerHeight(), 30) + 'px';\n                    if (toInsertInline) {\n                        style[\"display\"] = \"inline-block\";\n                        style[\"verticalAlign\"] = \"middle\";\n                        style[\"float\"] = \"none\";\n                    }\n                }\n            }\n            return {\n                vertical: vertical,\n                style: style,\n            };\n        }\n\n        // If the previous sibling is a BR tag or a non-whitespace text, it\n        // should be a vertical dropzone.\n        function testPreviousSibling(node, $zone) {\n            if (!node || ((node.tagName || !node.textContent.match(/\\S/)) && node.tagName !== 'BR')) {\n                return false;\n            }\n            return {\n                vertical: true,\n                style: {\n                    'float': 'none',\n                    'display': 'inline-block',\n                    'height': parseInt(self.window.getComputedStyle($zone[0]).lineHeight) + 'px',\n                },\n            };\n        }\n\n        // Firstly, add a dropzone after the clone (if we are not in grid mode).\n        var $clone = this.$body.find('.oe_drop_clone');\n        if ($clone.length && !$clone[0].parentElement.classList.contains(\"o_grid_mode\")) {\n            var $neighbor = $clone.prev();\n            if (!$neighbor.length) {\n                $neighbor = $clone.next();\n            }\n            var data;\n            if ($neighbor.length) {\n                data = setDropZoneDirection($neighbor, $neighbor.parent(), toInsertInline);\n            } else {\n                data = {\n                    vertical: false,\n                    style: {},\n                };\n            }\n            self._insertDropzone($('<we-hook/>').insertAfter($clone), data.vertical, data.style, canBeSanitizedUnless);\n        }\n        // If a modal or a dropdown is open, add the grid of the clone in the\n        // grid selectors to still be able to drop where the drag started.\n        if ($clone.length && $open.length && $clone[0].parentElement.classList.contains(\"o_grid_mode\")) {\n            selectorGrids.add($clone[0].parentElement);\n        }\n\n        if ($selectorChildren) {\n            $selectorChildren.each(function () {\n                var data;\n                var $zone = $(this);\n                var $children = $zone.find('> :not(.oe_drop_zone, .oe_drop_clone)');\n\n                if (!$zone.children().last().is('.oe_drop_zone')) {\n                    data = testPreviousSibling($zone[0].lastChild, $zone)\n                        || setDropZoneDirection($zone, $zone, toInsertInline, $children.last());\n                    self._insertDropzone($('<we-hook/>').appendTo($zone), data.vertical, data.style, canBeSanitizedUnless);\n                }\n\n                if (!$zone.children().first().is('.oe_drop_clone')) {\n                    data = testPreviousSibling($zone[0].firstChild, $zone)\n                        || setDropZoneDirection($zone, $zone, toInsertInline, $children.first());\n                    self._insertDropzone($('<we-hook/>').prependTo($zone), data.vertical, data.style, canBeSanitizedUnless);\n                }\n            });\n\n            // add children near drop zone\n            $selectorSiblings = $(unique(($selectorSiblings || $()).add($selectorChildren.children()).get()));\n        }\n\n        const noDropZonesSelector = '.o_we_no_overlay, :not(:visible)';\n        if ($selectorSiblings) {\n            $selectorSiblings.not(`.oe_drop_zone, .oe_drop_clone, ${noDropZonesSelector}`).each(function () {\n                var data;\n                var $zone = $(this);\n                var $zoneToCheck = $zone;\n\n                while ($zoneToCheck.prev(noDropZonesSelector).length) {\n                    $zoneToCheck = $zoneToCheck.prev();\n                }\n                if (!$zoneToCheck.prev('.oe_drop_zone:visible, .oe_drop_clone').length) {\n                    data = setDropZoneDirection($zone, $zone.parent(), toInsertInline);\n                    self._insertDropzone($('<we-hook/>').insertBefore($zone), data.vertical, data.style, canBeSanitizedUnless);\n                }\n\n                $zoneToCheck = $zone;\n                while ($zoneToCheck.next(noDropZonesSelector).length) {\n                    $zoneToCheck = $zoneToCheck.next();\n                }\n                if (!$zoneToCheck.next('.oe_drop_zone:visible, .oe_drop_clone').length) {\n                    data = setDropZoneDirection($zone, $zone.parent(), toInsertInline);\n                    self._insertDropzone($('<we-hook/>').insertAfter($zone), data.vertical, data.style, canBeSanitizedUnless);\n                }\n            });\n        }\n\n        var count;\n        var $zones;\n        do {\n            count = 0;\n            $zones = this.getEditableArea().find('.oe_drop_zone > .oe_drop_zone').remove(); // no recursive zones\n            count += $zones.length;\n            $zones.remove();\n        } while (count > 0);\n\n        // Cleaning consecutive zone and up zones placed between floating or\n        // inline elements. We do not like these kind of zones.\n        $zones = this.getEditableArea().find('.oe_drop_zone:not(.oe_vertical)');\n\n        let iframeOffset;\n        const bodyWindow = this.$body[0].ownerDocument.defaultView;\n        if (bodyWindow.frameElement && bodyWindow !== this.ownerDocument.defaultView && !fromIframe) {\n            iframeOffset = bodyWindow.frameElement.getBoundingClientRect();\n        }\n\n        $zones.each(function () {\n            var zone = $(this);\n            var prev = zone.prev();\n            var next = zone.next();\n            // remove consecutive zone\n            if (prev.is('.oe_drop_zone') || next.is('.oe_drop_zone')) {\n                zone.remove();\n                return;\n            }\n            var floatPrev = prev.css('float') || 'none';\n            var floatNext = next.css('float') || 'none';\n            var dispPrev = prev.css('display') || null;\n            var dispNext = next.css('display') || null;\n            if ((floatPrev === 'left' || floatPrev === 'right')\n             && (floatNext === 'left' || floatNext === 'right')) {\n                zone.remove();\n            } else if (dispPrev !== null && dispNext !== null\n             && dispPrev.indexOf('inline') >= 0 && dispNext.indexOf('inline') >= 0) {\n                zone.remove();\n            }\n\n            // In the case of the SnippetsMenu being instanciated in the global\n            // document, with its editable content in an iframe, we want to\n            // take the iframe's offset into account to compute the dropzones.\n            if (iframeOffset) {\n                this.oldGetBoundingClientRect = this.getBoundingClientRect;\n                this.getBoundingClientRect = () => {\n                    const rect = this.oldGetBoundingClientRect();\n                    const { x, y } = iframeOffset;\n                    rect.x += x;\n                    rect.y += y;\n                    return rect;\n                };\n            }\n        });\n\n        // Inserting a grid dropzone for each row in grid mode.\n        for (const rowEl of selectorGrids) {\n            self._insertGridDropzone(rowEl);\n        }\n    },\n    /**\n     * Adds an entry for every invisible snippet in the left panel box.\n     * The entries will contains an 'Edit' button to activate their snippet.\n     *\n     * @private\n     * @returns {Promise}\n     */\n    _updateInvisibleDOM: function () {\n        return this._execWithLoadingEffect(() => {\n            this.options.wysiwyg.odooEditor.automaticStepSkipStack();\n            this.invisibleDOMMap = new Map();\n            const $invisibleDOMPanelEl = $(this.invisibleDOMPanelEl);\n            $invisibleDOMPanelEl.find('.o_we_invisible_entry').remove();\n            const isMobile = this._isMobile();\n            const invisibleSelector = `.o_snippet_invisible, ${isMobile ? '.o_snippet_mobile_invisible' : '.o_snippet_desktop_invisible'}`;\n            const $selector = this.options.enableTranslation ? this.$body : globalSelector.all();\n            let $invisibleSnippets = $selector.find(invisibleSelector).addBack(invisibleSelector);\n\n            if (this.options.enableTranslation) {\n                // In translate mode, we do not want to be able to activate a\n                // hidden header or footer.\n                $invisibleSnippets = $invisibleSnippets.not(\"header, footer\");\n            }\n            $invisibleDOMPanelEl.toggleClass('d-none', !$invisibleSnippets.length);\n\n            // descendantPerSnippet: a map with its keys set to invisible\n            // snippets that have invisible descendants. The value corresponding\n            // to an invisible snippet element is a list filled with all its\n            // descendant invisible snippets except those that have a closer\n            // invisible snippet ancestor.\n            const descendantPerSnippet = new Map();\n            // Filter the \"$invisibleSnippets\" to only keep the root snippets\n            // and create the map (\"descendantPerSnippet\") of the snippets and\n            // their descendant snippets.\n            const rootInvisibleSnippetEls = [...$invisibleSnippets].filter(invisibleSnippetEl => {\n                const ancestorInvisibleEl = invisibleSnippetEl\n                                                 .parentElement.closest(invisibleSelector);\n                if (!ancestorInvisibleEl) {\n                    return true;\n                }\n                const descendantSnippets = descendantPerSnippet.get(ancestorInvisibleEl) || [];\n                descendantPerSnippet.set(ancestorInvisibleEl,\n                    [...descendantSnippets, invisibleSnippetEl]);\n                return false;\n            });\n            // Insert an invisible snippet in its \"parentEl\" element.\n            const createInvisibleElement = async (invisibleSnippetEl, isRootParent, isDescendant,\n                                                  parentEl) => {\n                const $invisibleSnippetEl = $(invisibleSnippetEl);\n                $invisibleSnippetEl.__force_create_editor = true;\n                const editor = await this._createSnippetEditor($invisibleSnippetEl);\n                const invisibleEntryEl = document.createElement(\"div\");\n                invisibleEntryEl.className = `${isRootParent ? \"o_we_invisible_root_parent\" : \"\"}`;\n                invisibleEntryEl.classList.add(\"o_we_invisible_entry\", \"d-flex\",\n                    \"align-items-center\", \"justify-content-between\");\n                invisibleEntryEl.classList.toggle(\"o_we_sublevel_1\", isDescendant);\n                const titleEl = document.createElement(\"we-title\");\n                titleEl.textContent = editor.getName();\n                invisibleEntryEl.appendChild(titleEl);\n                const iconEl = document.createElement(\"i\");\n                const eyeIconClass = editor.isTargetVisible() ? \"fa-eye\" : \"fa-eye-slash\";\n                iconEl.classList.add(\"fa\", \"ms-2\", eyeIconClass);\n                invisibleEntryEl.appendChild(iconEl);\n                parentEl.appendChild(invisibleEntryEl);\n                this.invisibleDOMMap.set(invisibleEntryEl, invisibleSnippetEl);\n            };\n            // Insert all the invisible snippets contained in \"snippetEls\" as\n            // well as their descendants in the \"parentEl\" element. If\n            // \"snippetEls\" is set to \"rootInvisibleSnippetEls\" and \"parentEl\"\n            // is set to \"$invisibleDOMPanelEl[0]\", then fills the right\n            // invisible panel like this:\n            // rootInvisibleSnippet\n            //     \u2514 descendantInvisibleSnippet\n            //          \u2514 descendantOfDescendantInvisibleSnippet\n            //               \u2514 etc...\n            const createInvisibleElements = async (snippetEls, isDescendant, parentEl) => {\n                for (const snippetEl of snippetEls) {\n                    const descendantSnippetEls = descendantPerSnippet.get(snippetEl);\n                    // An element is considered as \"RootParent\" if it has one or\n                    // more invisible descendants but is not a descendant.\n                    await createInvisibleElement(snippetEl,\n                        !isDescendant && !!descendantSnippetEls, isDescendant, parentEl);\n                    if (descendantSnippetEls) {\n                        // Insert all the descendant snippets in a list.\n                        const listEntryEl = document.createElement(\"ul\");\n                        await createInvisibleElements(descendantSnippetEls, true, listEntryEl);\n                        parentEl.appendChild(listEntryEl);\n                    }\n                }\n            };\n            return createInvisibleElements(rootInvisibleSnippetEls, false, $invisibleDOMPanelEl[0]);\n        }, false);\n    },\n    /**\n     * Disable the overlay editor of the active snippet and activate the new one\n     * if given.\n     * Note 1: if the snippet editor associated to the given snippet is not\n     *         created yet, this method will create it.\n     * Note 2: if the given DOM element is not a snippet (no editor option), the\n     *         first parent which is one is used instead.\n     *\n     * @param {jQuery|false} $snippet\n     *        The DOM element whose editor (and its parent ones) need to be\n     *        enabled. Only disable the current one if false is given.\n     * @param {boolean} [previewMode=false]\n     * @param {boolean} [ifInactiveOptions=false]\n     * @returns {Promise<SnippetEditor>}\n     *          (might be async when an editor must be created)\n     */\n    _activateSnippet: async function ($snippet, previewMode, ifInactiveOptions) {\n        if (this._blockPreviewOverlays && previewMode) {\n            return;\n        }\n        if ($snippet && !$snippet.is(':visible')) {\n            return;\n        }\n        // Take the first parent of the provided DOM (or itself) which\n        // should have an associated snippet editor.\n        // It is important to do that before the mutex exec call to compute it\n        // before potential ancestor removal.\n        if ($snippet && $snippet.length) {\n            const $globalSnippet = globalSelector.closest($snippet);\n            if (!$globalSnippet.length) {\n                $snippet = $snippet.closest('[data-oe-model=\"ir.ui.view\"]:not([data-oe-type]):not(.oe_structure), [data-oe-type=\"html\"]:not(.oe_structure)');\n            } else {\n                $snippet = $globalSnippet;\n            }\n        }\n        if (this.options.enableTranslation && $snippet && !this._allowInTranslationMode($snippet)) {\n            // In translate mode, only activate allowed snippets (e.g., even if\n            // we create editors for invisible elements when translating them,\n            // we only want to toggle their visibility when the related sidebar\n            // buttons are clicked).\n            const translationEditors = this.snippetEditors.filter(editor => {\n                return this._allowInTranslationMode(editor.$target);\n            });\n            // Before returning, we need to clean editors if their snippets are\n            // allowed in the translation mode.\n            for (const editor of translationEditors) {\n                await editor.cleanForSave();\n                editor.destroy();\n            }\n            return;\n        }\n        const exec = previewMode\n            ? action => this._mutex.exec(action)\n            : action => this._execWithLoadingEffect(action, false);\n        return exec(() => {\n            return new Promise(resolve => {\n                if ($snippet && $snippet.length) {\n                    return this._createSnippetEditor($snippet).then(resolve);\n                }\n                resolve(null);\n            }).then(async editorToEnable => {\n                if (!previewMode && this._enabledEditorHierarchy[0] === editorToEnable\n                        || ifInactiveOptions && this._enabledEditorHierarchy.includes(editorToEnable)) {\n                    return editorToEnable;\n                }\n\n                if (!previewMode) {\n                    this._enabledEditorHierarchy = [];\n                    let current = editorToEnable;\n                    while (current && current.$target) {\n                        this._enabledEditorHierarchy.push(current);\n                        current = current.getParent();\n                    }\n                }\n\n                // First disable all editors...\n                for (let i = this.snippetEditors.length; i--;) {\n                    const editor = this.snippetEditors[i];\n                    editor.toggleOverlay(false, previewMode);\n                    if (!previewMode) {\n                        const wasShown = !!await editor.toggleOptions(false);\n                        if (wasShown) {\n                            this._updateRightPanelContent({\n                                content: [],\n                                tab: this.tabs.BLOCKS,\n                            });\n                        }\n                    }\n                }\n                // ... then enable the right editor or look if some have been\n                // enabled previously by a click\n                let customize$Elements;\n                if (editorToEnable) {\n                    editorToEnable.toggleOverlay(true, previewMode);\n                    if (!previewMode && !editorToEnable.displayOverlayOptions) {\n                        const parentEditor = this._enabledEditorHierarchy.find(ed => ed.displayOverlayOptions);\n                        if (parentEditor) {\n                            parentEditor.toggleOverlay(true, previewMode);\n                        }\n                    }\n                    customize$Elements = await editorToEnable.toggleOptions(true);\n                } else {\n                    for (const editor of this.snippetEditors) {\n                        if (editor.isSticky()) {\n                            editor.toggleOverlay(true, false);\n                            customize$Elements = await editor.toggleOptions(true);\n                        }\n                    }\n                }\n\n                if (!previewMode) {\n                    // As some options can only be generated using JavaScript\n                    // (e.g. 'SwitchableViews'), it may happen at this point\n                    // that the overlay is activated even though there are no\n                    // options. That's why we disable the overlay if there are\n                    // no options to enable.\n                    if (editorToEnable && !customize$Elements) {\n                        editorToEnable.toggleOverlay(false);\n                    }\n                    this._updateRightPanelContent({\n                        content: customize$Elements || [],\n                        tab: customize$Elements ? this.tabs.OPTIONS : this.tabs.BLOCKS,\n                    });\n                }\n\n                return editorToEnable;\n            });\n        });\n    },\n    /**\n     * @private\n     * @param {boolean} invalidateCache\n     */\n    _loadSnippetsTemplates: async function (invalidateCache) {\n        return this._execWithLoadingEffect(async () => {\n            await this._destroyEditors();\n            const html = await this.loadSnippets(invalidateCache);\n            await this._computeSnippetTemplates(html);\n        }, false);\n    },\n    /**\n     * TODO everything related to SnippetEditor destroy / cleanForSave should\n     * really be cleaned / unified.\n     *\n     * @private\n     * @param {SnippetEditor} editor\n     */\n    _destroyEditor(editor) {\n        editor.destroy();\n        const index = this.snippetEditors.indexOf(editor);\n        if (index >= 0) {\n            this.snippetEditors.splice(index, 1);\n        }\n    },\n    /**\n     * @private\n     * @param {jQuery|null|undefined} [$el]\n     *        The DOM element whose inside editors need to be destroyed.\n     *        If no element is given, all the editors are destroyed.\n     */\n    _destroyEditors: async function ($el) {\n        const aliveEditors = this.snippetEditors.filter((snippetEditor) => {\n            return !$el || $el.has(snippetEditor.$target).length;\n        });\n        const cleanForSavePromises = aliveEditors.map((snippetEditor) => snippetEditor.cleanForSave());\n        await Promise.all(cleanForSavePromises);\n\n        for (const snippetEditor of aliveEditors) {\n            // No need to clean the `this.snippetEditors` array as each\n            // individual destroy notifies this class instance to remove the\n            // element from the array.\n            snippetEditor.destroy();\n        }\n    },\n    /**\n     * Calls a given callback 'on' the given snippet and all its child ones if\n     * any (DOM element with options).\n     *\n     * Note: the method creates the snippet editors if they do not exist yet.\n     *\n     * @private\n     * @param {jQuery} $snippet\n     * @param {function} callback\n     *        Given two arguments: the snippet editor associated to the snippet\n     *        being managed and the DOM element of this snippet.\n     * @returns {Promise} (might be async if snippet editors need to be created\n     *                     and/or the callback is async)\n     */\n    _callForEachChildSnippet: function ($snippet, callback) {\n        var self = this;\n        var defs = Array.from($snippet.add(globalSelector.all($snippet))).map((el) => {\n            var $snippet = $(el);\n            return self._createSnippetEditor($snippet).then(function (editor) {\n                if (editor) {\n                    return callback.call(self, editor, $snippet);\n                }\n            });\n        });\n        return Promise.all(defs);\n    },\n    /**\n     * @private\n     */\n    _closeWidgets: function () {\n        this.snippetEditors.forEach(editor => editor.closeWidgets());\n    },\n    /**\n     * Creates and returns a set of helper functions which can help finding\n     * snippets in the DOM which match some parameters (typically parameters\n     * given by a snippet option). The functions are:\n     *\n     * - `is`: to determine if a given DOM is a snippet that matches the\n     *         parameters\n     *\n     * - `closest`: find closest parent (or itself) of a given DOM which is a\n     *              snippet that matches the parameters\n     *\n     * - `all`: find all snippets in the DOM that match the parameters\n     *\n     * See implementation for function details.\n     *\n     * @private\n     * @param {string} selector\n     *        jQuery selector that DOM elements must match to be considered as\n     *        potential snippet.\n     * @param {string} exclude\n     *        jQuery selector that DOM elements must *not* match to be\n     *        considered as potential snippet.\n     * @param {string|false} target\n     *        jQuery selector that at least one child of a DOM element must\n     *        match to that DOM element be considered as a potential snippet.\n     * @param {boolean} noCheck\n     *        true if DOM elements which are technically not in an editable\n     *        environment may be considered.\n     * @param {boolean} isChildren\n     *        when the DOM elements must be in an editable environment to be\n     *        considered (@see noCheck), this is true if the DOM elements'\n     *        parent must also be in an editable environment to be considered.\n     * @param {string} excludeParent\n     *        jQuery selector that the parents of DOM elements must *not* match\n     *        to be considered as potential snippet.\n     */\n    _computeSelectorFunctions: function (selector, exclude, target, noCheck, isChildren, excludeParent) {\n        var self = this;\n\n        // TODO in master: FOR_DROP should be a param of the function.\n        const forDropID = 'FOR_DROP';\n        const forDrop = exclude && exclude.startsWith(forDropID);\n        if (forDrop) {\n            exclude = exclude.substring(forDropID.length);\n        }\n\n        // The `:not(.o_editable_media)` part is handled outside of the selector\n        // (see filterFunc).\n        // Note: the `:not([contenteditable=\"true\"])` part was there for that\n        // same purpose before the implementation of the o_editable_media class.\n        // It still make sense for potential editable areas though. Although it\n        // should be reviewed if we are to handle more hierarchy of nodes being\n        // editable despite their non editable environment.\n        // Without the `:not(.s_social_media)`, it is no longer possible to edit\n        // icons in the social media snippet. This should be fixed in a more\n        // proper way to get rid of this hack.\n        exclude += `${exclude && ', '}.o_snippet_not_selectable`;\n\n        let filterFunc = function () {\n            if (forDrop) {\n                // Prevents blocks from being dropped into an image field.\n                const selfOrParentEl = isChildren ? this.parentNode : this;\n                if (selfOrParentEl.closest(\"[data-oe-type=image]\")) {\n                    return false;\n                }\n            }\n            // Exclude what it is asked to exclude.\n            if ($(this).is(exclude)) {\n                return false;\n            }\n            if (noCheck) {\n                // When noCheck is true, we only check the exclude.\n                return true;\n            }\n            // `o_editable_media` bypasses the `o_not_editable` class except for\n            // drag & drop.\n            if (!forDrop && this.classList.contains('o_editable_media')) {\n                return weUtils.shouldEditableMediaBeEditable(this);\n            }\n            if (forDrop && !isChildren) {\n                // it's a drop-in.\n                return !$(this)\n                    .is('.o_not_editable :not([contenteditable=\"true\"]), .o_not_editable');\n            }\n            if (isChildren) {\n                return !$(this).is('.o_not_editable *');\n            }\n            return !$(this)\n                .is('.o_not_editable:not(.s_social_media) :not([contenteditable=\"true\"])');\n        };\n        if (target) {\n            const oldFilter = filterFunc;\n            filterFunc = function () {\n                return oldFilter.apply(this) && $(this).find(target).length !== 0;\n            };\n        }\n        if (excludeParent) {\n            const oldFilter = filterFunc;\n            filterFunc = function () {\n                return oldFilter.apply(this) && !$(this).parent().is(excludeParent);\n            };\n        }\n\n        // Prepare the functions\n        const functions = {};\n        // In translate mode, it is only possible to modify text content but not\n        // the structure of the snippets. For this reason, the \"Editable area\"\n        // are only the text zones and they should not be used inside functions\n        // such as \"is\", \"closest\" and \"all\".\n        if (noCheck || this.options.enableTranslation) {\n            functions.is = function ($from) {\n                return $from.is(selector) && $from.filter(filterFunc).length !== 0;\n            };\n            functions.closest = function ($from, parentNode) {\n                return $from.closest(selector, parentNode).filter(filterFunc);\n            };\n            functions.all = function ($from) {\n                return ($from ? dom.cssFind($from, selector) : self.$body.find(selector)).filter(filterFunc);\n            };\n        } else {\n            functions.is = function ($from) {\n                return $from.is(selector)\n                    && self.getEditableArea().find($from).addBack($from).length !== 0\n                    && $from.filter(filterFunc).length !== 0;\n            };\n            functions.closest = function ($from, parentNode) {\n                var parents = self.getEditableArea().get();\n                return $from.closest(selector, parentNode).filter(function () {\n                    var node = this;\n                    while (node.parentNode) {\n                        if (parents.indexOf(node) !== -1) {\n                            return true;\n                        }\n                        node = node.parentNode;\n                    }\n                    return false;\n                }).filter(filterFunc);\n            };\n            functions.all = isChildren ? function ($from) {\n                return dom.cssFind($from || self.getEditableArea(), selector).filter(filterFunc);\n            } : function ($from) {\n                $from = $from || self.getEditableArea();\n                return $from.filter(selector).add(dom.cssFind($from, selector)).filter(filterFunc);\n            };\n        }\n        return functions;\n    },\n    /**\n     * Processes the given snippet template to register snippet options, creates\n     * draggable thumbnail, etc.\n     *\n     * @private\n     * @param {string} html\n     */\n    _computeSnippetTemplates: function (html) {\n        var self = this;\n        var $html = $(html);\n        this._patchForComputeSnippetTemplates($html);\n        var $scroll = $html.siblings('#o_scroll');\n\n        // TODO adapt in master. This patches the BlogPostTagSelection option\n        // in stable versions. Done here to avoid converting the html back to\n        // a string.\n        const optionEl = $html.find('[data-js=\"BlogPostTagSelection\"][data-selector=\".o_wblog_post_page_cover\"]')[0];\n        if (optionEl) {\n            optionEl.dataset.selector = '.o_wblog_post_page_cover[data-res-model=\"blog.post\"]';\n        }\n\n        this.templateOptions = [];\n        var selectors = [];\n        var $styles = $html.find('[data-selector]');\n        const snippetAdditionDropIn = $styles.filter('#so_snippet_addition').data('drop-in');\n        $styles.each(function () {\n            var $style = $(this);\n            var selector = $style.data('selector');\n            var exclude = $style.data('exclude') || '';\n            const excludeParent = $style.attr('id') === \"so_content_addition\" ? snippetAdditionDropIn : '';\n            var target = $style.data('target');\n            var noCheck = $style.data('no-check');\n            // Note that the optionID will be used to add a class\n            // `snippet-option-XXX` (XXX being the optionID) on the related\n            // option DOM. This is used in JS tours. The data-js attribute can\n            // be used without a corresponding JS class being defined.\n            const optionID = $style.data('js');\n            var option = {\n                'option': optionID,\n                'base_selector': selector,\n                'base_exclude': exclude,\n                'base_target': target,\n                'selector': self._computeSelectorFunctions(selector, exclude, target, noCheck),\n                '$el': $style,\n                'drop-near': $style.data('drop-near') && self._computeSelectorFunctions($style.data('drop-near'), 'FOR_DROP', false, noCheck, true, excludeParent),\n                'drop-in': $style.data('drop-in') && self._computeSelectorFunctions($style.data('drop-in'), 'FOR_DROP', false, noCheck),\n                'drop-exclude-ancestor': this.dataset.dropExcludeAncestor,\n                'drop-lock-within': this.dataset.dropLockWithin,\n                'data': Object.assign({string: $style.attr('string')}, $style.data()),\n            };\n            self.templateOptions.push(option);\n            selectors.push(option.selector);\n        });\n        $styles.addClass('d-none');\n\n        globalSelector.closest = function ($from) {\n            var $temp;\n            var $target;\n            for (var i = 0, len = selectors.length; i < len; i++) {\n                $temp = selectors[i].closest($from, $target && $target[0]);\n                if ($temp.length) {\n                    $target = $temp;\n                }\n            }\n            return $target || $();\n        };\n        globalSelector.all = function ($from) {\n            var $target = $();\n            for (var i = 0, len = selectors.length; i < len; i++) {\n                $target = $target.add(selectors[i].all($from));\n            }\n            return $target;\n        };\n        globalSelector.is = function ($from, options = {}) {\n            for (var i = 0, len = selectors.length; i < len; i++) {\n                if (options.onlyTextOptions ? $from.is(self.templateOptions[i].data.textSelector) : selectors[i].is($from)) {\n                    return true;\n                }\n            }\n            return false;\n        };\n\n        this.$snippets = $scroll.find('.o_panel_body').children()\n            .addClass('oe_snippet')\n            .each((i, el) => {\n                const $snippet = $(el);\n                const name = el.getAttribute('name');\n                const thumbnailSrc = escape(el.dataset.oeThumbnail);\n                const $sbody = $snippet.children().addClass('oe_snippet_body');\n                const isCustomSnippet = !!el.closest('#snippet_custom');\n\n                // Associate in-page snippets to their name\n                // TODO I am not sure this is useful anymore and it should at\n                // least be made more robust using data-snippet\n                let snippetClasses = $sbody.attr('class').match(/s_[^ ]+/g);\n                if (snippetClasses && snippetClasses.length) {\n                    snippetClasses = '.' + snippetClasses.join('.');\n                }\n                const $els = self.$body.find(snippetClasses).not('[data-name]').add($(snippetClasses)).add($sbody);\n                $els.attr('data-name', name).data('name', name);\n\n                // Create the thumbnail\n                const $thumbnail = $(`\n                    <div class=\"oe_snippet_thumbnail\">\n                        <div class=\"oe_snippet_thumbnail_img\" style=\"background-image: url(${thumbnailSrc});\"></div>\n                        <span class=\"oe_snippet_thumbnail_title\">${escape(name)}</span>\n                    </div>\n                `);\n                $snippet.prepend($thumbnail);\n\n                // Create the install button (t-install feature) if necessary\n                const moduleID = $snippet.data('moduleId');\n                if (moduleID) {\n                    el.classList.add('o_snippet_install');\n                    $thumbnail.append($('<button/>', {\n                        class: 'btn btn-primary o_install_btn w-100',\n                        type: 'button',\n                        text: _t(\"Install\"),\n                    }));\n                }\n\n                // Create the rename and delete button for custom snippets\n                if (isCustomSnippet) {\n                    const btnRenameEl = document.createElement('we-button');\n                    btnRenameEl.dataset.snippetId = $snippet.data('oeSnippetId');\n                    btnRenameEl.classList.add('o_rename_btn', 'fa', 'fa-pencil', 'btn', 'o_we_hover_success');\n                    btnRenameEl.title = _t(\"Rename %s\", name);\n                    $snippet.append(btnRenameEl);\n                    const btnEl = document.createElement('we-button');\n                    btnEl.dataset.snippetId = $snippet.data('oeSnippetId');\n                    btnEl.classList.add('o_delete_btn', 'fa', 'fa-trash', 'btn', 'o_we_hover_danger');\n                    btnEl.title = _t(\"Delete %s\", name);\n                    $snippet.append(btnEl);\n                }\n            })\n            .not('[data-module-id]');\n\n        // Enable the snippet tooltips\n        this.$snippets.tooltip({\n            trigger: 'manual',\n            placement: 'bottom',\n            title: _t(\"Drag and drop the building block.\"),\n            // Ensure the tooltips have a good position when in iframe.\n            container: this.el,\n            // Prevent horizontal scroll when tooltip is displayed.\n            boundary: this.el.ownerDocument.body,\n        });\n\n        // Hide scroll if no snippets defined\n        if (!this.$snippets.length) {\n            this.$el.detach();\n        }\n\n        // Register the text nodes that needs to be auto-selected on click\n        this._registerDefaultTexts();\n\n        // Add the computed template and make elements draggable\n        this.$el.html($html);\n        this.$el.append(this.customizePanel);\n        this.$el.append(this.invisibleDOMPanelEl);\n        this._makeSnippetDraggable();\n        this._disableUndroppableSnippets();\n\n        this.$el.addClass('o_loaded');\n        $(this.el.ownerDocument.body).toggleClass('editor_has_snippets', !this.folded);\n    },\n    /**\n     * Eases patching the XML definition for snippets and options in stable\n     * versions. Note: in the future, we will probably move to other ways to\n     * define snippets and options.\n     *\n     * @private\n     * @param {jQuery}\n     */\n    _patchForComputeSnippetTemplates($html) {\n        // TODO: Remove in master and add it in template s_website_form\n        const websiteFormEditorOptionsEl = $html.find('[data-js=\"WebsiteFormEditor\"]')[0];\n        if (websiteFormEditorOptionsEl) {\n            websiteFormEditorOptionsEl.dataset.dropExcludeAncestor = \"form\";\n        }\n\n        // TODO: Remove in master and add it back in the template.\n        const $vAlignOption = $html.find(\"#row_valign_snippet_option\");\n        $vAlignOption[0].dataset.js = \"vAlignment\";\n\n        // Replace the \"src\" attribute of iframes with \"data-o-src-on-drop\" to\n        // prevent the iframes from loading in the snippet menu. This is a fix\n        // in stable that is no longer needed in later versions, where the\n        // snippets' HTML code is no longer rendered in the snippet menu.\n        const iframeEls = $html.find(\"[data-snippet] iframe[src]\");\n        for (const iframeEl of iframeEls) {\n            iframeEl.dataset.oSrcOnDrop = iframeEl.getAttribute(\"src\");\n            iframeEl.removeAttribute(\"src\");\n        }\n    },\n    /**\n     * Creates a snippet editor to associated to the given snippet. If the given\n     * snippet already has a linked snippet editor, the function only returns\n     * that one.\n     * The function also instantiates a snippet editor for all snippet parents\n     * as a snippet editor must be able to display the parent snippet options.\n     *\n     * @private\n     * @param {jQuery} $snippet\n     * @returns {Promise<SnippetEditor>}\n     */\n    _createSnippetEditor: function ($snippet) {\n        var self = this;\n        var snippetEditor = $snippet.data('snippet-editor');\n        if (snippetEditor) {\n            return snippetEditor.__isStarted;\n        }\n\n        // In translate mode, only allow creating the editor if the target is a\n        // text option snippet.\n        if (!$snippet.__force_create_editor && this.options.enableTranslation && !this._allowInTranslationMode($snippet)) {\n            return Promise.resolve(null);\n        }\n        // TODO: Adapt in master (property used in stable for compatibility).\n        delete $snippet.__force_create_editor;\n\n        var def;\n        if (this._allowParentsEditors($snippet)) {\n            var $parent = globalSelector.closest($snippet.parent());\n            if ($parent.length) {\n                def = this._createSnippetEditor($parent);\n            }\n        }\n\n        return Promise.resolve(def).then(function (parentEditor) {\n            // When reaching this position, after the Promise resolution, the\n            // snippet editor instance might have been created by another call\n            // to _createSnippetEditor... the whole logic should be improved\n            // to avoid doing this here.\n            snippetEditor = $snippet.data('snippet-editor');\n            if (snippetEditor) {\n                return snippetEditor.__isStarted;\n            }\n\n            let editableArea = self.getEditableArea();\n            snippetEditor = new SnippetEditor(parentEditor || self, $snippet, self.templateOptions, $snippet.closest('[data-oe-type=\"html\"], .oe_structure').add(editableArea), self.options);\n            self.snippetEditors.push(snippetEditor);\n            // Keep parent below its child inside the DOM as its `o_handle`\n            // needs to be (visually) on top of the child ones.\n            return snippetEditor.prependTo(self.$snippetEditorArea);\n        }).then(function () {\n            return snippetEditor;\n        });\n    },\n    /**\n     * There may be no location where some snippets might be dropped. This mades\n     * them appear disabled in the menu.\n     *\n     * @todo make them undraggable\n     * @private\n     */\n    _disableUndroppableSnippets: function () {\n        var self = this;\n        var cache = {};\n        this.$snippets.each(function () {\n            var $snippet = $(this);\n            var $snippetBody = $snippet.find('.oe_snippet_body');\n            const isSanitizeForbidden = $snippet.data('oeForbidSanitize');\n            const checkSanitize = isSanitizeForbidden === \"form\"\n                ? (el) => !el.closest('[data-oe-sanitize]:not([data-oe-sanitize=\"allow_form\"])')\n                : isSanitizeForbidden\n                    ? (el) => !el.closest('[data-oe-sanitize]')\n                    : () => true;\n            const isVisible = (el) => el.closest(\".o_snippet_invisible\")\n                ? !(el.offsetHeight === 0 || el.offsetWidth === 0)\n                : true;\n            const canDrop = ($els) => [...$els].some((el) => checkSanitize(el) && isVisible(el));\n\n            var check = false;\n            self.templateOptions.forEach((option, k) => {\n                if (check || !($snippetBody.is(option.base_selector) && !$snippetBody.is(option.base_exclude))) {\n                    return;\n                }\n\n                k = isSanitizeForbidden ? 'forbidden/' + k : k;\n                cache[k] = cache[k] || {\n                    'drop-near': option['drop-near'] ? canDrop(option['drop-near'].all()) : false,\n                    'drop-in': option['drop-in'] ? canDrop(option['drop-in'].all()) : false,\n                };\n                check = (cache[k]['drop-near'] || cache[k]['drop-in']);\n            });\n\n            $snippet.toggleClass('o_disabled', !check);\n            $snippet.attr('title', check ? '' : _t(\"No location to drop in\"));\n            const $icon = $snippet.find('.o_snippet_undroppable').remove();\n            if (check) {\n                $icon.remove();\n            } else if (!$icon.length) {\n                const imgEl = document.createElement('img');\n                imgEl.classList.add('o_snippet_undroppable');\n                imgEl.src = '/web_editor/static/src/img/snippet_disabled.svg';\n                $snippet.append(imgEl);\n            }\n        });\n    },\n    /**\n     * @private\n     * @param {string} [search]\n     */\n    _filterSnippets(search) {\n        const searchInputEl = this.el.querySelector('.o_snippet_search_filter_input');\n        const searchInputReset = this.el.querySelector('.o_snippet_search_filter_reset');\n        if (search !== undefined) {\n            searchInputEl.value = search;\n        } else {\n            search = searchInputEl.value;\n        }\n        search = search.toLowerCase();\n        searchInputReset.classList.toggle('d-none', !search);\n        const strMatches = str => !search || str.toLowerCase().includes(search);\n        for (const panelEl of this.el.querySelectorAll('.o_panel')) {\n            let hasVisibleSnippet = false;\n            const panelTitle = panelEl.querySelector('.o_panel_header').textContent;\n            const isPanelTitleMatch = strMatches(panelTitle);\n            for (const snippetEl of panelEl.querySelectorAll('.oe_snippet')) {\n                const matches = (isPanelTitleMatch\n                    || strMatches(snippetEl.getAttribute('name'))\n                    || strMatches(snippetEl.dataset.oeKeywords || ''));\n                if (matches) {\n                    hasVisibleSnippet = true;\n                }\n                snippetEl.classList.toggle('d-none', !matches);\n            }\n            panelEl.classList.toggle('d-none', !hasVisibleSnippet);\n        }\n    },\n    /**\n     * @private\n     * @param {Object} [options={}]\n     * @returns {Object}\n     */\n    _getDragAndDropOptions(options = {}) {\n        let iframeWindow = false;\n        if (this.$body[0].ownerDocument.defaultView !== window) {\n            iframeWindow = this.$body[0].ownerDocument.defaultView;\n        }\n        return Object.assign({}, options, {\n            iframeWindow,\n            cursor: \"move\",\n        });\n    },\n    /**\n     * Creates a dropzone element and inserts it by replacing the given jQuery\n     * location. This allows to add data on the dropzone depending on the hook\n     * environment.\n     *\n     * @private\n     * @param {jQuery} $hook\n     * @param {boolean} [vertical=false]\n     * @param {Object} [style]\n     * @param {string or boolean} canBeSanitizedUnless\n     *    true: always allow\n     *    'form': allow if forms are allowed\n     *    false: always fobid\n     */\n    _insertDropzone: function ($hook, vertical, style, canBeSanitizedUnless) {\n        const skip = $hook.closest('[data-oe-sanitize=\"no_block\"]').length;\n        let forbidSanitize;\n        if (canBeSanitizedUnless === 'form') {\n            forbidSanitize = $hook.closest('[data-oe-sanitize]:not([data-oe-sanitize=\"allow_form\"]):not([data-oe-sanitize=\"no_block\"])').length;\n        } else {\n            forbidSanitize = !canBeSanitizedUnless && $hook.closest('[data-oe-sanitize]:not([data-oe-sanitize=\"no_block\"])').length;\n        }\n        var $dropzone = $('<div/>', {\n            'class': skip ? 'd-none' : 'oe_drop_zone oe_insert' + (vertical ? ' oe_vertical' : '') +\n                (forbidSanitize ? ' text-center oe_drop_zone_danger' : ''),\n        });\n        if (style) {\n            $dropzone.css(style);\n        }\n        if (forbidSanitize) {\n            $dropzone[0].appendChild(document.createTextNode(\n                _t(\"For technical reasons, this block cannot be dropped here\")\n            ));\n        }\n        $hook.replaceWith($dropzone);\n        return $dropzone;\n    },\n    /**\n     * Creates a dropzone taking the entire area of the row in grid mode in\n     * which it will be added. It allows to place elements dragged over it\n     * inside the grid it belongs to.\n     *\n     * @param {Element} rowEl\n     */\n    _insertGridDropzone(rowEl) {\n        const columnCount = 12;\n        const rowCount = parseInt(rowEl.dataset.rowCount);\n        let $dropzone = $('<div/>', {\n            'class': 'oe_drop_zone oe_insert oe_grid_zone',\n            'style': 'grid-area: ' + 1 + '/' + 1 + '/' + (rowCount + 1) + '/' + (columnCount + 1),\n        });\n        $dropzone[0].style.minHeight = window.getComputedStyle(rowEl).height;\n        $dropzone[0].style.width = window.getComputedStyle(rowEl).width;\n        rowEl.append($dropzone[0]);\n    },\n    /**\n     * Make given snippets be draggable/droppable thanks to their thumbnail.\n     *\n     * @private\n     */\n    _makeSnippetDraggable() {\n        if (this.draggableComponent) {\n            this.draggableComponent.destroy();\n        }\n        var $toInsert, dropped, $snippet;\n        let $dropZones;\n\n        let dragAndDropResolve;\n        let $scrollingElement = $().getScrollingElement(this.$body[0].ownerDocument);\n        if (!$scrollingElement[0] || $scrollingElement.find('body.o_in_iframe').length) {\n            $scrollingElement = $(this.ownerDocument).find('.o_editable');\n        }\n\n        const dragAndDropOptions = this.options.getDragAndDropOptions({\n            el: this.$el[0],\n            elements: \".oe_snippet\",\n            scrollingElement: $scrollingElement[0],\n            handle: '.oe_snippet_thumbnail:not(.o_we_already_dragging)',\n            cancel: '.oe_snippet.o_disabled',\n            dropzones: () => {\n                return $dropZones.toArray();\n            },\n            helper: ({ element, elementRect, helperOffset, x, y }) => {\n                const dragSnip = element.cloneNode(true);\n                dragSnip.querySelectorAll('.o_delete_btn, .o_rename_btn').forEach(\n                    el => el.remove()\n                );\n                dragSnip.style.position = \"fixed\";\n                this.$el[0].ownerDocument.body.append(dragSnip);\n                // Prepare the offset of the helper to be at the position it was dragged from\n                helperOffset.x = x - elementRect.x;\n                helperOffset.y = y - elementRect.y;\n                return dragSnip;\n            },\n            onDragStart: ({ element }) => {\n                this._hideSnippetTooltips();\n\n                const prom = new Promise(resolve => dragAndDropResolve = () => resolve());\n                this._mutex.exec(() => prom);\n\n                const doc = this.options.wysiwyg.odooEditor.document;\n                $(doc.body).addClass('oe_dropzone_active');\n\n                this.options.wysiwyg.odooEditor.automaticStepUnactive();\n\n                this.$el.find('.oe_snippet_thumbnail').addClass('o_we_already_dragging');\n                this.options.wysiwyg.odooEditor.observerUnactive('dragAndDropCreateSnippet');\n\n                dropped = false;\n                $snippet = $(element);\n                var $baseBody = $snippet.find('.oe_snippet_body');\n                var $selectorSiblings = $();\n                var $selectorChildren = $();\n                const selectorExcludeAncestor = [];\n                var temp = this.templateOptions;\n                for (var k in temp) {\n                    if ($baseBody.is(temp[k].base_selector) && !$baseBody.is(temp[k].base_exclude)) {\n                        if (temp[k]['drop-near']) {\n                            $selectorSiblings = $selectorSiblings.add(temp[k]['drop-near'].all());\n                        }\n                        if (temp[k]['drop-in']) {\n                            $selectorChildren = $selectorChildren.add(temp[k]['drop-in'].all());\n                        }\n                        if (temp[k]['drop-exclude-ancestor']) {\n                            selectorExcludeAncestor.push(temp[k]['drop-exclude-ancestor']);\n                        }\n                    }\n                }\n\n                // Prevent dropping an element into another one.\n                // (E.g. ToC inside another ToC)\n                for (const excludedAncestorSelector of selectorExcludeAncestor) {\n                    $selectorSiblings = $selectorSiblings.filter((i, el) => !el.closest(excludedAncestorSelector));\n                    $selectorChildren = $selectorChildren.filter((i, el) => !el.closest(excludedAncestorSelector));\n                }\n\n                $toInsert = $baseBody.clone();\n                // Color-customize dynamic SVGs in dropped snippets with current theme colors.\n                [...$toInsert.find('img[src^=\"/web_editor/shape/\"]')].forEach(dynamicSvg => {\n                    const colorCustomizedURL = new URL(dynamicSvg.getAttribute('src'), window.location.origin);\n                    colorCustomizedURL.searchParams.forEach((value, key) => {\n                        const match = key.match(/^c([1-5])$/);\n                        if (match) {\n                            colorCustomizedURL.searchParams.set(key, weUtils.getCSSVariableValue(`o-color-${match[1]}`));\n                        }\n                    });\n                    dynamicSvg.src = colorCustomizedURL.pathname + colorCustomizedURL.search;\n                });\n\n                // The iframes must be loaded when the drag-and-drop starts and not when the snippet\n                // menu is loaded.\n                const iframeEls = $toInsert[0].querySelectorAll(\"iframe[data-o-src-on-drop]\");\n                for (const iframeEl of iframeEls) {\n                    iframeEl.setAttribute(\"src\", iframeEl.dataset.oSrcOnDrop);\n                    delete iframeEl.dataset.oSrcOnDrop;\n                }\n\n                if (!$selectorSiblings.length && !$selectorChildren.length) {\n                    console.warn($snippet.find('.oe_snippet_thumbnail_title').text() + \" have not insert action: data-drop-near or data-drop-in\");\n                    return;\n                }\n\n                const forbidSanitize = $snippet.data('oeForbidSanitize');\n                const canBeSanitizedUnless = forbidSanitize === 'form' ? 'form' : !forbidSanitize;\n                // Specific case for inline snippet (e.g. \"s_badge\")\n                    $baseBody[0].classList.remove(\"oe_snippet_body\");\n                    const toInsertInline = window.getComputedStyle($baseBody[0]).display.includes('inline');\n                    $baseBody[0].classList.add(\"oe_snippet_body\");\n                    this._activateInsertionZones($selectorSiblings, $selectorChildren, canBeSanitizedUnless, toInsertInline);\n                $dropZones = this.getEditableArea().find('.oe_drop_zone');\n                if (forbidSanitize === 'form') {\n                    $dropZones = $dropZones.filter((i, el) => !el.closest('[data-oe-sanitize]:not([data-oe-sanitize=\"allow_form\"]) .oe_drop_zone'));\n                } else if (forbidSanitize) {\n                    $dropZones = $dropZones.filter((i, el) => !el.closest('[data-oe-sanitize] .oe_drop_zone'));\n                }\n                // If a modal is open, the scroll target must be that modal\n                const $openModal = this.getEditableArea().find('.modal:visible');\n                if ($openModal.length) {\n                    this.draggableComponent.update({ scrollingElement: $openModal[0]});\n                    $scrollingElement = $openModal;\n                }\n                this.trigger_up('drop_zone_start');\n            },\n            dropzoneOver: ({ dropzone }) => {\n                if (dropped) {\n                    $toInsert.detach();\n                    $toInsert.addClass('oe_snippet_body');\n                    [...$dropZones].forEach(dropzoneEl =>\n                        dropzoneEl.classList.remove(\"invisible\"));\n                }\n                dropped = true;\n                $(dropzone.el).first().after($toInsert).addClass('invisible');\n                $toInsert.removeClass('oe_snippet_body');\n                this.trigger_up('drop_zone_over');\n            },\n            dropzoneOut: ({ dropzone }) => {\n                var prev = $toInsert.prev();\n                if (dropzone.el === prev[0]) {\n                    dropped = false;\n                    $toInsert.detach();\n                    $(dropzone.el).removeClass('invisible');\n                    $toInsert.addClass('oe_snippet_body');\n                }\n                this.trigger_up('drop_zone_out');\n            },\n            onDragEnd: async ({ x, y, helper }) => {\n                const doc = this.options.wysiwyg.odooEditor.document;\n                $(doc.body).removeClass('oe_dropzone_active');\n                this.options.wysiwyg.odooEditor.automaticStepUnactive();\n                this.options.wysiwyg.odooEditor.automaticStepSkipStack();\n                $toInsert.removeClass('oe_snippet_body');\n                $scrollingElement.off('scroll.scrolling_element');\n                if (!dropped && y > 3 && x + helper.getBoundingClientRect().height < this.el.getBoundingClientRect().left) {\n                    const point = { x, y };\n                    let droppedOnNotNearest = touching(doc.body.querySelectorAll('.oe_structure_not_nearest'), point);\n                    // If dropped outside of a dropzone with class oe_structure_not_nearest,\n                    // move the snippet to the nearest dropzone without it\n                    const selector = droppedOnNotNearest\n                        ? '.oe_drop_zone'\n                        : ':not(.oe_structure_not_nearest) > .oe_drop_zone';\n                    let $el = $(closest(doc.body.querySelectorAll(selector), point));\n                    // Some drop zones might have been disabled.\n                    $el = $el.filter($dropZones);\n                    if ($el.length) {\n                        $el.after($toInsert);\n                        dropped = true;\n                    }\n                }\n\n                this.getEditableArea().find('.oe_drop_zone').remove();\n\n                let $toInsertParent;\n                let prev;\n                let next;\n                if (dropped) {\n                    prev = $toInsert.first()[0].previousSibling;\n                    next = $toInsert.last()[0].nextSibling;\n\n                    $toInsertParent = $toInsert.parent();\n                    $toInsert.detach();\n                }\n\n                this.options.wysiwyg.odooEditor.observerActive('dragAndDropCreateSnippet');\n\n                if (dropped) {\n                    if (prev) {\n                        $toInsert.insertAfter(prev);\n                    } else if (next) {\n                        $toInsert.insertBefore(next);\n                    } else {\n                        $toInsertParent.prepend($toInsert);\n                    }\n\n                    var $target = $toInsert;\n                    this._updateDroppedSnippet($target);\n\n                    this.options.wysiwyg.odooEditor.observerUnactive('dragAndDropCreateSnippet');\n                    await this._scrollToSnippet($target, this.$scrollable);\n                    this.options.wysiwyg.odooEditor.observerActive('dragAndDropCreateSnippet');\n\n                    browser.setTimeout(async () => {\n                        // Free the mutex now to allow following operations\n                        // (mutexed as well).\n                        dragAndDropResolve();\n\n                        this.__postSnippetDropExtraActions = () => {\n                            // Restore editor to its normal edition state, also\n                            // make sure the undroppable snippets are updated.\n                            this._disableUndroppableSnippets();\n                            this.options.wysiwyg.odooEditor.unbreakableStepUnactive();\n                            this.options.wysiwyg.odooEditor.historyStep();\n                            this.$el.find('.oe_snippet_thumbnail').removeClass('o_we_already_dragging');\n                        };\n                        await this.callPostSnippetDrop($target);\n                    });\n                } else {\n                    $toInsert.remove();\n                    if (dragAndDropResolve) {\n                        dragAndDropResolve();\n                    }\n                    this.$el.find('.oe_snippet_thumbnail').removeClass('o_we_already_dragging');\n                }\n                this.trigger_up('drop_zone_stop');\n            },\n        });\n        this.draggableComponent = useDragAndDrop({ ref: { el: this.el }, ...dragAndDropOptions });\n    },\n    /**\n     * Adds the 'o_default_snippet_text' class on nodes which contain only\n     * non-empty text nodes. Those nodes are then auto-selected by the editor\n     * when they are clicked.\n     *\n     * @private\n     * @param {jQuery} [$in] - the element in which to search, default to the\n     *                       snippet bodies in the menu\n     */\n    _registerDefaultTexts: function ($in) {\n        if ($in === undefined) {\n            // By default, we don't want the `o_default_snippet_text` class on\n            // custom snippets. Those are most likely already ready, we don't\n            // really need the auto-selection by the editor.\n            $in = this.$snippets.find('.oe_snippet_body:not(.s_custom_snippet)');\n        }\n\n        $in.find('*').addBack()\n            .contents()\n            .filter(function () {\n                return this.nodeType === 3 && this.textContent.match(/\\S/);\n            }).parent().addClass('o_default_snippet_text');\n    },\n    /**\n     * Changes the content of the left panel and selects a tab.\n     *\n     * @private\n     * @param {htmlString | Element | Text | Array | jQuery} [content]\n     * the new content of the customizePanel\n     * @param {this.tabs.VALUE} [tab='blocks'] - the tab to select\n     */\n    _updateRightPanelContent: function ({content, tab, ...options}) {\n        this._hideTooltips();\n        this._closeWidgets();\n\n        // In translation mode, only the options tab is available.\n        if (this.options.enableTranslation) {\n            tab = this.tabs.OPTIONS;\n        }\n\n        this._currentTab = tab || this.tabs.BLOCKS;\n\n        if (this._$toolbarContainer) {\n            this._$toolbarContainer[0].remove();\n        }\n        this._$toolbarContainer = null;\n        if (content) {\n            while (this.customizePanel.firstChild) {\n                this.customizePanel.removeChild(this.customizePanel.firstChild);\n            }\n            $(this.customizePanel).append(content);\n            if (this._currentTab === this.tabs.OPTIONS && !options.forceEmptyTab) {\n                this._addToolbar();\n            }\n        }\n\n        this.$('.o_snippet_search_filter').toggleClass('d-none', this._currentTab !== this.tabs.BLOCKS);\n        this.$('#o_scroll').toggleClass('d-none', this._currentTab !== this.tabs.BLOCKS);\n        this.customizePanel.classList.toggle('d-none', this._currentTab === this.tabs.BLOCKS);\n        // Remove active class of custom button (e.g. mass mailing theme selection).\n        this.$('#snippets_menu button').removeClass('active');\n        this.$('.o_we_add_snippet_btn').toggleClass('active', this._currentTab === this.tabs.BLOCKS);\n        this.$('.o_we_customize_snippet_btn').toggleClass('active', this._currentTab === this.tabs.OPTIONS);\n    },\n    /**\n     * Scrolls to given snippet.\n     *\n     * @private\n     * @param {jQuery} $el - snippet to scroll to\n     * @param {jQuery} [$scrollable] - $element to scroll\n     * @return {Promise}\n     */\n    async _scrollToSnippet($el, $scrollable) {\n        // Don't scroll if $el is added to a visible popup that does not fill\n        // the page (otherwise the page would scroll to a random location).\n        const modalEl = $el[0].closest('.modal');\n        if (modalEl && !$(modalEl).hasScrollableContent()) {\n            return;\n        }\n        return dom.scrollTo($el[0], {extraOffset: 50, $scrollable: $scrollable});\n    },\n    /**\n     * @private\n     * @returns {HTMLElement}\n     */\n    _createLoadingElement() {\n        const loaderContainer = document.createElement('div');\n        const loader = document.createElement('img');\n        const loaderContainerClassList = [\n            'o_we_ui_loading',\n            'd-flex',\n            'justify-content-center',\n            'align-items-center',\n        ];\n        loaderContainer.classList.add(...loaderContainerClassList);\n        loader.setAttribute('src', '/web/static/img/spin.svg');\n        loaderContainer.appendChild(loader);\n        return loaderContainer;\n    },\n    /**\n     * Adds the action to the mutex queue and sets a loading effect over the\n     * editor to appear if the action takes too much time.\n     * As soon as the mutex is unlocked, the loading effect will be removed.\n     *\n     * @private\n     * @param {function} action\n     * @param {boolean} [contentLoading=true]\n     * @param {number} [delay=500]\n     * @returns {Promise}\n     */\n    async _execWithLoadingEffect(action, contentLoading = true, delay = 500) {\n        const mutexExecResult = this._mutex.exec(action);\n        if (!this.loadingTimers[contentLoading]) {\n            const addLoader = () => {\n                if (this._loadingEffectDisabled || this.loadingElements[contentLoading]) {\n                    return;\n                }\n                this.loadingElements[contentLoading] = this._createLoadingElement();\n                if (contentLoading) {\n                    this.$snippetEditorArea.append(this.loadingElements[contentLoading]);\n                } else {\n                    this.el.appendChild(this.loadingElements[contentLoading]);\n                }\n            };\n            if (delay) {\n                this.loadingTimers[contentLoading] = setTimeout(addLoader, delay);\n            } else {\n                addLoader();\n            }\n            this._mutex.getUnlockedDef().then(() => {\n                // Note: we remove the loading element at the end of the\n                // execution queue *even if subsequent actions are content\n                // related or not*. This is a limitation of the loading feature,\n                // the goal is still to limit the number of elements in that\n                // queue anyway.\n                if (delay) {\n                    clearTimeout(this.loadingTimers[contentLoading]);\n                    this.loadingTimers[contentLoading] = undefined;\n                }\n\n                if (this.loadingElements[contentLoading]) {\n                    this.loadingElements[contentLoading].remove();\n                    this.loadingElements[contentLoading] = null;\n                }\n            });\n        }\n        return mutexExecResult;\n    },\n    /**\n     * Update the options pannel as being empty.\n     *\n     * TODO review the utility of that function and how to call it (it was not\n     * called inside a mutex then we had to do it... there must be better things\n     * to do).\n     *\n     * @private\n     */\n    _activateEmptyOptionsTab() {\n        this._updateRightPanelContent({\n            content: this.emptyOptionsTabContent,\n            tab: this.tabs.OPTIONS,\n            forceEmptyTab: true,\n        });\n    },\n    /**\n     * Hides the active tooltips.\n     *\n     * The BS documentation says that \"Tooltips that use delegation (which are\n     * created using the selector option) cannot be individually destroyed on\n     * descendant trigger elements\". So this function should be useful to remove\n     * the active tooltips manually.\n     * For instance, without this, clicking on \"Hide in Desktop\" on a snippet\n     * will leave the tooltip \"forever\" visible even if the \"Hide in Desktop\"\n     * button is gone.\n     *\n     * @private\n     */\n    _hideTooltips() {\n        // While functionally there is probably no way to have multiple active\n        // tooltips, it is possible that the panel contains multiple tooltip\n        // descriptions (we do not know what is in customers' own saved snippets\n        // for example). In any case, it does not hurt to technically consider\n        // the case anyway.\n        const tooltipTargetEls = this.el.querySelectorAll('[aria-describedby^=\"tooltip\"]');\n        for (const el of tooltipTargetEls) {\n            Tooltip.getInstance(el)?.hide();\n        }\n    },\n    /**\n     * Returns whether the edited content is a mobile view content.\n     *\n     * @returns {boolean}\n     */\n    _isMobile() {\n        return weUtils.isMobileView(this.$body[0]);\n    },\n    /**\n     * @private\n     */\n    _allowParentsEditors($snippet) {\n        return !this.options.enableTranslation\n            && !$snippet[0].classList.contains(\"o_no_parent_editor\");\n    },\n    /**\n     * @private\n     */\n    _allowInTranslationMode($snippet) {\n        return globalSelector.is($snippet, { onlyTextOptions: true });\n    },\n    /**\n     * Allows to update the snippets to build & adapt dynamic content right\n     * after adding it to the DOM.\n     *\n     * @private\n     */\n    _updateDroppedSnippet($target) {\n        if ($target[0].classList.contains(\"o_snippet_drop_in_only\")) {\n            // If it's a \"drop in only\" snippet, after dropping\n            // it, we modify it so that it's no longer a\n            // draggable snippet but rather simple HTML code, as\n            // if the element had been created with the editor.\n            $target[0].classList.remove(\"o_snippet_drop_in_only\");\n            delete $target[0].dataset.snippet;\n            delete $target[0].dataset.name;\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Activates the right snippet and initializes its SnippetEditor.\n     *\n     * @private\n     */\n    _onClick(ev) {\n        // Clicking in the page should be ignored on save\n        if (this.options.wysiwyg.isSaving()) {\n            return;\n        }\n\n        var srcElement = ev.target || (ev.originalEvent && (ev.originalEvent.target || ev.originalEvent.originalTarget)) || ev.srcElement;\n        if (!srcElement || this.lastElement === srcElement) {\n            return;\n        }\n        var $target = $(srcElement);\n        // Keep popover open if clicked inside it, but not on a button\n        if ($target.parents('.o_edit_menu_popover').length && !$target.parent('a').addBack('a').length) {\n            return;\n        }\n        this.lastElement = srcElement;\n        browser.setTimeout(() => {\n            this.lastElement = false;\n        });\n\n        if (!$target.closest('we-button, we-toggler, we-select, .o_we_color_preview').length) {\n            this._closeWidgets();\n        }\n        if (!$target.closest('body > *').length || $target.is('#iframe_target')) {\n            return;\n        }\n        if ($target.closest(this._notActivableElementsSelector).length) {\n            return;\n        }\n        const $oeStructure = $target.closest('.oe_structure');\n        if ($oeStructure.length && !$oeStructure.children().length && this.$snippets) {\n            // If empty oe_structure, encourage using snippets in there by\n            // making them \"wizz\" in the panel.\n            this._activateSnippet(false).then(() => {\n                this.$snippets.odooBounce();\n            });\n            return;\n        }\n        this._activateSnippet($target);\n    },\n    /**\n     * Called when a child editor asks for insertion zones to be enabled.\n     *\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onActivateInsertionZones: function (ev) {\n        this._activateInsertionZones(ev.data.$selectorSiblings, ev.data.$selectorChildren, ev.data.canBeSanitizedUnless, ev.data.toInsertInline, ev.data.selectorGrids, ev.data.fromIframe);\n    },\n    /**\n     * Called when a child editor asks to deactivate the current snippet\n     * overlay.\n     *\n     * @private\n     */\n    _onActivateSnippet: function (ev) {\n        const prom = this._activateSnippet(ev.data.$snippet, ev.data.previewMode, ev.data.ifInactiveOptions);\n        if (ev.data.onSuccess) {\n            prom.then(() => ev.data.onSuccess());\n        }\n    },\n    /**\n     * Called when a child editor asks to operate some operation on all child\n     * snippet of a DOM element.\n     *\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onCallForEachChildSnippet: function (ev) {\n        this._callForEachChildSnippet(ev.data.$snippet, ev.data.callback)\n            .then(() => ev.data.onSuccess());\n    },\n    /**\n     * Called when the overlay dimensions/positions should be recomputed.\n     *\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onOverlaysCoverUpdate: function (ev) {\n        this.snippetEditors.forEach(editor => {\n            if (ev.data.overlayVisible) {\n                editor.toggleOverlayVisibility(true);\n            }\n            editor.cover();\n        });\n    },\n    /**\n     * Called when a child editor asks to clone a snippet, allows to correctly\n     * call the _onClone methods if the element's editor has one.\n     *\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onCloneSnippet: async function (ev) {\n        ev.stopPropagation();\n        const editor = await this._createSnippetEditor(ev.data.$snippet);\n        await editor.clone();\n        if (ev.data.onSuccess) {\n            ev.data.onSuccess();\n        }\n    },\n    /**\n     * Called when a child editor asks to clean the UI of a snippet.\n     *\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onCleanUIRequest(ev) {\n        const targetEditors = this.snippetEditors.filter(editor => {\n            return ev.data.targetEl.contains(editor.$target[0]);\n        });\n        Promise.all(targetEditors.map(editor => editor.cleanUI())).then(() => {\n            ev.data.onSuccess();\n        });\n    },\n    /**\n     * Called when a child editor asks to deactivate the current snippet\n     * overlay.\n     *\n     * @private\n     */\n    _onDeactivateSnippet: function () {\n        this._activateSnippet(false);\n    },\n    /**\n    * Called when a snippet will move in the page.\n    *\n    * @private\n    */\n   _onSnippetDragAndDropStart: function () {\n        this.snippetEditorDragging = true;\n    },\n    /**\n     * Called when a snippet has moved in the page.\n     *\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onSnippetDragAndDropStop: async function (ev) {\n        this.snippetEditorDragging = false;\n        const visibleConditionalEls = [];\n        for (const snippetEditor of this.snippetEditors) {\n            const targetEl = snippetEditor.$target[0];\n            if (targetEl.dataset[\"visibility\"] === \"conditional\" &&\n                !targetEl.classList.contains(\"o_conditional_hidden\")) {\n                visibleConditionalEls.push(targetEl);\n            }\n        }\n        const modalEl = ev.data.$snippet[0].closest('.modal');\n        const carouselItemEl = ev.data.$snippet[0].closest('.carousel-item');\n        // If the snippet is in a modal, destroy editors only in that modal.\n        // This to prevent the modal from closing because of the cleanForSave\n        // on each editors. Same thing for 'carousel-item', otherwise all the\n        // editors of the 'carousel' are destroyed and the 'carousel' jumps to\n        // first slide.\n        await this._destroyEditors(carouselItemEl ? $(carouselItemEl) : modalEl ? $(modalEl) : null);\n        await this._activateSnippet(ev.data.$snippet);\n        // Because of _destroyEditors(), all the snippets with a conditional\n        // visibility are hidden. Show the ones that were visible before the\n        // drag and drop.\n        for (const visibleConditionalEl of visibleConditionalEls) {\n            visibleConditionalEl.classList.remove(\"o_conditional_hidden\");\n            delete visibleConditionalEl.dataset[\"invisible\"];\n        }\n        // Update the \"Invisible Elements\" panel as the order of invisible\n        // snippets could have changed on the page.\n        await this._updateInvisibleDOM();\n    },\n    /**\n     * Transforms an event coming from a touch screen into a mouse event.\n     *\n     * @private\n     * @param {Event} ev - a touch event\n     */\n    _onTouchEvent(ev) {\n        if (ev.touches.length > 1 || ev.changedTouches.length < 1) {\n            // Ignore multi-touch events.\n            return;\n        }\n        const touch = ev.changedTouches[0];\n        const touchToMouse = {\n            touchstart: \"mousedown\",\n            touchmove: \"mousemove\",\n            touchend: \"mouseup\"\n        };\n        const simulatedEvent = new MouseEvent(touchToMouse[ev.type], {\n            screenX: touch.screenX,\n            screenY: touch.screenY,\n            clientX: touch.clientX,\n            clientY: touch.clientY,\n            button: 0, // left mouse button\n            bubbles: true,\n            cancelable: true,\n        });\n        touch.target.dispatchEvent(simulatedEvent);\n    },\n    /**\n     * Returns the droppable snippet from which a dropped snippet originates.\n     *\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onFindSnippetTemplate(ev) {\n        this.$snippets.each(function () {\n            const snippetBody = this.querySelector(`.oe_snippet_body[data-snippet=${ev.data.snippet.dataset.snippet}]`);\n            if (snippetBody) {\n                ev.data.callback(snippetBody.parentElement);\n                return false;\n            }\n        });\n    },\n    /**\n     * @private\n     */\n    _onHideOverlay: function () {\n        for (const editor of this.snippetEditors) {\n            editor.toggleOverlay(false);\n        }\n    },\n    /**\n     * @private\n     * @param {Event} ev\n     */\n    _onInstallBtnClick: function (ev) {\n        var $snippet = $(ev.currentTarget).closest('[data-module-id]');\n        var moduleID = $snippet.data('moduleId');\n        const moduleDisplayName = `\"${$snippet[0].dataset.moduleDisplayName}\"`;\n        const bodyText = _t(\"Do you want to install %s App?\", moduleDisplayName);\n        const linkText = _t(\"More info about this app.\");\n        const linkUrl = '/web#id=' + encodeURIComponent(moduleID) + '&view_type=form&model=ir.module.module&action=base.open_module_tree';\n        this.dialog.add(ConfirmationDialog, {\n            title: _t(\"Install %s\", moduleDisplayName),\n            body: markup(`${escape(bodyText)}\\n<a href=\"${linkUrl}\" target=\"_blank\"><i class=\"oi oi-arrow-right me-1\"></i>${escape(linkText)}</a>`),\n            confirm: async () => {\n                try {\n                    await this.orm.call(\"ir.module.module\", \"button_immediate_install\", [[moduleID]]);\n                    this.trigger_up('request_save', {\n                        invalidateSnippetCache: true,\n                        _toMutex: true,\n                        reloadWebClient: true,\n                    });\n                } catch (e) {\n                    if (e instanceof RPCError) {\n                        const message = escape(_t(\"Could not install module %s\", moduleDisplayName));\n                        this.notification.add(message, {\n                            type: \"danger\",\n                            sticky: true,\n                        });\n                    } else {\n                        throw e;\n                    }\n                }\n            },\n            confirmLabel: _t(\"Save and Install\"),\n            cancel: () => {},\n        });\n    },\n    /**\n     * @private\n     * @param {Event} ev\n     */\n    _onInvisibleEntryClick: async function (ev) {\n        ev.preventDefault();\n        const $snippet = $(this.invisibleDOMMap.get(ev.currentTarget));\n        $snippet.__force_create_editor = true;\n        const isVisible = await this._execWithLoadingEffect(async () => {\n            const editor = await this._createSnippetEditor($snippet);\n            const show = editor.toggleTargetVisibility();\n            this._disableUndroppableSnippets();\n            return show;\n        }, true);\n        $(ev.currentTarget).find('.fa')\n            .toggleClass('fa-eye', isVisible)\n            .toggleClass('fa-eye-slash', !isVisible);\n        return this._activateSnippet(isVisible ? $snippet : false);\n    },\n    /**\n     * @private\n     */\n    _onBlocksTabClick: function (ev) {\n        this._activateSnippet(false);\n    },\n    /**\n     * @private\n     */\n    _onOptionsTabClick: function (ev) {\n        if (!ev.currentTarget.classList.contains('active')) {\n            this._activateSnippet(false);\n            this._mutex.exec(() => {\n                this._activateEmptyOptionsTab();\n            });\n        }\n    },\n    /**\n     * @private\n     */\n    _onDeleteBtnClick: function (ev) {\n        const $snippet = $(ev.target).closest('.oe_snippet');\n        const snippetId = parseInt(ev.currentTarget.dataset.snippetId);\n        ev.stopPropagation();\n        const message = _t(\"Are you sure you want to delete the snippet %s?\", $snippet[0].getAttribute(\"name\"));\n        this.dialog.add(ConfirmationDialog, {\n            body: message,\n            confirm: async () => {\n                await this.orm.call(\"ir.ui.view\", \"delete_snippet\", [], {\n                    'view_id': snippetId,\n                    'template_key': this.options.snippets,\n                });\n                await this._loadSnippetsTemplates(true);\n            },\n            cancel: () => null,\n            confirmLabel: _t(\"Yes\"),\n            cancelLabel: _t(\"No\"),\n        });\n    },\n    /**\n     * @private\n     */\n    _onRenameBtnClick: function (ev) {\n        const $snippet = $(ev.target).closest('.oe_snippet');\n        const snippetName = $snippet.attr('name');\n        const confirmText = _t('Confirm');\n        const cancelText = _t('Cancel');\n        const $input = $(`\n            <we-input class=\"o_we_user_value_widget w-100 mx-1\">\n                <div>\n                    <input type=\"text\" autocomplete=\"chrome-off\" value=\"${snippetName}\" class=\"text-start\"/>\n                    <we-button class=\"o_we_confirm_btn o_we_text_success fa fa-check\" title=\"${confirmText}\"></we-button>\n                    <we-button class=\"o_we_cancel_btn o_we_text_danger fa fa-times\" title=\"${cancelText}\"></we-button>\n                </div>\n            </we-input>\n        `);\n        $snippet.find('we-button').remove();\n        $snippet.find('span.oe_snippet_thumbnail_title').replaceWith($input);\n        const $textInput = $input.find('input');\n        $textInput.focus();\n        $textInput.select();\n        $snippet.find('.oe_snippet_thumbnail').addClass('o_we_already_dragging'); // prevent drag\n        $input.find('.o_we_confirm_btn').click(async () => {\n            const name = $textInput.val();\n            if (name !== snippetName) {\n                this._execWithLoadingEffect(async () => {\n                    await this.orm.call(\"ir.ui.view\", \"rename_snippet\", [], {\n                        'name': name,\n                        'view_id': parseInt(ev.target.dataset.snippetId),\n                        'template_key': this.options.snippets,\n                    });\n                }, true);\n            }\n            await this._loadSnippetsTemplates(name !== snippetName);\n        });\n        $input.find('.o_we_cancel_btn').click(async () => {\n            await this._loadSnippetsTemplates(false);\n        });\n    },\n    /**\n     * Prevents pointer-events to change the focus when a pointer slide from\n     * left-panel to the editable area.\n     *\n     * @private\n     */\n    _onMouseDown: function (ev) {\n        const $blockedArea = $('#wrapwrap'); // TODO should get that element another way\n        this.options.wysiwyg.odooEditor.automaticStepSkipStack();\n        $blockedArea.addClass('o_we_no_pointer_events');\n        const reenable = () => {\n            this.options.wysiwyg.odooEditor.automaticStepSkipStack();\n            $blockedArea.removeClass('o_we_no_pointer_events');\n        };\n        // Use a setTimeout fallback to avoid locking the editor if the mouseup\n        // is fired over an element which stops propagation for example.\n        const enableTimeoutID = setTimeout(() => reenable(), 5000);\n        $(document).one('mouseup', () => {\n            clearTimeout(enableTimeoutID);\n            reenable();\n        });\n    },\n    /**\n     * @private\n     */\n    _onMouseUp(ev) {\n        const snippetEl = ev.target.closest('.oe_snippet');\n        if (snippetEl && !snippetEl.querySelector(\".o_we_already_dragging\")\n                    && !ev.target.matches(\".o_rename_btn\")) {\n            this._showSnippetTooltip($(snippetEl));\n        }\n    },\n    /**\n     * Displays an autofading tooltip over a snippet, after a delay.\n     * If in the meantime the user has started to drag the snippet, it won't be\n     * shown.\n     *\n     * TODO: remove delay param in master\n     *\n     * @private\n     * @param {jQuery} $snippet\n     * @param {Number} [delay=1500]\n     */\n    _showSnippetTooltip($snippet, delay = 1500) {\n        this.$snippets.not($snippet).tooltip('hide');\n        $snippet.tooltip('show');\n        this._hideSnippetTooltips(1500);\n    },\n    /**\n     * @private\n     * @param {Number} [delay=0]\n     */\n    _hideSnippetTooltips(delay = 0) {\n        clearTimeout(this.__hideSnippetTooltipTimeout);\n        this.__hideSnippetTooltipTimeout = setTimeout(() => {\n            this.$snippets.tooltip('hide');\n        }, delay);\n    },\n    /**\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onGetSnippetVersions: function (ev) {\n        const snippet = this.el.querySelector(`.oe_snippet > [data-snippet=\"${ev.data.snippetName}\"]`);\n        ev.data.onSuccess(snippet && {\n            vcss: snippet.dataset.vcss,\n            vjs: snippet.dataset.vjs,\n            vxml: snippet.dataset.vxml,\n        });\n    },\n    /**\n     * UNUSED: used to be called when saving a custom snippet. We now save and\n     * reload the page when saving a custom snippet so that all the DOM cleanup\n     * mechanisms are run before saving. Kept for compatibility.\n     *\n     * TODO: remove in master / find a way to clean the DOM without save+reload\n     *\n     * @private\n     */\n    _onReloadSnippetTemplate: async function (ev) {\n        await this._activateSnippet(false);\n        await this._loadSnippetsTemplates(true);\n    },\n    /**\n     * @private\n     */\n    _onBlockPreviewOverlays: function (ev) {\n        this._blockPreviewOverlays = true;\n    },\n    /**\n     * @private\n     */\n    _onUnblockPreviewOverlays: function (ev) {\n        this._blockPreviewOverlays = false;\n    },\n    /**\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onRemoveSnippet: async function (ev) {\n        ev.stopPropagation();\n        const editor = await this._createSnippetEditor(ev.data.$snippet);\n        await editor.removeSnippet(ev.data.shouldRecordUndo);\n        if (ev.data.onSuccess) {\n            ev.data.onSuccess();\n        }\n    },\n    /**\n     * Saving will destroy all editors since they need to clean their DOM.\n     * This has thus to be done when they are all finished doing their work.\n     *\n     * @private\n     */\n    _onSaveRequest: function (ev) {\n        const data = ev.data || {};\n        if (ev.target === this && !data._toMutex) {\n            return;\n        }\n        delete data._toMutex;\n        ev.stopPropagation();\n        this._buttonClick(async (after) => {\n            await this.postSnippetDropPromise;\n            return this._execWithLoadingEffect(async () => {\n                const oldOnFailure = data.onFailure;\n                data.onFailure = () => {\n                    if (oldOnFailure) {\n                        oldOnFailure();\n                    }\n                    after();\n                };\n                this.trigger_up('request_save', data);\n            }, true);\n        }, this.$el[0].querySelector('button[data-action=save]'));\n    },\n    /**\n     * @private\n     */\n    _onSnippetClick() {\n        const $els = this.getEditableArea().find('.oe_structure.oe_empty').addBack('.oe_structure.oe_empty');\n        for (const el of $els) {\n            if (!el.children.length) {\n                $(el).odooBounce('o_we_snippet_area_animation');\n            }\n        }\n    },\n    /**\n     * @private\n     * @param {OdooEvent} ev\n     * @param {Object} ev.data\n     * @param {function} ev.data.exec\n     */\n    _onSnippetEditionRequest: function (ev) {\n        this._execWithLoadingEffect(ev.data.exec, true);\n    },\n    /**\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onSnippetEditorDestroyed(ev) {\n        ev.stopPropagation();\n        const index = this.snippetEditors.indexOf(ev.target);\n        this.snippetEditors.splice(index, 1);\n    },\n    /**\n     * @private\n     */\n    _onSnippetCloned: function (ev) {\n        this._updateInvisibleDOM();\n    },\n    /**\n     * Called when a snippet is removed -> checks if there is draggable snippets\n     * to enable/disable as the DOM changed.\n     *\n     * @private\n     */\n    _onSnippetRemoved: function () {\n        this._disableUndroppableSnippets();\n        this._updateInvisibleDOM();\n    },\n    /**\n     * When the editor panel receives a notification indicating that an option\n     * was used, the panel is in charge of asking for an UI update of the whole\n     * panel. Logically, the options are displayed so that an option above\n     * may influence the status and visibility of an option which is below;\n     * e.g.:\n     * - the user sets a badge type to 'info'\n     *      -> the badge background option (below) is shown as blue\n     * - the user adds a shadow\n     *      -> more options are shown afterwards to control it (not above)\n     *\n     * Technically we however update the whole editor panel (parent and child\n     * options) wherever the updates comes from. The only important thing is\n     * to first update the options UI then their visibility as their visibility\n     * may depend on their UI status.\n     *\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onSnippetOptionUpdate(ev) {\n        ev.stopPropagation();\n        (async () => {\n            // Only update editors whose DOM target is still inside the document\n            // as a top option may have removed currently-enabled child items.\n            const editors = this._enabledEditorHierarchy.filter(editor => !!editor.$target[0].closest('body'));\n\n            await Promise.all(editors.map(editor => editor.updateOptionsUI()));\n            await Promise.all(editors.map(editor => editor.updateOptionsUIVisibility()));\n\n            // Always enable the deepest editor whose DOM target is still inside\n            // the document.\n            if (editors[0] !== this._enabledEditorHierarchy[0]) {\n                // No awaiting this as the mutex is currently locked here.\n                this._activateSnippet(editors[0].$target);\n            }\n\n            ev.data.onSuccess();\n        })();\n    },\n    /**\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onSnippetOptionVisibilityUpdate: async function (ev) {\n        if (this.options.wysiwyg.isSaving()) {\n            // Do not update the option visibilities if we are destroying them.\n            return;\n        }\n        if (!ev.data.show) {\n            await this._activateSnippet(false);\n        }\n        await this._updateInvisibleDOM(); // Re-render to update status\n    },\n    /**\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onSnippetThumbnailURLRequest(ev) {\n        const $snippet = this.$snippets.has(`[data-snippet=\"${ev.data.key}\"]`);\n        ev.data.onSuccess($snippet.length ? $snippet[0].dataset.oeThumbnail : '');\n    },\n    /**\n     * Called when an user value widget is being opened -> close all the other\n     * user value widgets of all editors + add backdrop.\n     */\n    _onUserValueWidgetOpening: function () {\n        this._closeWidgets();\n        this.el.classList.add('o_we_backdrop');\n    },\n    /**\n     * Called when an user value widget is being closed -> rely on the fact only\n     * one widget can be opened at a time: remove the backdrop.\n     */\n    _onUserValueWidgetClosing: function () {\n        this.el.classList.remove('o_we_backdrop');\n    },\n    /**\n     * Called when search input value changed -> adapts the snippets grid.\n     *\n     * @private\n     */\n    _onSnippetSearchInput: function () {\n        this._filterSnippets();\n    },\n    /**\n     * Called on snippet search filter reset -> clear input field search.\n     *\n     * @private\n     */\n    _onSnippetSearchResetClick: function () {\n        this._filterSnippets('');\n    },\n    /**\n     * Called when a child editor asks to update the \"Invisible Elements\" panel.\n     *\n     * @private\n     */\n    async _onUpdateInvisibleDom() {\n        await this._updateInvisibleDOM();\n    },\n    _addToolbar(toolbarMode = \"text\") {\n        if (this.folded) {\n            return;\n        }\n        let titleText = _t(\"Inline Text\");\n        switch (toolbarMode) {\n            case \"image\":\n                titleText = _t(\"Image Formatting\");\n                break;\n            case \"video\":\n                titleText = _t(\"Video Formatting\");\n                break;\n            case \"picto\":\n                titleText = _t(\"Icon Formatting\");\n                break;\n        }\n        // Create toolbar custom container.\n        this._$toolbarContainer = $('<WE-CUSTOMIZEBLOCK-OPTIONS id=\"o_we_editor_toolbar_container\"/>');\n        const $title = $(\"<we-title><span>\" + titleText + \"</span></we-title>\");\n        this._$toolbarContainer.append($title);\n        // In case, the snippetEditor is inside an iframe, rebind the dropdown\n        // from the iframe.\n        for (const dropdown of this._toolbarWrapperEl.querySelectorAll('.colorpicker-group')) {\n            const $ = dropdown.ownerDocument.defaultView.$;\n            const $dropdown = $(dropdown);\n            $dropdown.off('show.bs.dropdown');\n            $dropdown.on('show.bs.dropdown', () => {\n                this.options.wysiwyg.onColorpaletteDropdownShow(dropdown.dataset.colorType);\n            });\n            $dropdown.off('hide.bs.dropdown');\n            $dropdown.on('hide.bs.dropdown', (ev) => this.options.wysiwyg.onColorpaletteDropdownHide(ev));\n        }\n        this._$toolbarContainer.append(this._toolbarWrapperEl);\n        $(this.customizePanel).append(this._$toolbarContainer);\n\n        // Create table-options custom container.\n        const customizeTableBlock = renderToElement('web_editor.toolbar.table-options');\n        this.options.wysiwyg.odooEditor.bindExecCommand(customizeTableBlock);\n        $(this.customizePanel).append(customizeTableBlock);\n        this._removeFormatButton = this._removeFormatButton || this._toolbarWrapperEl.querySelector('#removeFormat');\n        $title.append(this._removeFormatButton);\n        this._$toolbarContainer.append(this._toolbarWrapperEl);\n\n        this._checkEditorToolbarVisibility();\n    },\n    /**\n     * Update editor UI visibility based on the current range.\n     */\n    _checkEditorToolbarVisibility: function (e) {\n        const $toolbarContainer = this.$('#o_we_editor_toolbar_container');\n        const $toolbarTableContainer = this.$('#o-we-editor-table-container');\n        const selection = this.options.wysiwyg.odooEditor.document.getSelection();\n        const range = selection && selection.rangeCount && selection.getRangeAt(0);\n        const $currentSelectionTarget = $(range && range.commonAncestorContainer);\n        // Do not  toggle visibility if the target is inside the toolbar ( eg.\n        // during link edition).\n        if ($currentSelectionTarget.closest('#o_we_editor_toolbar_container').length ||\n            (e && $(e.target).closest('#o_we_editor_toolbar_container').length)\n        ) {\n            return;\n        }\n        if (!range ||\n            !$currentSelectionTarget.parents('#wrapwrap, .iframe-editor-wrapper').length ||\n            closestElement(selection.anchorNode, '[data-oe-model]:not([data-oe-type=\"html\"]):not([data-oe-field=\"arch\"]):not([data-oe-translation-initial-sha])') ||\n            closestElement(selection.focusNode, '[data-oe-model]:not([data-oe-type=\"html\"]):not([data-oe-field=\"arch\"]):not([data-oe-translation-initial-sha])') ||\n            (e && $(e.target).closest('.fa, img').length ||\n            this.options.wysiwyg.lastMediaClicked && $(this.options.wysiwyg.lastMediaClicked).is('.fa, img')) ||\n            (this.options.wysiwyg.lastElement && !this.options.wysiwyg.lastElement.isContentEditable)\n        ) {\n            $toolbarContainer.hide();\n        } else {\n            $toolbarContainer.show();\n        }\n\n        const isInsideTD = !!(\n            range &&\n            $(range.startContainer).closest('.o_editable td').length &&\n            $(range.endContainer).closest('.o_editable td').length\n        );\n        $toolbarTableContainer.toggleClass('d-none', !isInsideTD);\n    },\n    /**\n     * On click on discard button.\n     */\n    _onDiscardClick: function () {\n        this._buttonClick(after => {\n            this.snippetEditors.forEach(editor => {\n                editor.toggleOverlay(false);\n            });\n            this.trigger_up('request_cancel', {onReject: after});\n        }, this.$el[0].querySelector('button[data-action=cancel]'), false);\n    },\n    /**\n     * Preview on mobile.\n     */\n    _onMobilePreviewClick() {\n        // TODO refactor things to make this more understandable -> on mobile\n        // edition, update the UI. But to do it properly and inside the mutex\n        // this simulates what happens when a snippet option is used.\n        this._execWithLoadingEffect(async () => {\n            const initialBodySize = this.$body[0].clientWidth;\n            this.trigger_up('request_mobile_preview');\n\n            // TODO needed so that mobile edition is considered before updating\n            // the UI but this is clearly random. The trigger_up above should\n            // properly await for the rerender somehow or, better, the UI update\n            // should not depend on the mobile re-render entirely.\n            let count = 0;\n            do {\n                await new Promise(resolve => setTimeout(resolve, 1));\n            // Technically, should not be possible to fall into an infinite loop\n            // but extra safety as a stable fix.\n            } while (count++ < 1000 && Math.abs(this.$body[0].clientWidth - initialBodySize) < 1);\n\n            // Reload images inside grid items so that no image disappears when\n            // activating mobile preview.\n            const $gridItemEls = this.getEditableArea().find('div.o_grid_item');\n            for (const gridItemEl of $gridItemEls) {\n                gridUtils._reloadLazyImages(gridItemEl);\n            }\n\n            const isMobilePreview = weUtils.isMobileView(this.$body[0]);\n            for (const invisibleOverrideEl of this.getEditableArea().find('.o_snippet_mobile_invisible, .o_snippet_desktop_invisible')) {\n                const isMobileHidden = invisibleOverrideEl.classList.contains(\"o_snippet_mobile_invisible\");\n                invisibleOverrideEl.classList.remove('o_snippet_override_invisible');\n                if (isMobilePreview === isMobileHidden) {\n                    invisibleOverrideEl.dataset.invisible = '1';\n                } else {\n                    delete invisibleOverrideEl.dataset.invisible;\n                }\n            }\n\n            // This is async but using the main editor mutex, currently locked.\n            this._updateInvisibleDOM();\n\n            // Updating options upon changing preview mode to avoid ghost overlay\n            const enabledInvisibleOverrideEl = this.options.wysiwyg.lastElement &&\n                this.options.wysiwyg.lastElement.closest(\".o_snippet_mobile_invisible, .o_snippet_desktop_invisible\");\n            const needDeactivate = enabledInvisibleOverrideEl && enabledInvisibleOverrideEl.dataset.invisible === \"1\";\n\n            return new Promise(resolve => {\n                // No need to trigger \"snippet_option_update\" when snippet is deactivated.\n                if (needDeactivate) {\n                    this._activateSnippet(false);\n                    resolve();\n                } else {\n                    this.trigger_up(\"snippet_option_update\", {\n                        onSuccess: () => resolve(),\n                    });\n                }\n            });\n        }, false);\n    },\n    /**\n     * Undo..\n     */\n    _onUndo: async function () {\n        this.options.wysiwyg.undo();\n    },\n    /**\n     * Redo.\n     */\n    _onRedo: async function () {\n        this.options.wysiwyg.redo();\n    },\n    /**\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onRequestEditable: function (ev) {\n        ev.data.callback($(this.options.wysiwyg.odooEditor.editable));\n    },\n    /**\n     * Enable loading effects\n     *\n     * @private\n     */\n    _onEnableLoadingEffect: function () {\n        this._loadingEffectDisabled = false;\n    },\n    /**\n     * Disable loading effects and cancel the one displayed\n     *\n     * @private\n     */\n    _onDisableLoadingEffect: function () {\n        this._loadingEffectDisabled = true;\n        Object.keys(this.loadingElements).forEach(key => {\n            if (this.loadingElements[key]) {\n                this.loadingElements[key].remove();\n                this.loadingElements[key] = null;\n            }\n        });\n    },\n    /***\n     * Display a loading effect on the clicked button, and disables the other\n     * buttons. Passes an argument to restore the buttons to their normal\n     * state to the function to execute.\n     *\n     * @param action {Function} The action to execute\n     * @param button {HTMLElement} The button element\n     * @param addLoadingEffect {boolean} whether or not to add a loading effect.\n     * @returns {Promise<void>}\n     * @private\n     */\n    async _buttonClick(action, button, addLoadingEffect = true) {\n        if (this._buttonAction) {\n            return;\n        }\n        this._buttonAction = true;\n        let removeLoadingEffect;\n        // Remove the tooltips now, because the button will be disabled and so,\n        // the tooltip will not be removable (see BS doc).\n        this._hideTooltips();\n        if (addLoadingEffect) {\n            removeLoadingEffect = dom.addButtonLoadingEffect(button);\n        }\n        const actionButtons = this.$el[0].querySelectorAll('[data-action]');\n        for (const actionButton of actionButtons) {\n            actionButton.disabled = true;\n        }\n        const after = () => {\n            if (removeLoadingEffect) {\n                removeLoadingEffect();\n            }\n            for (const actionButton of actionButtons) {\n                actionButton.disabled = false;\n            }\n        };\n        await action(after);\n        this._buttonAction = false;\n    },\n});\n\nexport default {\n    SnippetsMenu: SnippetsMenu,\n    SnippetEditor: SnippetEditor,\n    globalSelector: globalSelector,\n};\n", "/** @odoo-module **/\n\nimport { attachComponent } from \"@web/legacy/utils\";\nimport { MediaDialog } from \"@web_editor/components/media_dialog/media_dialog\";\nimport { ConfirmationDialog } from \"@web/core/confirmation_dialog/confirmation_dialog\";\nimport dom from \"@web/legacy/js/core/dom\";\nimport { throttleForAnimation, debounce } from \"@web/core/utils/timing\";\nimport { clamp } from \"@web/core/utils/numbers\";\nimport Widget from \"@web/legacy/js/core/widget\";\nimport { ColorPalette } from \"@web_editor/js/wysiwyg/widgets/color_palette\";\nimport weUtils from \"@web_editor/js/common/utils\";\nimport * as gridUtils from \"@web_editor/js/common/grid_layout_utils\";\nimport {ColumnLayoutMixin} from \"@web_editor/js/common/column_layout_mixin\";\nconst {\n    normalizeColor,\n    getBgImageURL,\n    backgroundImageCssToParts,\n    backgroundImagePartsToCss,\n    DEFAULT_PALETTE,\n    isBackgroundImageAttribute,\n} = weUtils;\nimport { ImageCrop } from '@web_editor/js/wysiwyg/widgets/image_crop';\nimport {\n    loadImage,\n    loadImageInfo,\n    applyModifications,\n    removeOnImageChangeAttrs,\n    isImageSupportedForProcessing,\n    isImageSupportedForStyle,\n    createDataURL,\n    isGif,\n    getDataURLBinarySize,\n} from \"@web_editor/js/editor/image_processing\";\nimport * as OdooEditorLib from \"@web_editor/js/editor/odoo-editor/src/OdooEditor\";\nimport { pick } from \"@web/core/utils/objects\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport {\n    isCSSColor,\n    convertCSSColorToRgba,\n    normalizeCSSColor,\n } from '@web/core/utils/colors';\nimport { renderToElement } from \"@web/core/utils/render\";\nimport { jsonrpc } from \"@web/core/network/rpc_service\";\n\nconst preserveCursor = OdooEditorLib.preserveCursor;\nconst { DateTime } = luxon;\nconst resetOuids = OdooEditorLib.resetOuids;\nlet _serviceCache = {\n    orm: {},\n    rpc: {},\n};\nconst clearServiceCache = () => {\n    _serviceCache = {\n        orm: {},\n        rpc: {},\n    };\n};\n/**\n * Caches rpc/orm service\n * @param {Function} service\n * @param  {...any} args\n * @returns\n */\nfunction serviceCached(service) {\n    const cache = _serviceCache;\n    return Object.assign(Object.create(service), {\n        call() {\n            const serviceName = Object.prototype.hasOwnProperty.call(service, \"call\")\n                ? \"orm\"\n                : \"rpc\";\n            const cacheId = JSON.stringify(arguments);\n            if (!cache[serviceName][cacheId]) {\n                cache[serviceName][cacheId] =\n                    serviceName == \"rpc\" ? service(...arguments) : service.call(...arguments);\n            }\n            return cache[serviceName][cacheId];\n        },\n    });\n}\n// Outdated snippets whose alert has been discarded.\nconst controlledSnippets = new Set();\nconst clearControlledSnippets = () => controlledSnippets.clear();\n/**\n * @param {HTMLElement} el\n * @param {string} [title]\n * @param {Object} [options]\n * @param {string[]} [options.classes]\n * @param {string} [options.tooltip]\n * @param {string} [options.placeholder]\n * @param {Object} [options.dataAttributes]\n * @returns {HTMLElement} - the original 'el' argument\n */\nfunction _addTitleAndAllowedAttributes(el, title, options) {\n    let tooltipEl = el;\n    if (title) {\n        const titleEl = _buildTitleElement(title);\n        tooltipEl = titleEl;\n        el.appendChild(titleEl);\n        if (options && options.dataAttributes && options.dataAttributes.fontFamily) {\n            titleEl.style.fontFamily = options.dataAttributes.fontFamily;\n        }\n    }\n\n    if (options && options.classes) {\n        el.classList.add(...options.classes);\n    }\n    if (options && options.tooltip) {\n        tooltipEl.title = options.tooltip;\n    }\n    if (options && options.placeholder) {\n        el.setAttribute('placeholder', options.placeholder);\n    }\n    if (options && options.dataAttributes) {\n        for (const key in options.dataAttributes) {\n            el.dataset[key] = options.dataAttributes[key];\n        }\n    }\n\n    return el;\n}\n/**\n * @param {string} tagName\n * @param {string} title - @see _addTitleAndAllowedAttributes\n * @param {Object} options - @see _addTitleAndAllowedAttributes\n * @returns {HTMLElement}\n */\nfunction _buildElement(tagName, title, options) {\n    const el = document.createElement(tagName);\n    return _addTitleAndAllowedAttributes(el, title, options);\n}\n/**\n * @param {string} title\n * @returns {HTMLElement}\n */\nfunction _buildTitleElement(title) {\n    const titleEl = document.createElement('we-title');\n    titleEl.textContent = title;\n    return titleEl;\n}\n/**\n * @param {string} src\n * @returns {HTMLElement}\n */\nconst _buildImgElementCache = {};\nasync function _buildImgElement(src) {\n    if (!(src in _buildImgElementCache)) {\n        _buildImgElementCache[src] = (async () => {\n            if (src.split('.').pop() === 'svg') {\n                const response = await window.fetch(src);\n                const text = await response.text();\n                const parser = new window.DOMParser();\n                const xmlDoc = parser.parseFromString(text, 'text/xml');\n                return xmlDoc.getElementsByTagName('svg')[0];\n            } else {\n                const imgEl = document.createElement('img');\n                imgEl.src = src;\n                return imgEl;\n            }\n        })();\n    }\n    const node = await _buildImgElementCache[src];\n    return node.cloneNode(true);\n}\n/**\n * Build the correct DOM for a we-row element.\n *\n * @param {string} [title] - @see _buildElement\n * @param {Object} [options] - @see _buildElement\n * @param {HTMLElement[]} [options.childNodes]\n * @returns {HTMLElement}\n */\nfunction _buildRowElement(title, options) {\n    const groupEl = _buildElement('we-row', title, options);\n\n    const rowEl = document.createElement('div');\n    groupEl.appendChild(rowEl);\n\n    if (options && options.childNodes) {\n        options.childNodes.forEach(node => rowEl.appendChild(node));\n    }\n\n    return groupEl;\n}\n/**\n * Build the correct DOM for a we-collapse element.\n *\n * @param {string} [title] - @see _buildElement\n * @param {Object} [options] - @see _buildElement\n * @param {HTMLElement[]} [options.childNodes]\n * @returns {HTMLElement}\n */\nfunction _buildCollapseElement(title, options) {\n    const groupEl = _buildElement('we-collapse', title, options);\n    const titleEl = groupEl.querySelector('we-title');\n\n    const children = options && options.childNodes || [];\n    if (titleEl) {\n        titleEl.remove();\n        titleEl.classList.add('o_we_collapse_toggler');\n        children.unshift(titleEl);\n    }\n    let i = 0;\n    for (i = 0; i < children.length; i++) {\n        groupEl.appendChild(children[i]);\n        if (children[i].nodeType === Node.ELEMENT_NODE) {\n            break;\n        }\n    }\n\n    const togglerEl = document.createElement('we-toggler');\n    togglerEl.classList.add('o_we_collapse_toggler');\n    groupEl.appendChild(togglerEl);\n\n    const containerEl = document.createElement('div');\n    children.slice(i + 1).forEach(node => containerEl.appendChild(node));\n    groupEl.appendChild(containerEl);\n\n    return groupEl;\n}\n/**\n * Creates a proxy for an object where one property is replaced by a different\n * value. This value is captured in the closure and can be read and written to.\n *\n * @param {Object} obj - the object for which to create a proxy\n * @param {string} propertyName - the name/key of the property to replace\n * @param {*} value - the initial value to give to the property's copy\n * @returns {Proxy} a proxy of the object with the property replaced\n */\nfunction createPropertyProxy(obj, propertyName, value) {\n    return new Proxy(obj, {\n        get: function (obj, prop) {\n            if (prop === propertyName) {\n                return value;\n            }\n            return obj[prop];\n        },\n        set: function (obj, prop, val) {\n            if (prop === propertyName) {\n                return (value = val);\n            }\n            return Reflect.set(...arguments);\n        },\n    });\n}\n/**\n * Creates and registers a UserValueWidget by tag-name\n *\n * @param {string} widgetName\n * @param {SnippetOptionWidget|UserValueWidget|null} parent\n * @param {string} title\n * @param {Object} options\n * @returns {UserValueWidget}\n */\nfunction registerUserValueWidget(widgetName, parent, title, options, $target) {\n    const widget = new userValueWidgetsRegistry[widgetName](parent, title, options, $target);\n    parent.registerSubWidget(widget);\n    return widget;\n}\n\n//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n\nconst NULL_ID = '__NULL__';\n\n/**\n * Base class for components to be used in snippet options widgets to retrieve\n * user values.\n */\nconst UserValueWidget = Widget.extend({\n    className: 'o_we_user_value_widget',\n    custom_events: {\n        'user_value_update': '_onUserValueNotification',\n    },\n\n    /**\n     * @constructor\n     */\n    init: function (parent, title, options, $target) {\n        this._super(...arguments);\n        this.title = title;\n        this.options = options;\n        this._userValueWidgets = [];\n        this._value = '';\n        this.$target = $target;\n    },\n    /**\n     * @override\n     */\n    async willStart() {\n        await this._super(...arguments);\n        if (this.options.dataAttributes.img) {\n            this.illustrationEl = await _buildImgElement(this.options.dataAttributes.img);\n        } else if (this.options.dataAttributes.icon) {\n            this.illustrationEl = document.createElement('i');\n            this.illustrationEl.classList.add('fa', this.options.dataAttributes.icon);\n        }\n        if (this.options.dataAttributes.reload) {\n            this.options.dataAttributes.noPreview = \"true\";\n        }\n    },\n    /**\n     * @override\n     */\n    _makeDescriptive: function () {\n        const $el = this._super(...arguments);\n        const el = $el[0];\n        _addTitleAndAllowedAttributes(el, this.title, this.options);\n        this.containerEl = document.createElement('div');\n\n        if (this.illustrationEl) {\n            this.containerEl.appendChild(this.illustrationEl);\n        }\n\n        el.appendChild(this.containerEl);\n        return $el;\n    },\n    /**\n     * @override\n     */\n    async start() {\n        await this._super(...arguments);\n\n        if (this.el.classList.contains('o_we_img_animate')) {\n            const buildImgExtensionSwitcher = (from, to) => {\n                const regex = new RegExp(`${from}$`, 'i');\n                return ev => {\n                    const img = ev.currentTarget.getElementsByTagName(\"img\")[0];\n                    img.src = img.src.replace(regex, to);\n                };\n            };\n            this.$el.on('mouseenter.img_animate', buildImgExtensionSwitcher('png', 'gif'));\n            this.$el.on('mouseleave.img_animate', buildImgExtensionSwitcher('gif', 'png'));\n        }\n    },\n    /**\n     * @override\n     */\n    destroy() {\n        // Check if $el exists in case the widget is destroyed before it has\n        // been fully initialized.\n        // TODO there is probably better to do. This case was found only in\n        // tours, where the editor is left before the widget icon is loaded.\n        if (this.$el) {\n            this.$el.off('.img_animate');\n        }\n        this._super(...arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * Closes the widget (only meaningful for widgets that can be closed).\n     */\n    close: function () {\n        if (!this.el) {\n            // In case the method is called while the widget is not fully\n            // initialized yet. No need to prevent that case: asking a non\n            // initialized widget to close itself should just not be a problem\n            // and just be ignored.\n            return;\n        }\n        if (!this.el.classList.contains('o_we_widget_opened')) {\n            // Small optimization: it would normally not matter asking to\n            // remove a class of an element if it does not already have it but\n            // in this case we do more: we trigger_up an event and ask to close\n            // all sub widgets. When we ask the editor to close all widgets...\n            // it makes sense not letting every sub button of every select\n            // trigger_up an event. This allows to avoid tens of thousands of\n            // instructions being done at each click in the editor.\n            return;\n        }\n        this.trigger_up('user_value_widget_closing');\n        this.el.classList.remove('o_we_widget_opened');\n        this._userValueWidgets.forEach(widget => widget.close());\n    },\n    /**\n     * Simulates the correct event on the element to make it active.\n     */\n    enable() {\n        this.$el.click();\n    },\n    /**\n     * @param {string} name\n     * @returns {UserValueWidget|null}\n     */\n    findWidget: function (name) {\n        for (const widget of this._userValueWidgets) {\n            if (widget.getName() === name) {\n                return widget;\n            }\n            const depWidget = widget.findWidget(name);\n            if (depWidget) {\n                return depWidget;\n            }\n        }\n        return null;\n    },\n    /**\n     * Focus the main focusable element of the widget.\n     */\n    focus() {\n        const el = this._getFocusableElement();\n        if (el) {\n            el.focus();\n        }\n    },\n    /**\n     * Returns the value that the widget would hold if it was active, by default\n     * the internal value it holds.\n     *\n     * @param {string} [methodName]\n     * @returns {string}\n     */\n    getActiveValue: function (methodName) {\n        return this._value;\n    },\n    /**\n     * Returns the default value the widget holds when inactive, by default the\n     * first \"possible value\".\n     *\n     * @param {string} [methodName]\n     * @returns {string}\n     */\n    getDefaultValue: function (methodName) {\n        const possibleValues = this._methodsParams.optionsPossibleValues[methodName];\n        return possibleValues && possibleValues[0] || '';\n    },\n    /**\n     * @returns {string[]}\n     */\n    getDependencies: function () {\n        return this._dependencies;\n    },\n    /**\n     * Returns the names of the option methods associated to the widget. Those\n     * are loaded with @see loadMethodsData.\n     *\n     * @returns {string[]}\n     */\n    getMethodsNames: function () {\n        return this._methodsNames;\n    },\n    /**\n     * Returns the option parameters associated to the widget (for a given\n     * method name or not). Most are loaded with @see loadMethodsData.\n     *\n     * @param {string} [methodName]\n     * @returns {Object}\n     */\n    getMethodsParams: function (methodName) {\n        const params = Object.assign({}, this._methodsParams);\n        if (methodName) {\n            params.possibleValues = params.optionsPossibleValues[methodName] || [];\n            params.activeValue = this.getActiveValue(methodName);\n            params.defaultValue = this.getDefaultValue(methodName);\n        }\n        return params;\n    },\n    /**\n     * @returns {string} empty string if no name is used by the widget\n     */\n    getName: function () {\n        return this._methodsParams.name || '';\n    },\n    /**\n     * Returns the user value that the widget currently holds. The value is a\n     * string, this is the value that will be received in the option methods\n     * of SnippetOptionWidget instances.\n     *\n     * @param {string} [methodName]\n     * @returns {string}\n     */\n    getValue: function (methodName) {\n        const isActive = this.isActive();\n        if (!methodName || !this._methodsNames.includes(methodName)) {\n            return isActive ? 'true' : '';\n        }\n        if (isActive) {\n            return this.getActiveValue(methodName);\n        }\n        return this.getDefaultValue(methodName);\n    },\n    /**\n     * Returns whether or not the widget is active (holds a value).\n     *\n     * @returns {boolean}\n     */\n    isActive: function () {\n        return this._value && this._value !== NULL_ID;\n    },\n    /**\n     * Indicates if the widget can contain sub user value widgets or not.\n     *\n     * @returns {boolean}\n     */\n    isContainer: function () {\n        return false;\n    },\n    /**\n     * Indicates if the widget is being previewed or not: the user is\n     * manipulating it. Base case: if an internal <input/> element is focused.\n     *\n     * @returns {boolean}\n     */\n    isPreviewed: function () {\n        const focusEl = document.activeElement;\n        if (focusEl && focusEl.tagName === 'INPUT'\n                && (this.el === focusEl || this.el.contains(focusEl))) {\n            return true;\n        }\n        return this.el.classList.contains('o_we_preview');\n    },\n    /**\n     * Loads option method names and option method parameters.\n     *\n     * @param {string[]} validMethodNames\n     * @param {Object} extraParams\n     */\n    loadMethodsData: function (validMethodNames, extraParams) {\n        this._methodsNames = [];\n        this._methodsParams = Object.assign({}, extraParams);\n        this._methodsParams.optionsPossibleValues = {};\n        this._dependencies = [];\n        this._triggerWidgetsNames = [];\n        this._triggerWidgetsValues = [];\n\n        for (const key in this.el.dataset) {\n            const dataValue = this.el.dataset[key].trim();\n\n            if (key === 'dependencies') {\n                this._dependencies.push(...dataValue.split(/\\s*,\\s*/g));\n            } else if (key === 'trigger') {\n                this._triggerWidgetsNames.push(...dataValue.split(/\\s*,\\s*/g));\n            } else if (key === 'triggerValue') {\n                this._triggerWidgetsValues.push(...dataValue.split(/\\s*,\\s*/g));\n            } else if (validMethodNames.includes(key)) {\n                this._methodsNames.push(key);\n                this._methodsParams.optionsPossibleValues[key] = dataValue.split(/\\s*\\|\\s*/g);\n            } else {\n                this._methodsParams[key] = dataValue;\n            }\n        }\n        this._userValueWidgets.forEach(widget => {\n            const inheritedParams = Object.assign({}, this._methodsParams);\n            inheritedParams.optionsPossibleValues = null;\n            widget.loadMethodsData(validMethodNames, inheritedParams);\n            const subMethodsNames = widget.getMethodsNames();\n            const subMethodsParams = widget.getMethodsParams();\n\n            for (const methodName of subMethodsNames) {\n                if (!this._methodsNames.includes(methodName)) {\n                    this._methodsNames.push(methodName);\n                    this._methodsParams.optionsPossibleValues[methodName] = [];\n                }\n                for (const subPossibleValue of subMethodsParams.optionsPossibleValues[methodName]) {\n                    this._methodsParams.optionsPossibleValues[methodName].push(subPossibleValue);\n                }\n            }\n        });\n        for (const methodName of this._methodsNames) {\n            const arr = this._methodsParams.optionsPossibleValues[methodName];\n            const uniqArr = arr.filter((v, i, arr) => i === arr.indexOf(v));\n            this._methodsParams.optionsPossibleValues[methodName] = uniqArr;\n        }\n\n        // Method names come from the widget's dataset whose keys' order cannot\n        // be relied on. We explicitely sort them by alphabetical order allowing\n        // consistent behavior, while relying on order for such methods should\n        // not be done when possible (the methods should be independent from\n        // each other when possible).\n        this._methodsNames.sort();\n    },\n    /**\n     * @param {boolean} [previewMode=false]\n     * @param {boolean} [isSimulatedEvent=false]\n     */\n    notifyValueChange: function (previewMode, isSimulatedEvent) {\n        // In the case we notify a change update, force a preview update if it\n        // was not already previewed\n        const isPreviewed = this.isPreviewed();\n        if (!previewMode && !isPreviewed) {\n            this.notifyValueChange(true);\n        }\n\n        const data = {\n            previewMode: previewMode || false,\n            isSimulatedEvent: !!isSimulatedEvent,\n        };\n        // TODO improve this. The preview state has to be updated only when the\n        // actual option _select is gonna be called... but this is delayed by a\n        // mutex. So, during test tours, we would notify both 'preview' and\n        // 'reset' before the 'preview' handling is done: and so the widget\n        // would not be considered in preview during that 'preview' handling.\n        if (previewMode === true || previewMode === false) {\n            // Note: the widgets need to be considered in preview mode during\n            // non-preview handling (a previewed checkbox is considered having\n            // an inverted state)... but if, for example, a modal opens before\n            // handling that non-preview, a 'reset' will be thrown thus removing\n            // the preview class. So we force it in non-preview too.\n            data.prepare = () => this.el.classList.add('o_we_preview');\n        } else if (previewMode === 'reset') {\n            data.prepare = () => this.el.classList.remove('o_we_preview');\n        }\n\n        this.trigger_up('user_value_update', data);\n    },\n    /**\n     * Opens the widget (only meaningful for widgets that can be opened).\n     */\n    open() {\n        this.trigger_up('user_value_widget_opening');\n        this.el.classList.add('o_we_widget_opened');\n    },\n    /**\n     * Adds the given widget to the known list of user value sub-widgets (useful\n     * for container widgets).\n     *\n     * @param {UserValueWidget} widget\n     */\n    registerSubWidget: function (widget) {\n        this._userValueWidgets.push(widget);\n    },\n    /**\n     * Sets the user value that the widget should currently hold, for the\n     * given method name.\n     *\n     * Note: a widget typically only holds one value for the only method it\n     * supports. However, widgets can have several methods; in that case, the\n     * value is typically received for a first method and receiving the value\n     * for other ones should not affect the widget (otherwise, it means the\n     * methods are conflicting with each other).\n     *\n     * @param {string} value\n     * @param {string} [methodName]\n     */\n    async setValue(value, methodName) {\n        this._value = value;\n        this.el.classList.remove('o_we_preview');\n    },\n    /**\n     * @param {boolean} show\n     */\n    toggleVisibility: function (show) {\n        let doFocus = false;\n        if (show) {\n            const wasInvisible = this.el.classList.contains('d-none');\n            doFocus = wasInvisible && this.el.dataset.requestFocus === \"true\";\n        }\n        this.el.classList.toggle('d-none', !show);\n        if (doFocus) {\n            this.focus();\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Returns the main focusable element of the widget. By default supposes\n     * nothing is focusable.\n     *\n     * @todo review all specific widget's method\n     * @private\n     * @returns {HTMLElement}\n     */\n    _getFocusableElement: function () {\n        return null;\n    },\n    /**\n     * @private\n     * @param {OdooEvent|Event}\n     * @returns {boolean}\n     */\n    _handleNotifierEvent: function (ev) {\n        if (!ev) {\n            return true;\n        }\n        if (ev._seen) {\n            return false;\n        }\n        ev._seen = true;\n        if (ev.preventDefault) {\n            ev.preventDefault();\n        }\n        return true;\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Should be called when an user event on the widget indicates a value\n     * change.\n     *\n     * @private\n     * @param {OdooEvent|Event} [ev]\n     */\n    _onUserValueChange: function (ev) {\n        if (this._handleNotifierEvent(ev)) {\n            this.notifyValueChange(false);\n        }\n    },\n    /**\n     * Allows container widgets to add additional data if needed.\n     *\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onUserValueNotification: function (ev) {\n        ev.data.widget = this;\n\n        if (!ev.data.triggerWidgetsNames) {\n            ev.data.triggerWidgetsNames = [];\n        }\n        ev.data.triggerWidgetsNames.push(...this._triggerWidgetsNames);\n\n        if (!ev.data.triggerWidgetsValues) {\n            ev.data.triggerWidgetsValues = [];\n        }\n        ev.data.triggerWidgetsValues.push(...this._triggerWidgetsValues);\n    },\n    /**\n     * Should be called when an user event on the widget indicates a value\n     * preview.\n     *\n     * @private\n     * @param {OdooEvent|Event} [ev]\n     */\n    _onUserValuePreview: function (ev) {\n        if (this._handleNotifierEvent(ev)) {\n            this.notifyValueChange(true);\n        }\n    },\n    /**\n     * Should be called when an user event on the widget indicates a value\n     * reset.\n     *\n     * @private\n     * @param {OdooEvent|Event} [ev]\n     */\n    _onUserValueReset: function (ev) {\n        if (this._handleNotifierEvent(ev)) {\n            this.notifyValueChange('reset');\n        }\n    },\n});\n\nconst ButtonUserValueWidget = UserValueWidget.extend({\n    tagName: 'we-button',\n    events: {\n        'click': '_onButtonClick',\n        'click [role=\"button\"]': '_onInnerButtonClick',\n        'mouseenter': '_onUserValuePreview',\n        'mouseleave': '_onUserValueReset',\n    },\n\n    /**\n     * @override\n     */\n    async willStart() {\n        await this._super(...arguments);\n        if (this.options.dataAttributes.activeImg) {\n            this.activeImgEl = await _buildImgElement(this.options.dataAttributes.activeImg);\n        }\n    },\n    /**\n     * @override\n     */\n    _makeDescriptive() {\n        const $el = this._super(...arguments);\n        if (this.illustrationEl) {\n            $el[0].classList.add('o_we_icon_button');\n        }\n        if (this.activeImgEl) {\n            this.containerEl.appendChild(this.activeImgEl);\n        }\n        return $el;\n    },\n    /**\n     * @override\n     */\n    start: function (parent, title, options) {\n        if (this.options && this.options.childNodes) {\n            this.options.childNodes.forEach(node => this.containerEl.appendChild(node));\n        }\n\n        return this._super(...arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    getActiveValue: function (methodName) {\n        const possibleValues = this._methodsParams.optionsPossibleValues[methodName];\n        return possibleValues && possibleValues[possibleValues.length - 1] || '';\n    },\n    /**\n     * @override\n     */\n    isActive: function () {\n        return (this.isPreviewed() !== this.el.classList.contains('active'));\n    },\n    /**\n     * @override\n     */\n    loadMethodsData: function (validMethodNames) {\n        this._super.apply(this, arguments);\n        for (const methodName of this._methodsNames) {\n            const possibleValues = this._methodsParams.optionsPossibleValues[methodName];\n            if (possibleValues.length <= 1) {\n                possibleValues.unshift('');\n            }\n        }\n    },\n    /**\n     * @override\n     */\n    async setValue(value, methodName) {\n        await this._super(...arguments);\n        let active = !!value;\n        if (methodName) {\n            if (!this._methodsNames.includes(methodName)) {\n                return;\n            }\n            active = (this.getActiveValue(methodName) === value);\n        }\n        if (this.illustrationEl && this.activeImgEl) {\n            this.illustrationEl.classList.toggle('d-none', active);\n            this.activeImgEl.classList.toggle('d-none', !active);\n        }\n        this.el.classList.toggle('active', active);\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * @private\n     */\n    _onButtonClick: function (ev) {\n        if (!ev._innerButtonClicked) {\n            this._onUserValueChange(ev);\n        }\n    },\n    /**\n     * @private\n     */\n    _onInnerButtonClick: function (ev) {\n        // Cannot just stop propagation as the click needs to be propagated to\n        // potential parent widgets for event delegation on those inner buttons.\n        ev._innerButtonClicked = true;\n    },\n});\n\nconst CheckboxUserValueWidget = ButtonUserValueWidget.extend({\n    className: (ButtonUserValueWidget.prototype.className || '') + ' o_we_checkbox_wrapper',\n\n    /**\n     * @override\n     */\n    start: function () {\n        const checkboxEl = document.createElement('we-checkbox');\n        this.containerEl.appendChild(checkboxEl);\n\n        return this._super(...arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    enable() {\n        this.$('we-checkbox').click();\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _onButtonClick(ev) {\n        if (!ev.target.closest('we-title, we-checkbox')) {\n            // Only consider clicks on the label and the checkbox control itself\n            return;\n        }\n        return this._super(...arguments);\n    },\n});\n\nconst BaseSelectionUserValueWidget = UserValueWidget.extend({\n    /**\n     * @override\n     */\n    async start() {\n        await this._super(...arguments);\n\n        this.menuEl = document.createElement('we-selection-items');\n        if (this.options && this.options.childNodes) {\n            this.options.childNodes.forEach(node => {\n                // Ensure to only put element nodes inside the selection menu\n                // as there could be an :empty CSS rule to handle the case when\n                // the menu is empty (so it should not contain any whitespace).\n                if (node.nodeType === Node.ELEMENT_NODE) {\n                    this.menuEl.appendChild(node);\n                }\n            });\n        }\n        this.containerEl.appendChild(this.menuEl);\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    getMethodsParams(methodName) {\n        const params = this._super(...arguments);\n        const activeWidget = this._getActiveSubWidget();\n        if (!activeWidget) {\n            return params;\n        }\n        return Object.assign(activeWidget.getMethodsParams(...arguments), params);\n    },\n    /**\n     * @override\n     */\n    getValue(methodName) {\n        const activeWidget = this._getActiveSubWidget();\n        if (activeWidget) {\n            return activeWidget.getActiveValue(methodName);\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    isContainer() {\n        return true;\n    },\n    /**\n     * @override\n     */\n    async setValue(value, methodName) {\n        const _super = this._super.bind(this);\n        for (const widget of this._userValueWidgets) {\n            await widget.setValue(NULL_ID, methodName);\n        }\n        for (const widget of [...this._userValueWidgets].reverse()) {\n            await widget.setValue(value, methodName);\n            if (widget.isActive()) {\n                // Only one select item can be true at a time, we consider the\n                // last one if multiple would be active.\n                break;\n            }\n        }\n        await _super(...arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @private\n     * @returns {UserValueWidget|undefined}\n     */\n    _getActiveSubWidget() {\n        const previewedWidget = this._userValueWidgets.find(widget => widget.isPreviewed());\n        if (previewedWidget) {\n            return previewedWidget;\n        }\n        return this._userValueWidgets.find(widget => widget.isActive());\n    },\n});\n\nconst SelectUserValueWidget = BaseSelectionUserValueWidget.extend({\n    tagName: 'we-select',\n    events: {\n        'click': '_onClick',\n    },\n    PLACEHOLDER_TEXT: _t(\"None\"),\n\n    /**\n     * @override\n     */\n    async start() {\n        await this._super(...arguments);\n\n        if (this.options && this.options.valueEl) {\n            this.containerEl.insertBefore(this.options.valueEl, this.menuEl);\n        }\n\n        this.menuEl.dataset.placeholderText = this.PLACEHOLDER_TEXT;\n\n        this.menuTogglerEl = document.createElement('we-toggler');\n        this.menuTogglerEl.dataset.placeholderText = this.PLACEHOLDER_TEXT;\n        this.iconEl = this.illustrationEl || null;\n        const icon = this.el.dataset.icon;\n        if (icon) {\n            this.iconEl = document.createElement('i');\n            this.iconEl.classList.add('fa', 'fa-fw', icon);\n        }\n        if (this.iconEl) {\n            this.el.classList.add('o_we_icon_select');\n            this.menuTogglerEl.appendChild(this.iconEl);\n        }\n        this.containerEl.insertBefore(this.menuTogglerEl, this.menuEl);\n\n        const dropdownCaretEl = document.createElement('span');\n        dropdownCaretEl.classList.add('o_we_dropdown_caret');\n        this.containerEl.appendChild(dropdownCaretEl);\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    close: function () {\n        this._super(...arguments);\n        this.el.classList.remove(\"o_we_select_dropdown_up\");\n        if (this.menuTogglerEl) {\n            this.menuTogglerEl.classList.remove('active');\n        }\n    },\n    /**\n     * @override\n     */\n    isPreviewed: function () {\n        return this._super(...arguments) || this.menuTogglerEl.classList.contains('active');\n    },\n    /**\n     * @override\n     */\n    open() {\n        this._super(...arguments);\n        this.menuTogglerEl.classList.add('active');\n        this._adjustDropdownPosition();\n    },\n    /**\n     * @override\n     */\n    async setValue() {\n        await this._super(...arguments);\n\n        if (this.iconEl) {\n            return;\n        }\n\n        if (this.menuTogglerItemEl) {\n            this.menuTogglerItemEl.remove();\n            this.menuTogglerItemEl = null;\n        }\n\n        let textContent = '';\n        const activeWidget = this._userValueWidgets.find(widget => !widget.isPreviewed() && widget.isActive());\n        if (activeWidget) {\n            const svgTag = activeWidget.el.querySelector('svg'); // useful to avoid searching text content in svg element\n            const value = (activeWidget.el.dataset.selectLabel || (!svgTag && activeWidget.el.textContent.trim()));\n            const imgSrc = activeWidget.el.dataset.img;\n            const icon = activeWidget.el.dataset.icon;\n            if (value) {\n                textContent = value;\n            } else if (icon) {\n                this.menuTogglerItemEl = document.createElement('i');\n                this.menuTogglerItemEl.classList.add('fa', icon);\n            } else if (imgSrc) {\n                this.menuTogglerItemEl = document.createElement('img');\n                this.menuTogglerItemEl.src = imgSrc;\n            } else {\n                const fakeImgEl = activeWidget.el.querySelector('.o_we_fake_img_item');\n                if (fakeImgEl) {\n                    this.menuTogglerItemEl = fakeImgEl.cloneNode(true);\n                }\n            }\n        } else {\n            textContent = this.PLACEHOLDER_TEXT;\n        }\n\n        this.menuTogglerEl.textContent = textContent;\n        if (this.menuTogglerItemEl) {\n            this.menuTogglerEl.appendChild(this.menuTogglerItemEl);\n        }\n    },\n    /**\n     * @override\n     */\n    enable() {\n        if (!this.menuTogglerEl.classList.contains('active')) {\n            this.menuTogglerEl.click();\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @private\n     * @param {Event} ev\n     */\n    _shouldIgnoreClick(ev) {\n        return !!ev.target.closest('[role=\"button\"]');\n    },\n    /**\n     * Decides whether the dropdown should be positioned below or above the\n     * selector based on the available space.\n     *\n     * @private\n     */\n    _adjustDropdownPosition() {\n        const customizePanelEl = this.menuEl.closest(\".o_we_customize_panel\");\n        if (!customizePanelEl) {\n            return;\n        }\n\n        this.el.classList.remove(\"o_we_select_dropdown_up\");\n        const customizePanelElCoords = customizePanelEl.getBoundingClientRect();\n        let dropdownMenuElCoords = this.menuEl.getBoundingClientRect();\n\n        // Adds a margin to prevent the dropdown from sticking to the edge of\n        // the customize panel.\n        const dropdownMenuMargin = 5;\n        // If after opening, the dropdown list overflows the customization\n        // panel at the bottom, opens the dropdown above the selector.\n        if ((dropdownMenuElCoords.bottom + dropdownMenuMargin) > customizePanelElCoords.bottom) {\n            this.el.classList.add(\"o_we_select_dropdown_up\");\n            dropdownMenuElCoords = this.menuEl.getBoundingClientRect();\n            // If there is no available space above it either, then we open\n            // it below the selector.\n            if (dropdownMenuElCoords.top < customizePanelElCoords.top) {\n                this.el.classList.remove(\"o_we_select_dropdown_up\");\n            }\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Called when the select is clicked anywhere -> open/close it.\n     *\n     * @private\n     */\n    _onClick: function (ev) {\n        if (this._shouldIgnoreClick(ev)) {\n            return;\n        }\n\n        if (!this.menuTogglerEl.classList.contains('active')) {\n            this.open();\n        } else {\n            this.close();\n        }\n        const activeButton = this._userValueWidgets.find(widget => widget.isActive());\n        if (activeButton) {\n            this.menuEl.scrollTop = activeButton.el.offsetTop - (this.menuEl.offsetHeight / 2);\n        }\n    },\n});\n\nconst ButtonGroupUserValueWidget = BaseSelectionUserValueWidget.extend({\n    tagName: 'we-button-group',\n});\n\nconst UnitUserValueWidget = UserValueWidget.extend({\n    /**\n     * @override\n     */\n    start: async function () {\n        const unit = this.el.dataset.unit || '';\n        this.el.dataset.unit = unit;\n        if (this.el.dataset.saveUnit === undefined) {\n            this.el.dataset.saveUnit = unit;\n        }\n\n        return this._super(...arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    getActiveValue: function (methodName) {\n        const activeValue = this._super(...arguments);\n\n        const params = this._methodsParams;\n        if (!this._isNumeric()) {\n            return activeValue;\n        }\n\n        const defaultValue = this.getDefaultValue(methodName, false);\n\n        return activeValue.split(/\\s+/g).map(v => {\n            const numValue = parseFloat(v);\n            if (isNaN(numValue)) {\n                return defaultValue;\n            } else {\n                const value = weUtils.convertNumericToUnit(numValue, params.unit, params.saveUnit, params.cssProperty, this.$target);\n                return `${this._floatToStr(value)}${params.saveUnit}`;\n            }\n        }).join(' ');\n    },\n    /**\n     * @override\n     * @param {boolean} [useInputUnit=false]\n     */\n    getDefaultValue: function (methodName, useInputUnit) {\n        const defaultValue = this._super(...arguments);\n\n        const params = this._methodsParams;\n        if (!this._isNumeric()) {\n            return defaultValue;\n        }\n\n        const unit = useInputUnit ? params.unit : params.saveUnit;\n        const numValue = weUtils.convertValueToUnit(defaultValue || '0', unit, params.cssProperty, this.$target);\n        if (isNaN(numValue)) {\n            return defaultValue;\n        }\n        return `${this._floatToStr(numValue)}${unit}`;\n    },\n    /**\n     * @override\n     */\n    isActive: function () {\n        const isSuperActive = this._super(...arguments);\n        if (!this._isNumeric()) {\n            return isSuperActive;\n        }\n        return isSuperActive && (\n            this._floatToStr(parseFloat(this._value)) !== '0'\n            // Or is a composite value.\n            || !!this._value.match(/\\d+\\s+\\d+/)\n        );\n    },\n    /**\n     * @override\n     */\n    async setValue(value, methodName) {\n        const params = this._methodsParams;\n        if (this._isNumeric()) {\n            value = value.split(' ').map(v => {\n                const numValue = weUtils.convertValueToUnit(v, params.unit, params.cssProperty, this.$target);\n                if (isNaN(numValue)) {\n                    return ''; // Something not supported\n                }\n                return this._floatToStr(numValue);\n            }).join(' ');\n        }\n        return this._super(value, methodName);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Converts a floating value to a string, rounded to 5 digits without zeros.\n     *\n     * @private\n     * @param {number} value\n     * @returns {string}\n     */\n    _floatToStr: function (value) {\n        return `${parseFloat(value.toFixed(5))}`;\n    },\n    /**\n     * Checks whether the widget contains a numeric value.\n     *\n     * @private\n     * @returns {Boolean} true if the value is numeric, false otherwise.\n     */\n    _isNumeric() {\n        const params = this._methodsParams || this.el.dataset;\n        return !!params.unit;\n    },\n});\n\nconst InputUserValueWidget = UnitUserValueWidget.extend({\n    tagName: 'we-input',\n    events: {\n        'input input': '_onInputInput',\n        'blur input': '_onInputBlur',\n        'change input': '_onUserValueChange',\n        'keydown input': '_onInputKeydown',\n    },\n\n    /**\n     * @override\n     */\n    start: async function () {\n        await this._super(...arguments);\n\n        const unit = this.el.dataset.unit;\n        this.inputEl = document.createElement('input');\n        this.inputEl.setAttribute('type', 'text');\n        this.inputEl.setAttribute('autocomplete', 'chrome-off');\n        this.inputEl.setAttribute('placeholder', this.el.getAttribute('placeholder') || '');\n        const useNumberAlignment = this._isNumeric() || !!this.el.dataset.hideUnit;\n        this.inputEl.classList.toggle('text-start', !useNumberAlignment);\n        this.inputEl.classList.toggle('text-end', useNumberAlignment);\n        this.containerEl.appendChild(this.inputEl);\n\n        const showUnit = (!!unit || !!this.el.dataset.fakeUnit) && !this.el.dataset.hideUnit;\n        if (showUnit) {\n            var unitEl = document.createElement('span');\n            const unitText = this.el.dataset.fakeUnit || unit;\n            unitEl.textContent = unitText;\n            this.containerEl.appendChild(unitEl);\n            if (unitText.length > 3) {\n                this.el.classList.add('o_we_large');\n            }\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    async setValue() {\n        await this._super(...arguments);\n        this.inputEl.value = this._value;\n        this._oldValue = this._value;\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _getFocusableElement() {\n        return this.inputEl;\n    },\n    /**\n     * @override\n     */\n    _isNumeric() {\n        const isNumeric = this._super(...arguments);\n        const params = this._methodsParams || this.el.dataset;\n        return isNumeric || !!params.fakeUnit || !!params.step;\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * @private\n     * @param {Event} ev\n     */\n    _onInputInput: function (ev) {\n        // First record the input value as the new current value and bound it if\n        // necessary (min / max params).\n        this._value = this.inputEl.value;\n\n        const params = this._methodsParams;\n        const hasMin = ('min' in params);\n        const hasMax = ('max' in params);\n        if (hasMin || hasMax) {\n            // Bounding the value in [min, max] if specified.\n            const boundedValue = this._value.split(/\\s+/g).map(v => {\n                let numValue = parseFloat(v);\n                if (isNaN(numValue)) {\n                    return hasMin ? params.min : v;\n                } else {\n                    numValue = hasMin ? Math.max(params.min, numValue) : numValue;\n                    numValue = hasMax ? Math.min(numValue, params.max) : numValue;\n                    return numValue;\n                }\n            }).join(\" \");\n\n            // If the bounded version is different from the value, forget about\n            // the old value so that we properly update the UI in any case.\n            this._oldValue = undefined;\n\n            // Note: we do not change the input's value because we want the user\n            // to be able to enter anything without it being auto-fixed. For\n            // example, just emptying the input to enter new numbers: you don't\n            // want the min value to pop up unexpectedly. The next UI update\n            // will take care of showing the user that the value was bound.\n            this._value = boundedValue;\n        }\n\n        // When the value changes as a result of a arrow up/down, the change\n        // event is not called, unless a real user input has been triggered.\n        // This event handler holds a variable for this in order to not call\n        // `_onUserValueChange` two times. If the users only uses arrow up/down\n        // it will be trigger on blur otherwise it will be triggered on change.\n        if (!ev.detail || !ev.detail.keyUpOrDown) {\n            this.changeEventWillBeTriggered = true;\n        }\n        this._onUserValuePreview(ev);\n    },\n    /**\n     * @private\n     * @param {Event} ev\n     */\n    _onInputBlur: function (ev) {\n        if (this.notifyValueChangeOnBlur && !this.changeEventWillBeTriggered) {\n            // In case the input value has been modified with arrow up/down, the\n            // change event is not triggered (except if there has been a natural\n            // input event), so if the element doesn't trigger a preview, we\n            // have to notify that the value changes now.\n            this._onUserValueChange(ev);\n            this.notifyValueChangeOnBlur = false;\n        }\n        this.changeEventWillBeTriggered = false;\n    },\n    /**\n     * @private\n     * @param {Event} ev\n     */\n    _onInputKeydown: function (ev) {\n        const params = this._methodsParams;\n        if (!this._isNumeric()) {\n            return;\n        }\n        switch (ev.key) {\n            case \"Enter\":\n                this._onUserValueChange(ev);\n                break;\n            case \"ArrowUp\":\n            case \"ArrowDown\": {\n                const input = ev.currentTarget;\n                let parts = (input.value || input.placeholder).match(/-?\\d+\\.\\d+|-?\\d+/g);\n                if (!parts) {\n                    parts = [input.value || input.placeholder];\n                }\n                if (parts.length > 1 && !('min' in params)) {\n                    // No negative for composite values.\n                    params['min'] = 0;\n                }\n                const newValue = parts.map(part => {\n                    let value = parseFloat(part);\n                    if (isNaN(value)) {\n                        value = 0.0;\n                    }\n                    let step = parseFloat(params.step);\n                    if (isNaN(step)) {\n                        step = 1.0;\n                    }\n\n                    const increasing = ev.key === \"ArrowUp\";\n                    const hasMin = ('min' in params);\n                    const hasMax = ('max' in params);\n\n                    // If value already at min and trying to decrease, do nothing\n                    if (!increasing && hasMin && Math.abs(value - params.min) < 0.001) {\n                        return value;\n                    }\n                    // If value already at max and trying to increase, do nothing\n                    if (increasing && hasMax && Math.abs(value - params.max) < 0.001) {\n                        return value;\n                    }\n\n                    // If trying to decrease/increase near min/max, we still need to\n                    // bound the produced value and immediately show the user.\n                    value += (increasing ? step : -step);\n                    value = hasMin ? Math.max(params.min, value) : value;\n                    value = hasMax ? Math.min(value, params.max) : value;\n                    return this._floatToStr(value);\n                }).join(\" \");\n                if (newValue === (input.value || input.placeholder)) {\n                    return;\n                }\n                input.value = newValue;\n\n                // We need to know if the change event will be triggered or not.\n                // Change is triggered if there has been a \"natural\" input event\n                // from the user. Since we are triggering a \"fake\" input event,\n                // we specify that the original event is a key up/down.\n                input.dispatchEvent(new CustomEvent('input', {\n                    bubbles: true,\n                    cancelable: true,\n                    detail: {keyUpOrDown: true}\n                }));\n                this.notifyValueChangeOnBlur = true;\n                break;\n            }\n        }\n    },\n    /**\n     * @override\n     */\n    _onUserValueChange() {\n        if (this._oldValue !== this._value) {\n            this._super(...arguments);\n        }\n    }\n});\n\nconst MultiUserValueWidget = UserValueWidget.extend({\n    tagName: 'we-multi',\n\n    /**\n     * @override\n     */\n    start: function () {\n        if (this.options && this.options.childNodes) {\n            this.options.childNodes.forEach(node => this.containerEl.appendChild(node));\n        }\n        return this._super(...arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    getValue: function (methodName) {\n        const value = this._userValueWidgets.map(widget => {\n            return widget.getValue(methodName);\n        }).join(' ').trim();\n\n        return value || this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    isContainer: function () {\n        return true;\n    },\n    /**\n     * @override\n     */\n    async setValue(value, methodName) {\n        let values = value.split(/\\s*\\|\\s*/g);\n        if (values.length === 1) {\n            values = value.split(/\\s+/g);\n        }\n        for (let i = 0; i < this._userValueWidgets.length - 1; i++) {\n            await this._userValueWidgets[i].setValue(values.shift() || '', methodName);\n        }\n        await this._userValueWidgets[this._userValueWidgets.length - 1].setValue(values.join(' '), methodName);\n    },\n});\n\nconst ColorpickerUserValueWidget = SelectUserValueWidget.extend({\n    className: (SelectUserValueWidget.prototype.className || '') + ' o_we_so_color_palette',\n\n    /**\n     * @override\n     */\n    start: async function () {\n        const _super = this._super.bind(this);\n        const args = arguments;\n\n        this.resetTabCount = 0;\n\n        // Build the select element with a custom span to hold the color preview\n        this.colorPreviewEl = document.createElement('span');\n        this.colorPreviewEl.classList.add('o_we_color_preview');\n        // todo: This div should be removed whenever possible (like when\n        // converting the uservaluewidget to owl).\n        this.colorPaletteEl = document.createElement('div');\n        this.colorPaletteEl.classList.add('o_we_color_palette_wrapper');\n        this.colorPaletteEl.style.display = 'contents';\n        this.colorPaletteColorNames = [];\n        this.options.childNodes = [this.colorPaletteEl];\n        this.options.valueEl = this.colorPreviewEl;\n        // TODO: find a better way to do this.\n        // The colorpicker widget is started before the ColorPalette component\n        // is attached to the DOM (which only happens once the user opens the\n        // picker). However, the colorNames are only set after the ColorPalette\n        // has been mounted. Initializing the colorNames through a direct call\n        // to the `getColorPickerTemplateService` so that the widget starts\n        // with possible default values is thus necessary to avoid bugs on\n        // `_computeWidgetState()`.\n        const wysiwyg = this.getParent().options.wysiwyg;\n        if (wysiwyg) {\n            const colorpickerTemplate = await wysiwyg.getColorpickerTemplate.call(wysiwyg);\n            this.colorPaletteColorNames = this._getColorNames(colorpickerTemplate);\n        }\n        return _super(...args);\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    open: function () {\n        if (this.colorPaletteWrapper) {\n            this.colorPaletteWrapper?.update({\n                selectedCC: this._ccValue,\n                selectedColor: this._value,\n                resetTabCount: ++this.resetTabCount,\n            });\n            this._super(...arguments);\n        } else {\n            // TODO review in master, this does async stuff. Maybe the open\n            // method should now be async. This is not really robust as the\n            // colorPalette can be used without it to be fully rendered but\n            // the use of the saved promise where we can should mitigate that\n            // issue.\n            this._colorPaletteRenderPromise = this._renderColorPalette();\n            this._super(...arguments);\n            this._colorPaletteRenderPromise.then(() => {\n                // Re-adjust the position of the colorpicker once the\n                // colorpalette is completely rendered (once that the\n                // colorpicker has its final height.\n                // TODO should not be needed once everything will be converted\n                // to owl.\n                this._adjustDropdownPosition();\n            });\n        }\n    },\n    /**\n     * @override\n     */\n    close: function () {\n        this._super(...arguments);\n        if (this._customColorValue && this._customColorValue !== this._value) {\n            this._value = this._customColorValue;\n            this._customColorValue = false;\n            this._onUserValueChange();\n        }\n    },\n    /**\n     * @override\n     */\n    getMethodsParams: function () {\n        return Object.assign(this._super(...arguments), {\n            colorNames: this.colorPaletteColorNames,\n        });\n    },\n    /**\n     * @override\n     */\n    getValue: function (methodName) {\n        const isCCMethod = (this._methodsParams.withCombinations === methodName);\n        let value = this._super(...arguments);\n        if (isCCMethod) {\n            value = this._ccValue;\n        } else if (typeof this._customColorValue === 'string') {\n            value = this._customColorValue;\n        }\n\n        // TODO strange there is some processing below for the normal value but\n        // not for the preview value? To check in older stable versions as well.\n        if (typeof this._previewColor === 'string') {\n            return isCCMethod ? this._previewCC : this._previewColor;\n        }\n\n        if (value) {\n            // TODO probably something to be done to handle gradients properly\n            // in this code.\n            const useCssColor = this.options.dataAttributes.hasOwnProperty('useCssColor');\n            const cssCompatible = this.options.dataAttributes.hasOwnProperty('cssCompatible');\n            if ((useCssColor || cssCompatible) && !isCSSColor(value)) {\n                if (useCssColor) {\n                    value = weUtils.getCSSVariableValue(value);\n                } else {\n                    value = `var(--${value})`;\n                }\n            }\n        }\n        return value;\n    },\n    /**\n     * @override\n     */\n    isContainer: function () {\n        return false;\n    },\n    /**\n     * @override\n     */\n    isActive: function () {\n        return !!this._ccValue\n            || !weUtils.areCssValuesEqual(this._value, 'rgba(0, 0, 0, 0)');\n    },\n    /**\n     * Updates the color preview + re-render the whole color palette widget.\n     *\n     * @override\n     */\n    async setValue(color, methodName, ...rest) {\n        // The colorpicker widget can hold two values: a color combination and\n        // a normal color or a gradient. The base `_value` will hold the normal\n        // color or the gradient value. The color combination one will be\n        // available in `_ccValue`.\n        const isCCMethod = (this._methodsParams.withCombinations === methodName);\n        // Always call _super but don't change _value if meant for the CC value.\n        await this._super(isCCMethod ? this._value : color, methodName, ...rest);\n        if (isCCMethod) {\n            this._ccValue = color;\n        }\n\n        await this._colorPaletteRenderPromise;\n\n        const classes = weUtils.computeColorClasses(this.colorPaletteColorNames);\n        this.colorPreviewEl.classList.remove(...classes);\n        this.colorPreviewEl.style.removeProperty('background-color');\n        this.colorPreviewEl.style.removeProperty('background-image');\n        const prefix = this.options.dataAttributes.colorPrefix || 'bg';\n        if (this._ccValue) {\n            this.colorPreviewEl.style.backgroundColor = `var(--we-cp-o-cc${this._ccValue}-${prefix.replace(/-/, '')})`;\n        }\n        if (this._value) {\n            if (isCSSColor(this._value)) {\n                this.colorPreviewEl.style.backgroundColor = this._value;\n            } else if (weUtils.isColorGradient(this._value)) {\n                this.colorPreviewEl.style.backgroundImage = this._value;\n            } else if (weUtils.EDITOR_COLOR_CSS_VARIABLES.includes(this._value)) {\n                this.colorPreviewEl.style.backgroundColor = `var(--we-cp-${this._value}`;\n            } else {\n                // Checking if the className actually exists seems overkill but\n                // it is actually needed to prevent a crash. As an example, if a\n                // colorpicker widget is linked to a SnippetOption instance's\n                // `selectStyle` method designed to handle the \"border-color\"\n                // property of an element, the value received can be split if\n                // the item uses different colors for its top/right/bottom/left\n                // borders. For instance, you could receive \"red blue\" if the\n                // item as red top and bottom borders and blue left and right\n                // borders, in which case you would reach this `else` and try to\n                // add the class \"bg-red blue\" which would crash because of the\n                // space inside). In that case, we simply do not show any color.\n                // We could choose to handle this split-value case specifically\n                // but it was decided that this is enough for the moment.\n                const className = `bg-${this._value}`;\n                if (classes.includes(className)) {\n                    this.colorPreviewEl.classList.add(className);\n                }\n            }\n        }\n        // If the palette was already opened (e.g. modifying a gradient), the new DOM state must be\n        // reflected in the palette, but the tab selection must not be impacted.\n        this.colorPaletteWrapper?.update({\n            selectedCC: this._ccValue,\n            selectedColor: this._value,\n        });\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @private\n     * @returns {Promise}\n     */\n    _renderColorPalette: async function () {\n        this.resetTabCount = 0;\n        const options = {\n            resetTabCount: this.resetTabCount,\n            selectedCC: this._ccValue,\n            selectedColor: this._value,\n            getCustomColors: () => {\n                let result = [];\n                this.trigger_up('get_custom_colors', {\n                    onSuccess: (colors) => result = colors,\n                });\n                return result;\n            },\n            onCustomColorPicked: this._onCustomColorPicked.bind(this),\n            onColorPicked: this._onColorPicked.bind(this),\n            onColorHover: this._onColorHovered.bind(this),\n            onColorLeave: this._onColorLeft.bind(this),\n            onInputEnter: this._onEnterKey.bind(this),\n        };\n        if (this.options.dataAttributes.excluded) {\n            options.excluded = this.options.dataAttributes.excluded.replace(/ /g, '').split(',');\n        }\n        if (this.options.dataAttributes.opacity) {\n            options.opacity = parseFloat(this.options.dataAttributes.opacity);\n        }\n        if (this.options.dataAttributes.withCombinations) {\n            options.withCombinations = !!this.options.dataAttributes.withCombinations;\n        }\n        if (this.options.dataAttributes.withGradients) {\n            options.withGradients = !!this.options.dataAttributes.withGradients;\n        }\n        if (this.options.dataAttributes.noTransparency) {\n            options.noTransparency = !!this.options.dataAttributes.noTransparency;\n            options.excluded = [...(options.excluded || []), 'transparent_grayscale'];\n        }\n        if (this.options.dataAttributes.selectedTab) {\n            options.selectedTab = this.options.dataAttributes.selectedTab;\n        }\n        const wysiwyg = this.getParent().options.wysiwyg;\n        if (wysiwyg) {\n            options.document = this.$target[0].ownerDocument;\n            options.getTemplate = wysiwyg.getColorpickerTemplate.bind(wysiwyg);\n        }\n        this.colorPaletteWrapper?.destroy();\n        const sidebarDocument = this.colorPaletteEl.ownerDocument;\n        if (!(this.colorPaletteEl instanceof sidebarDocument.defaultView.HTMLElement)) {\n            // When inside an iframe, the element for mounting a component must\n            // be an instance of the iframe's HTMLElement, or else target\n            // validation for attachComponent fails.\n            const newEl = sidebarDocument.importNode(this.colorPaletteEl, true);\n            this.colorPaletteEl.before(newEl);\n            this.colorPaletteEl.remove();\n            this.colorPaletteEl = newEl;\n        }\n        this.colorPaletteWrapper = await attachComponent(this, this.colorPaletteEl, ColorPalette, options);\n    },\n    /**\n     * @override\n     */\n    _shouldIgnoreClick(ev) {\n        return ev.originalEvent.__isColorpickerClick || this._super(...arguments);\n    },\n    /**\n     * Browses the colorpicker XML template to return all possible values of\n     * [data-color].\n     *\n     * @param {string} colorpickerTemplate\n     * @returns {string[]}\n     */\n    _getColorNames(colorpickerTemplate) {\n        // Init with the color combinations presets as these don't appear in\n        // the template.\n        const colorNames = [\"1\", \"2\", \"3\", \"4\", \"5\"];\n        const template = new DOMParser().parseFromString(colorpickerTemplate, \"text/html\");\n        template.querySelectorAll(\"button[data-color]:not(.o_custom_gradient_btn)\").forEach(el => {\n            const colorName = el.dataset.color;\n            if (!weUtils.isColorGradient(colorName)) {\n                colorNames.push(colorName);\n            }\n        });\n        return colorNames;\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Called when a custom color is selected -> preview the color\n     * and set the current value. Update of this value on close\n     *\n     * @private\n     * @param {Object} params\n     */\n    _onCustomColorPicked: function (params) {\n        this._customColorValue = params.color;\n    },\n    /**\n     * Called when a color button is clicked -> confirms the preview.\n     *\n     * @private\n     * @param {Object} params\n     */\n    _onColorPicked: function (params) {\n        this._previewCC = false;\n        this._previewColor = false;\n        this._customColorValue = false;\n\n        this._ccValue = params.ccValue;\n        this._value = params.color;\n\n        this._onUserValueChange();\n    },\n    /**\n     * Called when a color button is entered -> previews the background color.\n     *\n     * @private\n     * @param {Object} params\n     */\n    _onColorHovered: function (params) {\n        this._previewCC = params.ccValue;\n        this._previewColor = params.color;\n        this._onUserValuePreview();\n    },\n    /**\n     * Called when a color button is left -> cancels the preview.\n     *\n     * @private\n     */\n    _onColorLeft: function () {\n        this._previewCC = false;\n        this._previewColor = false;\n        this._onUserValueReset();\n    },\n    /**\n     * @private\n     */\n    _onEnterKey: function () {\n        this.close();\n    },\n});\n\nconst MediapickerUserValueWidget = UserValueWidget.extend({\n    tagName: 'we-button',\n    events: {\n        'click': '_onEditMedia',\n    },\n\n    /**\n     * @override\n     */\n    async start() {\n        await this._super(...arguments);\n        if (this.options.dataAttributes.buttonStyle) {\n            const iconEl = document.createElement('i');\n            iconEl.classList.add('fa', 'fa-fw', 'fa-camera');\n            $(this.containerEl).prepend(iconEl);\n        } else {\n            this.el.classList.add('o_we_no_toggle', 'o_we_bg_success');\n            this.containerEl.textContent = _t(\"Replace\");\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates and opens a media dialog to edit a given element's media.\n     *\n     * @private\n     * @param {HTMLElement} el the element whose media should be edited\n     * @param {boolean} [images] whether images should be available\n     *   default: false\n     * @param {boolean} [videos] whether videos should be available\n     *   default: false\n     */\n    _openDialog(el, {images = false, videos = false, save}) {\n        el.src = this._value;\n        const $editable = this.$target.closest('.o_editable');\n        this.call(\"dialog\", \"add\", MediaDialog, {\n            noImages: !images,\n            noVideos: !videos,\n            noIcons: true,\n            noDocuments: true,\n            isForBgVideo: true,\n            vimeoPreviewIds: ['528686125', '430330731', '509869821', '397142251', '763851966', '486931161',\n                '499761556', '392935303', '728584384', '865314310', '511727912', '466830211'],\n            'res_model': $editable.data('oe-model'),\n            'res_id': $editable.data('oe-id'),\n            save,\n            media: el,\n        });\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    async setValue() {\n        await this._super(...arguments);\n        this.el.classList.toggle('active', this.isActive());\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Called when the edit button is clicked.\n     *\n     * @private\n     * @param {Event} ev\n     */\n    _onEditMedia: function (ev) {},\n});\n\nconst ImagepickerUserValueWidget = MediapickerUserValueWidget.extend({\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _onEditMedia(ev) {\n        // Need a dummy element for the media dialog to modify.\n        const dummyEl = document.createElement('img');\n        this._openDialog(dummyEl, {\n            images: true,\n            save: (media) => {\n                // Accessing the value directly through dummyEl.src converts the url to absolute,\n                // using getAttribute allows us to keep the url as it was inserted in the DOM\n                // which can be useful to compare it to values stored in db.\n                this._value = media.getAttribute('src');\n                this._onUserValueChange();\n            }\n        });\n    },\n});\n\nconst VideopickerUserValueWidget = MediapickerUserValueWidget.extend({\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _onEditMedia(ev) {\n        // Need a dummy element for the media dialog to modify.\n        const dummyEl = document.createElement('iframe');\n        this._openDialog(dummyEl, {\n            videos: true,\n            save: (media) => {\n                this._value = media.querySelector('iframe').src;\n                this._onUserValueChange();\n        }});\n    },\n});\n\nconst DatetimePickerUserValueWidget = InputUserValueWidget.extend({\n    events: { // Explicitely not consider all InputUserValueWidget events\n        'blur input': '_onInputBlur',\n        'input input': '_onDateInputInput',\n    },\n    pickerType: 'datetime',\n\n    /**\n     * @override\n     */\n    init: function () {\n        this._super(...arguments);\n        this._value = DateTime.now().toUnixInteger().toString();\n    },\n    /**\n     * @override\n     */\n    start: async function () {\n        await this._super(...arguments);\n\n        this.el.classList.add('o_we_large');\n        this.inputEl.classList.add('datetimepicker-input', 'mx-0', 'text-start');\n\n        this.picker = this.call(\"datetime_picker\", \"create\", {\n            target: this.inputEl,\n            onChange: this._onDateTimePickerChange.bind(this),\n            pickerProps: {\n                type: this.pickerType,\n                minDate: DateTime.fromObject({ year: 1000 }),\n                maxDate: DateTime.now().plus({ year: 200 }),\n                value: DateTime.fromSeconds(parseInt(this._value)),\n                rounding: 0,\n            },\n        });\n        this.picker.enable();\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    getMethodsParams: function () {\n        return Object.assign(this._super(...arguments), {\n            format: this.defaultFormat,\n        });\n    },\n    /**\n     * @override\n     */\n    isPreviewed: function () {\n        return this._super(...arguments) || this.picker.isOpen;\n    },\n    /**\n     * @override\n     */\n    async setValue() {\n        await this._super(...arguments);\n        let dateTime = null;\n        if (this._value) {\n            dateTime = DateTime.fromSeconds(parseInt(this._value))\n            if (!dateTime.isValid) {\n                dateTime = DateTime.now();\n            }\n        }\n        this.picker.state.value = dateTime;\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * @private\n     * @param {Event} ev\n     */\n    _onDateTimePickerChange: function (newDateTime) {\n        if (!newDateTime || !newDateTime.isValid) {\n            this._value = '';\n        } else {\n            this._value = newDateTime.toUnixInteger().toString();\n        }\n        this._onUserValuePreview();\n    },\n    /**\n     * Handles the clear button of the datepicker.\n     *\n     * @private\n     * @param {Event} ev\n     */\n    _onDateInputInput(ev) {\n        if (!this.inputEl.value) {\n            this._value = '';\n            this._onUserValuePreview(ev);\n        }\n    },\n});\n\nconst DatePickerUserValueWidget = DatetimePickerUserValueWidget.extend({\n    pickerType: 'date',\n});\n\nconst ListUserValueWidget = UserValueWidget.extend({\n    tagName: 'we-list',\n    events: {\n        'click we-button.o_we_select_remove_option': '_onRemoveItemClick',\n        'click we-button.o_we_list_add_optional': '_onAddCustomItemClick',\n        'click we-button.o_we_list_add_existing': '_onAddExistingItemClick',\n        'click we-select.o_we_user_value_widget.o_we_add_list_item': '_onAddItemSelectClick',\n        'click we-button.o_we_checkbox_wrapper': '_onAddItemCheckboxClick',\n        'input table input': '_onListItemBlurInput',\n        'blur table input': '_onListItemBlurInput',\n        'mousedown': '_onWeListMousedown',\n    },\n\n    /**\n     * @override\n     */\n    willStart() {\n        if (this.options.createWidget) {\n            this.createWidget = this.options.createWidget;\n            this.createWidget.setParent(this);\n            this.registerSubWidget(this.createWidget);\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    start() {\n        this.addItemTitle = this.el.dataset.addItemTitle || _t(\"Add\");\n        if (this.el.dataset.availableRecords) {\n            this.records = JSON.parse(this.el.dataset.availableRecords);\n        } else {\n            this.isCustom = !this.el.dataset.notEditable;\n        }\n        if (this.el.dataset.defaults || this.el.dataset.hasDefault) {\n            this.hasDefault = this.el.dataset.hasDefault || 'unique';\n            this.selected = this.el.dataset.defaults ? JSON.parse(this.el.dataset.defaults) : [];\n        }\n        this.listTable = document.createElement('table');\n        const tableWrapper = document.createElement('div');\n        tableWrapper.classList.add('o_we_table_wrapper');\n        tableWrapper.appendChild(this.listTable);\n        this.containerEl.appendChild(tableWrapper);\n        this.el.classList.add('o_we_fw');\n        this._makeListItemsSortable();\n        if (this.createWidget) {\n            return this.createWidget.appendTo(this.containerEl);\n        }\n    },\n\n    /**\n     * @override\n     */\n    destroy() {\n        this.bindedSortable?.cleanup();\n        this._super(...arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    getMethodsParams() {\n        return Object.assign(this._super(...arguments), {\n            records: this.records,\n        });\n    },\n    /**\n     * @override\n     */\n    setValue() {\n        this._super(...arguments);\n        const currentValues = this._value ? JSON.parse(this._value) : [];\n        this.listTable.innerHTML = '';\n        if (this.addItemButton) {\n            this.addItemButton.remove();\n        }\n\n        if (this.createWidget) {\n            const selectedIds = currentValues.map(({ id }) => id)\n                .filter(id => typeof id === 'number');\n            // Note: it's important to simplify the domain at its maximum as the\n            // rpc using it are cached. Similar domain components should be\n            // written the same way for the cache to work.\n            this.createWidget.options.domainComponents.selected = selectedIds.length ? ['id', 'not in', selectedIds] : null;\n            this.createWidget.setValue('');\n            this.createWidget.inputEl.value = '';\n            $(this.createWidget.inputEl).trigger('input');\n        } else {\n            if (this.isCustom) {\n                this.addItemButton = document.createElement('we-button');\n                this.addItemButton.textContent = this.addItemTitle;\n                this.addItemButton.classList.add('o_we_list_add_optional');\n            } else {\n                // TODO use a real select widget ?\n                this.addItemButton = document.createElement('we-select');\n                this.addItemButton.classList.add('o_we_user_value_widget', 'o_we_add_list_item');\n                const divEl = document.createElement('div');\n                this.addItemButton.appendChild(divEl);\n                const togglerEl = document.createElement('we-toggler');\n                togglerEl.textContent = this.addItemTitle;\n                divEl.appendChild(togglerEl);\n                this.selectMenuEl = document.createElement('we-selection-items');\n                divEl.appendChild(this.selectMenuEl);\n            }\n            this.containerEl.appendChild(this.addItemButton);\n        }\n        currentValues.forEach(value => {\n            if (typeof value === 'object') {\n                const recordData = value;\n                const { id, display_name } = recordData;\n                delete recordData.id;\n                delete recordData.display_name;\n                this._addItemToTable(id, display_name, recordData);\n            } else {\n                this._addItemToTable(value, value);\n            }\n        });\n        if (!this.createWidget && !this.isCustom) {\n            this._reloadSelectDropdown(currentValues);\n        }\n        this._makeListItemsSortable();\n    },\n    /**\n     * @override\n     */\n    getValue(methodName) {\n        if (this.createWidget && this.createWidget.getMethodsNames().includes(methodName)) {\n            return this.createWidget.getValue(methodName);\n        }\n        return this._value;\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @private\n     * @param {string || integer} id\n     * @param {string} [value]\n     * @param {Object} [recordData] key, values that will be added to the\n     *     element's dataset\n     */\n    _addItemToTable(id, value = this.el.dataset.defaultValue || _t(\"Item\"), recordData) {\n        const trEl = document.createElement('tr');\n        if (!this.el.dataset.unsortable) {\n            const draggableEl = document.createElement('we-button');\n            draggableEl.classList.add('o_we_drag_handle', 'o_we_link', 'fa', 'fa-fw', 'fa-arrows');\n            draggableEl.dataset.noPreview = 'true';\n            const draggableTdEl = document.createElement('td');\n            draggableTdEl.appendChild(draggableEl);\n            trEl.appendChild(draggableTdEl);\n        }\n        let recordDataSelected = false;\n        const inputEl = document.createElement('input');\n        inputEl.type = this.el.dataset.inputType || 'text';\n        if (value) {\n            inputEl.value = value;\n        }\n        if (id) {\n            inputEl.name = id;\n        }\n        if (recordData) {\n            recordDataSelected = recordData.selected;\n            if (recordData.placeholder) {\n                inputEl.placeholder = recordData.placeholder;\n            }\n            for (const key of Object.keys(recordData)) {\n                inputEl.dataset[key] = recordData[key];\n            }\n        }\n        inputEl.disabled = !this.isCustom;\n        const inputTdEl = document.createElement('td');\n        inputTdEl.classList.add('o_we_list_record_name');\n        inputTdEl.appendChild(inputEl);\n        trEl.appendChild(inputTdEl);\n        if (this.hasDefault) {\n            const checkboxEl = document.createElement('we-button');\n            checkboxEl.classList.add('o_we_user_value_widget', 'o_we_checkbox_wrapper');\n            if (this.selected.includes(id) || recordDataSelected) {\n                checkboxEl.classList.add('active');\n            }\n            if (!recordData || !recordData.notToggleable) {\n                const div = document.createElement('div');\n                const checkbox = document.createElement('we-checkbox');\n                div.appendChild(checkbox);\n                checkboxEl.appendChild(div);\n                checkboxEl.appendChild(checkbox);\n                const checkboxTdEl = document.createElement('td');\n                checkboxTdEl.appendChild(checkboxEl);\n                trEl.appendChild(checkboxTdEl);\n            }\n        }\n        if (!recordData || !recordData.undeletable) {\n            const buttonTdEl = document.createElement('td');\n            const buttonEl = document.createElement('we-button');\n            buttonEl.classList.add('o_we_select_remove_option', 'o_we_link', 'o_we_text_danger', 'fa', 'fa-fw', 'fa-minus');\n            buttonEl.dataset.removeOption = id;\n            buttonTdEl.appendChild(buttonEl);\n            trEl.appendChild(buttonTdEl);\n        }\n        this.listTable.appendChild(trEl);\n    },\n    /**\n     * @override\n     */\n    _getFocusableElement() {\n        return this.listTable.querySelector('input');\n    },\n    /**\n     * @private\n     */\n    _makeListItemsSortable() {\n        if (this.el.dataset.unsortable) {\n            return;\n        }\n        this.bindedSortable = this.call(\n            \"sortable\",\n            \"create\",\n            {\n                ref: { el: this.listTable },\n                elements: \"tr\",\n                followingElementClasses: [\"opacity-50\"],\n                handle: \".o_we_drag_handle\",\n                onDrop: () => this._notifyCurrentState(),\n                applyChangeOnDrop: true,\n            },\n        ).enable();\n    },\n    /**\n     * @private\n     * @param {Boolean} [preview]\n     */\n    _notifyCurrentState(preview = false) {\n        const isIdModeName = this.el.dataset.idMode === \"name\" || !this.isCustom;\n        const trimmed = (str) => str.trim().replace(/\\s+/g, \" \");\n        const values = [...this.listTable.querySelectorAll('.o_we_list_record_name input')].map(el => {\n            const id = trimmed(isIdModeName ? el.name : el.value);\n            return Object.assign({\n                id: /^-?[0-9]{1,15}$/.test(id) ? parseInt(id) : id,\n                name: trimmed(el.value),\n                display_name: trimmed(el.value),\n            }, el.dataset);\n        });\n        if (this.hasDefault) {\n            const checkboxes = [...this.listTable.querySelectorAll('we-button.o_we_checkbox_wrapper.active')];\n            this.selected = checkboxes.map(el => {\n                const input = el.parentElement.previousSibling.firstChild;\n                const id = trimmed(isIdModeName ? input.name : input.value);\n                return /^-?[0-9]{1,15}$/.test(id) ? parseInt(id) : id;\n            });\n            values.forEach(v => {\n                // Elements not toggleable are considered as always selected.\n                // We have to check that it is equal to the string 'true'\n                // because this information comes from the dataset.\n                v.selected = this.selected.includes(v.id) || v.notToggleable === 'true';\n            });\n        }\n        this._value = JSON.stringify(values);\n        if (preview) {\n            this._onUserValuePreview();\n        } else {\n            this._onUserValueChange();\n        }\n        if (!this.createWidget && !this.isCustom) {\n            this._reloadSelectDropdown(values);\n        }\n    },\n    /**\n     * @private\n     * @param {Array} currentValues\n     */\n    _reloadSelectDropdown(currentValues) {\n        this.selectMenuEl.innerHTML = '';\n        this.records.forEach(el => {\n            if (!currentValues.find(v => v.id === el.id)) {\n                const option = document.createElement('we-button');\n                option.classList.add('o_we_list_add_existing');\n                option.dataset.addOption = el.id;\n                option.dataset.noPreview = 'true';\n                const divEl = document.createElement('div');\n                divEl.textContent = el.display_name;\n                option.appendChild(divEl);\n                this.selectMenuEl.appendChild(option);\n            }\n        });\n        if (!this.selectMenuEl.children.length) {\n            const title = document.createElement('we-title');\n            title.textContent = _t(\"No more records\");\n            this.selectMenuEl.appendChild(title);\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * @private\n     */\n    _onAddCustomItemClick() {\n        const recordData = {};\n        if (this.el.dataset.newElementsNotToggleable) {\n            recordData.notToggleable = true;\n        }\n        this._addItemToTable(undefined, this.el.dataset.defaultValue, recordData);\n        this._notifyCurrentState();\n        // Scroll to the new list element.\n        this.el.querySelector('tr:last-child')\n            .scrollIntoView({behavior: 'smooth', block: 'nearest'});\n    },\n    /**\n     * @private\n     * @param {Event} ev\n     */\n    _onAddExistingItemClick(ev) {\n        const value = ev.currentTarget.dataset.addOption;\n        this._addItemToTable(value, ev.currentTarget.textContent);\n        this._notifyCurrentState();\n    },\n    /**\n     * @private\n     * @param {Event} ev\n     */\n    _onAddItemSelectClick(ev) {\n        ev.currentTarget.querySelector('we-toggler').classList.toggle('active');\n    },\n    /**\n     * @private\n     * @param {Event} ev\n     */\n    _onAddItemCheckboxClick: function (ev) {\n        const isActive = ev.currentTarget.classList.contains('active');\n        if (this.hasDefault === 'unique') {\n            this.listTable.querySelectorAll('we-button.o_we_checkbox_wrapper.active').forEach(el => el.classList.remove('active'));\n        }\n        ev.currentTarget.classList.toggle('active', !isActive);\n        this._notifyCurrentState();\n    },\n    /**\n     * @private\n     * @param {Event} ev\n     */\n    _onListItemBlurInput(ev) {\n        const preview = ev.type === 'input';\n        if (preview || !this.el.contains(ev.relatedTarget) || this.el.dataset.renderOnInputBlur) {\n            // We call the function below only if the element that recovers the\n            // focus after this blur is not an element of the we-list or if it\n            // is an input event (preview). This allows to use the TAB key to go\n            // from one input to another in the list. This behavior can be\n            // cancelled if the widget has reloadOnInputBlur = \"true\" in its\n            // dataset.\n            const timeSinceMousedown = ev.timeStamp - this.mousedownTime;\n            if (timeSinceMousedown < 500) {\n                // Without this \"setTimeOut\", \"click\" events are not triggered when\n                // clicking directly on a \"we-button\" of the \"we-list\" without first\n                // focusing out the input.\n                setTimeout(() => {\n                    this._notifyCurrentState(preview);\n                }, 500);\n            } else {\n                this._notifyCurrentState(preview);\n            }\n        }\n    },\n    /**\n     * @private\n     */\n    _onWeListMousedown(ev) {\n        this.mousedownTime = ev.timeStamp;\n    },\n    /**\n     * @private\n     * @param {Event} ev\n     */\n    _onRemoveItemClick(ev) {\n        const minElements = this.el.dataset.allowEmpty ? 0 : 1;\n        if (ev.target.closest('table').querySelectorAll('tr').length > minElements) {\n            ev.target.closest('tr').remove();\n            this._notifyCurrentState();\n        }\n    },\n    /**\n     * @override\n     */\n    _onUserValueNotification(ev) {\n        const { widget, previewMode, prepare } = ev.data;\n        if (widget && widget === this.createWidget) {\n            if (widget.options.createMethod && widget.getValue(widget.options.createMethod)) {\n                return this._super(ev);\n            }\n            ev.stopPropagation();\n            if (previewMode) {\n                return;\n            }\n            prepare();\n            const recordData = JSON.parse(widget.getMethodsParams('addRecord').recordData);\n            const { id, display_name } = recordData;\n            delete recordData.id;\n            delete recordData.display_name;\n            this._addItemToTable(id, display_name, recordData);\n            this._notifyCurrentState();\n        }\n        return this._super(ev);\n    },\n});\n\nconst RangeUserValueWidget = UnitUserValueWidget.extend({\n    tagName: 'we-range',\n    events: {\n        'change input': '_onInputChange',\n        'input input': '_onInputInput',\n    },\n\n    /**\n     * @override\n     */\n    async start() {\n        await this._super(...arguments);\n        this.input = document.createElement('input');\n        this.input.type = \"range\";\n        let min = this.el.dataset.min && parseFloat(this.el.dataset.min) || 0;\n        let max = this.el.dataset.max && parseFloat(this.el.dataset.max) || 100;\n        const step = this.el.dataset.step && parseFloat(this.el.dataset.step) || 1;\n        this.displayValue = this.el.dataset.displayRangeValue;\n        if (min > max) {\n            [min, max] = [max, min];\n            this.input.classList.add('o_we_inverted_range');\n        }\n        this._setInputAttributes(min, max, step);\n        this.containerEl.appendChild(this.input);\n        if (this.displayValue) {\n            this.outputEl = document.createElement('output');\n            this.outputEl.classList.add('ms-2');\n            this.containerEl.appendChild(this.outputEl);\n        }\n\n        this._onInputChange = debounce(this._onInputChange, 100);\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    loadMethodsData(validMethodNames) {\n        this._super(...arguments);\n        for (const methodName of this._methodsNames) {\n            const possibleValues = this._methodsParams.optionsPossibleValues[methodName];\n            if (possibleValues.length > 1) {\n                this._setInputAttributes(0, possibleValues.length - 1, 1);\n                break;\n            }\n        }\n    },\n    /**\n     * @override\n     */\n    async setValue(value, methodName) {\n        await this._super(...arguments);\n        const possibleValues = this._methodsParams.optionsPossibleValues[methodName];\n        const inputValue = possibleValues.length > 1 ? possibleValues.indexOf(value) : this._value;\n        this.input.value = inputValue;\n        if (this.displayValue) {\n            this.outputEl.value = inputValue;\n        }\n    },\n    /**\n     * @override\n     */\n    getValue(methodName) {\n        const value = this._super(...arguments);\n        const possibleValues = this._methodsParams.optionsPossibleValues[methodName];\n        return possibleValues.length > 1 ? possibleValues[+value] : value;\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * @private\n     */\n    _onInputChange(ev) {\n        this._value = ev.target.value;\n        this._onUserValueChange(ev);\n    },\n    /**\n     * @private\n     * @param {Event} ev\n     */\n    _onInputInput(ev) {\n        this._value = ev.target.value;\n        if (this.displayValue) {\n            this.outputEl.value = this._value;\n        }\n        this._onUserValuePreview(ev);\n    },\n    /**\n     * @private\n     */\n    _setInputAttributes(min, max, step) {\n        this.input.setAttribute('min', min);\n        this.input.setAttribute('max', max);\n        this.input.setAttribute('step', step);\n    },\n});\n\nconst SelectPagerUserValueWidget = SelectUserValueWidget.extend({\n    className: (SelectUserValueWidget.prototype.className || '') + ' o_we_select_pager',\n    events: Object.assign({}, SelectUserValueWidget.prototype.events, {\n        'click .o_pager_nav_btn': '_onClickScrollPage',\n        'click .o_pager_nav_angle': '_onClickCloseMenu',\n    }),\n    /**\n     * @override\n     */\n    async start() {\n        const _super = this._super.bind(this);\n\n        await _super(...arguments);\n        this.menuEl.classList.add('o_we_has_pager', 'position-fixed', 'top-0', 'end-0', 'z-index-1', 'rounded-0');\n        this.menuTogglerEl.classList.add('o_we_toggler_pager');\n\n        this.pagerContainerEl = this.el.querySelector('.o_pager_container');\n        this.__onScroll = throttleForAnimation(this._onScroll.bind(this));\n        this.pagerContainerEl.addEventListener('scroll', this.__onScroll);\n    },\n    /**\n     * @override\n     */\n    destroy() {\n        this._super(...arguments);\n        this.pagerContainerEl.removeEventListener('scroll', this.__onScroll);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * We never try to adjust the position for selection with pagers as they\n     * are fullscreen.\n     *\n     * @override\n     */\n    _adjustDropdownPosition() {\n        return;\n    },\n    /**\n     * @override\n     */\n    _shouldIgnoreClick(ev) {\n        return !!ev.target.closest('.o_pager_nav') || this._super(...arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Scrolls to the requested section.\n     *\n     * @private\n     */\n    _onClickScrollPage(ev) {\n        const navButtonEl = ev.currentTarget;\n        const attribute = navButtonEl.dataset.scrollTo;\n        const destinationOffset = this.menuEl.querySelector('.' + attribute).offsetTop;\n\n        const pagerNavEl = this.menuEl.querySelector('.o_pager_nav');\n        this.pagerContainerEl.scrollTop = destinationOffset - pagerNavEl.offsetHeight;\n    },\n    /**\n     * @private\n     */\n    _onClickCloseMenu(ev) {\n        this.close();\n    },\n    /**\n     * @private\n     */\n    _onScroll(ev) {\n        const pagerContainerHeight = this.pagerContainerEl.getBoundingClientRect().height;\n        // The threshold for when a menu element is defined as 'active' is half\n        // of the container's height. This has a drawback as if a section\n        // is too small it might never get `active` if it's the last section.\n        const threshold = this.pagerContainerEl.scrollTop + (pagerContainerHeight / 2);\n        const anchorElements = this.menuEl.querySelectorAll('[data-scroll-to]');\n        for (const anchorEl of anchorElements) {\n            const destination = anchorEl.getAttribute('data-scroll-to');\n            const sectionEl = this.menuEl.querySelector(`.${destination}`);\n            const nextSectionEl = sectionEl.nextElementSibling;\n            anchorEl.classList.toggle('active', sectionEl.offsetTop < threshold &&\n            (!nextSectionEl || nextSectionEl.offsetTop > threshold));\n        }\n    }\n});\n\nconst Many2oneUserValueWidget = SelectUserValueWidget.extend({\n    className: (SelectUserValueWidget.prototype.className || '') + ' o_we_many2one',\n    events: Object.assign({}, SelectUserValueWidget.prototype.events, {\n        'input .o_we_m2o_search input': '_onSearchInput',\n        'keydown .o_we_m2o_search input': '_onSearchKeydown',\n        'click .o_we_m2o_search_more': '_onSearchMoreClick',\n    }),\n    // Data-attributes that will be read into `this.options` on init and not\n    // transfered to inner buttons.\n    // `domain` is the static part of the domain used in searches, not\n    // depending on already selected ids and other filters.\n    configAttributes: [\n        'model', 'fields', 'limit', 'domain', 'callWith', 'createMethod', 'filterInModel', 'filterInField', 'nullText'\n    ],\n\n    /**\n     * @override\n     */\n    init(parent, title, options, $target) {\n        this.afterSearch = [];\n        this.displayNameCache = {};\n        const {dataAttributes} = options;\n        Object.assign(options, {\n            limit: '5',\n            fields: '[]',\n            domain: '[]',\n            callWith: 'id',\n        });\n        this.configAttributes.forEach(attr => {\n            if (dataAttributes.hasOwnProperty(attr)) {\n                options[attr] = dataAttributes[attr];\n                delete dataAttributes[attr];\n            }\n        });\n        options.limit = parseInt(options.limit);\n        options.fields = JSON.parse(options.fields);\n        if (!options.fields.includes('display_name')) {\n            options.fields.push('display_name');\n        }\n        options.domain = JSON.parse(options.domain);\n        options.domainComponents = {};\n        options.nullText = $target[0].dataset.nullText ||\n            JSON.parse($target[0].dataset.oeContactOptions || '{}')['null_text'];\n\n        this.orm = serviceCached(this.bindService(\"orm\"));\n\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    async start() {\n        await this._super(...arguments);\n\n        this.inputEl = document.createElement('input');\n        this.inputEl.setAttribute('placeholder', _t(\"Search for records...\"));\n        const searchEl = document.createElement('div');\n        searchEl.classList.add('o_we_m2o_search');\n        searchEl.appendChild(this.inputEl);\n        this.menuEl.appendChild(searchEl);\n\n        this.searchMore = document.createElement('div');\n        this.searchMore.classList.add('o_we_m2o_search_more');\n        this.searchMore.textContent = _t(\"Search more...\");\n        this.searchMore.title = _t(\"Search to show more records\");\n\n        if (this.options.createMethod) {\n            this.createInput = new InputUserValueWidget(this, undefined, {\n                classes: ['o_we_large'],\n                dataAttributes: { noPreview: 'true' },\n            }, this.$target);\n            this.createButton = new ButtonUserValueWidget(this, undefined, {\n                classes: ['flex-grow-0'],\n                dataAttributes: {\n                    noPreview: 'true',\n                    [this.options.createMethod]: '', // Value through getValue.\n                },\n                childNodes: [document.createTextNode(_t(\"Create\"))],\n            }, this.$target);\n            // Override isActive so it doesn't show up in toggler\n            this.createButton.isActive = () => false;\n\n            await Promise.all([\n                this.createInput.appendTo(document.createDocumentFragment()),\n                this.createButton.appendTo(document.createDocumentFragment()),\n            ]);\n            this.registerSubWidget(this.createInput);\n            this.registerSubWidget(this.createButton);\n            this.createWidget = _buildRowElement('', {\n                classes: ['o_we_full_row', 'o_we_m2o_create', 'p-1'],\n                childNodes: [this.createInput.el, this.createButton.el],\n            });\n        }\n\n        return this._search('');\n    },\n    /**\n     * @override\n     */\n    async setValue(value, methodName) {\n        await this._super(...arguments);\n        if (this.menuTogglerEl.textContent === this.PLACEHOLDER_TEXT.toString()) {\n            // The currently selected value is not present in the search, need to read\n            // its display name.\n            if (value !== '') {\n                // FIXME: value may not be an id if callWith is specified!\n                this.menuTogglerEl.textContent = await this._getDisplayName(parseInt(value));\n            } else {\n                this.menuTogglerEl.textContent = _t(\"Choose a record...\");\n            }\n        }\n    },\n    /**\n     * @override\n     */\n    getValue(methodName) {\n        if (methodName === this.options.createMethod && this.createInput) {\n            return this.createInput._value;\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * Prevents double widget instanciation for we-buttons that have been\n     * created manually by _search (container widgets will have their innner\n     * html searched for userValueWidgets to instanciate during option startup)\n     *\n     * @override\n     */\n    isContainer() {\n        return false;\n    },\n    /**\n     * @override\n     */\n    open() {\n        if (this.createInput) {\n            this.createInput.setValue('');\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * Updates the domain with defined inclusive filter to make sure that only\n     * records that are linked to specific records are retrieved.\n     * Filtering-in is configured with\n     *   * a `filterInModel` attribute, the linked model\n     *   * a `filterInField` attribute, field of the linked model holding\n     *   allowed values for this widget\n     *\n     * @param {integer[]} linkedRecordsIds\n     * @returns {Promise}\n     */\n    async setFilterInDomainIds(linkedRecordsIds) {\n        const allowedIds = new Set();\n        if (linkedRecordsIds) {\n            const parentRecordsData = await this.orm.searchRead(\n                this.options.filterInModel,\n                [['id', 'in', linkedRecordsIds]],\n                [this.options.filterInField]\n            );\n            parentRecordsData.forEach(record => {\n                record[this.options.filterInField].forEach(item => allowedIds.add(item));\n            });\n        }\n        if (allowedIds.size) {\n            this.options.domainComponents.filterInModel = ['id', 'in', [...allowedIds]];\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Searches the database for corresponding records and updates the dropdown\n     *\n     * @private\n     */\n    async _search(needle) {\n        const recTuples = await this.orm.call(this.options.model, \"name_search\", [], {\n            name: needle,\n            args: (await this._getSearchDomain()).concat(\n                Object.values(this.options.domainComponents).filter(item => item !== null)\n            ),\n            operator: \"ilike\",\n            limit: this.options.limit + 1,\n        });\n        const records = await this.orm.read(\n            this.options.model,\n            recTuples.map(([id, _name]) => id),\n            this.options.fields\n        );\n        // Remove select options.\n        this._userValueWidgets.filter(widget => {\n            return widget instanceof ButtonUserValueWidget &&\n                !widget.isDestroyed() &&\n                widget.el.parentElement.matches('we-selection-items');\n        }).forEach(button => {\n            if (button.isPreviewed()) {\n                button.notifyValueChange('reset');\n            }\n            button.destroy();\n        });\n        this._userValueWidgets = this._userValueWidgets.filter(widget => !widget.isDestroyed());\n        if (this.options.nullText &&\n                this.options.nullText.toLowerCase().includes(needle.toLowerCase())) {\n            // Beware of RPC cache.\n            if (!records.length || records[0].id) {\n                records.unshift({id: 0, name: this.options.nullText, display_name: this.options.nullText});\n            }\n        }\n        records.forEach(record => {\n            this.displayNameCache[record.id] = record.display_name;\n        });\n\n        await Promise.all(records.slice(0, this.options.limit).map(async record => {\n            // Copy over the data-attributes from the main element, and default the value\n            // to the callWith field of the record so that if it's a method, it will\n            // be called with that value\n            const buttonDataAttributes = Object.assign({}, this.options.dataAttributes);\n            Object.keys(buttonDataAttributes).forEach(key => {\n                buttonDataAttributes[key] = buttonDataAttributes[key] || record[this.options.callWith];\n            });\n            // REMARK: this syntax is very similar to React.createComponent, maybe we could\n            // write a transformer like there is for JSX?\n            const buttonWidget = new ButtonUserValueWidget(this, undefined, {\n                dataAttributes: Object.assign({recordData: JSON.stringify(record)}, buttonDataAttributes),\n                childNodes: [document.createTextNode(record.display_name)],\n            }, this.$target);\n            this.registerSubWidget(buttonWidget);\n            await buttonWidget.appendTo(this.menuEl);\n            if (this._methodsNames) {\n                buttonWidget.loadMethodsData(this._methodsNames);\n            }\n        }));\n        // Load methodsData for new buttons if possible. It will not be possible\n        // when the widget is first created (as this._methodsNames will be undefined)\n        // but the snippetOption lifecycle will load the methods data explicitely\n        // just after creating the widget\n        if (this._methodsNames) {\n            this._methodsNames.forEach(methodName => {\n                this.setValue(this._value, methodName);\n            });\n        }\n\n        const hasMore = records.length > this.options.limit;\n        if (hasMore) {\n            this.menuEl.appendChild(this.searchMore);\n            this.searchMore.classList.remove('d-none');\n        } else {\n            this.searchMore.classList.add('d-none');\n        }\n\n        if (this.createWidget) {\n            this.menuEl.appendChild(this.createWidget);\n        }\n\n        this.waitingForSearch = false;\n        this.afterSearch.forEach(cb => cb());\n        this.afterSearch = [];\n        if (this.options.nullText && !this.getValue()) {\n            this.setValue(0);\n        }\n    },\n    /**\n     * Returns the domain to use for the search.\n     *\n     * @private\n     */\n    async _getSearchDomain() {\n        return this.options.domain;\n    },\n    /**\n     * Returns the display name for a given record.\n     *\n     * @private\n     */\n    async _getDisplayName(recordId) {\n        if (!this.displayNameCache.hasOwnProperty(recordId)) {\n            this.displayNameCache[recordId] = (await this.orm.read(this.options.model, [recordId], ['display_name']))[0].display_name;\n        }\n        return this.displayNameCache[recordId];\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _onClick(ev) {\n        // Prevent dropdown from closing if you click on the search or has_more\n        if (ev.target.closest('.o_we_m2o_search_more, .o_we_m2o_search, .o_we_m2o_create') &&\n                !ev.target.closest('we-button')) {\n            ev.stopPropagation();\n            return;\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * Handles changes to the search bar.\n     *\n     * @private\n     */\n    _onSearchInput(ev) {\n        // maybe there is a concurrency primitive we can use instead of manual record-keeping?\n        // Basically we want to queue the enter action to go after the current search if there\n        // is one that is ongoing (ie currently waiting for the debounce or RPC)\n        clearTimeout(this.searchIntent);\n        this.waitingForSearch = true;\n        this.searchIntent = setTimeout(() => {\n            this._search(ev.target.value);\n        }, 500);\n    },\n    /**\n     * Selects the first option when pressing enter in the search input.\n     *\n     * @private\n     */\n    _onSearchKeydown(ev) {\n        if (ev.key !== \"Enter\") {\n            return;\n        }\n        const action = () => {\n            const firstButton = this.menuEl.querySelector(':scope > we-button');\n            if (firstButton) {\n                firstButton.click();\n            }\n        };\n        if (this.waitingForSearch) {\n            this.afterSearch.push(action);\n        } else {\n            action();\n        }\n    },\n    /**\n     * Focuses the search input when clicking on the \"Search more...\" button.\n     *\n     * @private\n     */\n    _onSearchMoreClick(ev) {\n        this.inputEl.focus();\n    },\n    /**\n     * @override\n     */\n    _onUserValueNotification(ev) {\n        const { widget } = ev.data;\n        if (widget && widget === this.createInput) {\n            ev.stopPropagation();\n            return;\n        }\n        if (widget && widget === this.createButton) {\n            // When the create button is clicked, make sure the text\n            // value is restored from the actual input element because\n            // it might have been removed when hovering existing tags.\n            // TODO review this, there is probably better to do\n            this.createInput._value = this.createInput.el.querySelector('input').value;\n            if (!this.createInput._value) {\n                ev.stopPropagation();\n            }\n            return;\n        }\n        if (widget !== this.createButton && this.createInput) {\n            this.createInput._value = '';\n        }\n        return this._super(ev);\n    },\n});\n\nconst Many2manyUserValueWidget = UserValueWidget.extend({\n    configAttributes: ['model', 'recordId', 'm2oField', 'createMethod', 'fakem2m', 'filterIn'],\n\n    /**\n     * @override\n     */\n    init(parent, title, options, $target) {\n        const { dataAttributes } = options;\n        this.configAttributes.forEach(attr => {\n            if (dataAttributes.hasOwnProperty(attr)) {\n                options[attr] = dataAttributes[attr];\n                delete dataAttributes[attr];\n            }\n        });\n        this.filterIn = options.filterIn !== undefined;\n        if (this.filterIn) {\n            // Transfer filter-in values to child m2o.\n            dataAttributes.filterInModel = options.model;\n            dataAttributes.filterInField = options.m2oField;\n        }\n        this.orm = this.bindService(\"orm\");\n        this.fields = this.bindService(\"field\");\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    async willStart() {\n        await this._super(...arguments);\n        // If the widget does not have a real m2m field in the database\n        // We do not need to fetch anything from the DB\n        if (this.options.fakem2m) {\n            this.m2oModel = this.options.model;\n            return;\n        }\n        const { model, recordId, m2oField } = this.options;\n        const [record] = await this.orm.read(model, [parseInt(recordId)], [m2oField]);\n        const selectedRecordIds = record[m2oField];\n        // TODO: handle no record\n        const modelData = await this.fields.loadFields(model, { fieldNames: [m2oField] });\n        // TODO: simultaneously fly both RPCs\n        this.m2oModel = modelData[m2oField].relation;\n        this.m2oName = modelData[m2oField].field_description; // Use as string attr?\n\n        const selectedRecords = await this.orm.read(this.m2oModel, selectedRecordIds, ['display_name']);\n        // TODO: reconcile the fact that this widget sets its own initial value\n        // instead of it coming through setValue(_computeWidgetState)\n        this._value = JSON.stringify(selectedRecords);\n    },\n    /**\n     * @override\n     */\n    async start() {\n        this.el.classList.add('o_we_m2m');\n        const m2oDataAttributes = Object.entries(this.options.dataAttributes).filter(([attrName]) => {\n            return Many2oneUserValueWidget.prototype.configAttributes.includes(attrName);\n        });\n        m2oDataAttributes.push(\n            ['model', this.m2oModel],\n            ['addRecord', ''],\n            ['createMethod', this.options.createMethod],\n        );\n        // Don't register this one as a subWidget because it will be a subWidget\n        // of the listWidget\n        this.createWidget = new Many2oneUserValueWidget(null, undefined, {\n            dataAttributes: Object.fromEntries(m2oDataAttributes),\n        }, this.$target);\n\n        this.listWidget = registerUserValueWidget('we-list', this, undefined, {\n            dataAttributes: { unsortable: 'true', notEditable: 'true', allowEmpty: 'true' },\n            createWidget: this.createWidget,\n        }, this.$target);\n        await this.listWidget.appendTo(this.containerEl);\n\n        // Make this.el the select's offsetParent so the we-selection-items has\n        // the correct width\n        this.listWidget.el.querySelector('we-select').style.position = 'static';\n        this.el.style.position = 'relative';\n    },\n    /**\n     * Only allow to fetch/select records which are linked (via `m2oField`) to the\n     * specified records.\n     *\n     * @param {integer[]} linkedRecordsIds\n     * @returns {Promise}\n     * @see Many2oneUserValueWidget.setFilterInDomainIds\n     */\n    async setFilterInDomainIds(linkedRecordsIds) {\n        if (this.filterIn) {\n            return this.listWidget.createWidget.setFilterInDomainIds(linkedRecordsIds);\n        }\n    },\n    /**\n     * @override\n     */\n    loadMethodsData(validMethodNames, ...rest) {\n        // TODO: check that addRecord is still needed.\n        this._super(['addRecord', ...validMethodNames], ...rest);\n        this._methodsNames = this._methodsNames.filter(name => name !== 'addRecord');\n    },\n    /**\n     * @override\n     */\n    setValue(value, methodName) {\n        if (methodName === this.options.createMethod) {\n            return this.createWidget.setValue(value, methodName);\n        }\n        if (!value) {\n            // TODO: why do we need this.\n            value = this._value;\n        }\n        this._super(value, methodName);\n        this.listWidget.setValue(this._value);\n    },\n    /**\n     * @override\n     */\n    getValue(methodName) {\n        return this.listWidget.getValue(methodName);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _onUserValueNotification(ev) {\n        const { widget, previewMode } = ev.data;\n        if (!widget) {\n            return this._super(ev);\n        }\n        if (widget === this.listWidget) {\n            ev.stopPropagation();\n            this._value = widget._value;\n            this.notifyValueChange(previewMode);\n        }\n    },\n});\n\nconst userValueWidgetsRegistry = {\n    'we-button': ButtonUserValueWidget,\n    'we-checkbox': CheckboxUserValueWidget,\n    'we-select': SelectUserValueWidget,\n    'we-button-group': ButtonGroupUserValueWidget,\n    'we-input': InputUserValueWidget,\n    'we-multi': MultiUserValueWidget,\n    'we-colorpicker': ColorpickerUserValueWidget,\n    'we-datetimepicker': DatetimePickerUserValueWidget,\n    'we-datepicker': DatePickerUserValueWidget,\n    'we-list': ListUserValueWidget,\n    'we-imagepicker': ImagepickerUserValueWidget,\n    'we-videopicker': VideopickerUserValueWidget,\n    'we-range': RangeUserValueWidget,\n    'we-select-pager': SelectPagerUserValueWidget,\n    'we-many2one': Many2oneUserValueWidget,\n    'we-many2many': Many2manyUserValueWidget,\n};\n\n/**\n * Handles a set of options for one snippet. The registry returned by this\n * module contains the names of the specialized SnippetOptionWidget which can be\n * referenced thanks to the data-js key in the web_editor options template.\n */\nconst SnippetOptionWidget = Widget.extend({\n    tagName: 'we-customizeblock-option',\n    events: {\n        'click .o_we_collapse_toggler': '_onCollapseTogglerClick',\n    },\n    custom_events: {\n        'user_value_update': '_onUserValueUpdate',\n        'user_value_widget_critical': '_onUserValueWidgetCritical',\n    },\n    /**\n     * Indicates if the option should be displayed in the button group at the\n     * top of the options panel, next to the clone/remove button.\n     *\n     * @type {boolean}\n     */\n    isTopOption: false,\n    /**\n     * Indicates if the option should be the first one displayed in the button\n     * group at the top of the options panel, next to the clone/remove button.\n     *\n     * @type {boolean}\n     */\n    isTopFirstOption: false,\n    /**\n     * Forces the target to not be possible to remove. It will also hide the\n     * clone button.\n     *\n     * @type {boolean}\n     */\n    forceNoDeleteButton: false,\n    /**\n     * The option needs the handles overlay to be displayed on the snippet.\n     *\n     * @type {boolean}\n     */\n    displayOverlayOptions: false,\n    /**\n     * Forces the target to be duplicable.\n     *\n     * @type {boolean}\n     */\n    forceDuplicateButton: false,\n\n    /**\n     * The option `$el` is supposed to be the associated DOM UI element.\n     * The option controls another DOM element: the snippet it\n     * customizes, which can be found at `$target`. Access to the whole edition\n     * overlay is possible with `$overlay` (this is not recommended though).\n     *\n     * @constructor\n     */\n    init: function (parent, $uiElements, $target, $overlay, data, options) {\n        this._super.apply(this, arguments);\n\n        this.$originalUIElements = $uiElements;\n\n        this.$target = $target;\n        this.$overlay = $overlay;\n        this.data = data;\n        this.options = options;\n\n        this.className = 'snippet-option-' + this.data.optionName;\n\n        this.ownerDocument = this.$target[0].ownerDocument;\n\n        this._userValueWidgets = [];\n        this._actionQueues = new Map();\n\n        this.dialog = this.bindService(\"dialog\");\n    },\n    /**\n     * @override\n     */\n    willStart: async function () {\n        await this._super(...arguments);\n        return this._renderOriginalXML().then(uiFragment => {\n            this.uiFragment = uiFragment;\n        });\n    },\n    /**\n     * @override\n     */\n    renderElement: function () {\n        this._super(...arguments);\n        this.el.appendChild(this.uiFragment);\n        this.uiFragment = null;\n    },\n    /**\n     * Called when the parent edition overlay is covering the associated snippet\n     * (the first time, this follows the call to the @see start method).\n     *\n     * @abstract\n     * @returns {Promise|undefined}\n     */\n    async onFocus() {},\n    /**\n     * Called when the parent edition overlay is covering the associated snippet\n     * for the first time, when it is a new snippet dropped from the d&d snippet\n     * menu. Note: this is called after the start and onFocus methods.\n     *\n     * @abstract\n     * @param {Object} options\n     * @param {boolean} options.isCurrent\n     *        true if the main element has been built (so not when a child of\n     *        the main element has been built).\n     * @returns {Promise|undefined}\n     */\n    async onBuilt(options) {},\n    /**\n     * Called when the parent edition overlay is removed from the associated\n     * snippet (another snippet enters edition for example).\n     *\n     * @abstract\n     * @returns {Promise|undefined}\n     */\n    async onBlur() {},\n    /**\n     * Called when the associated snippet is the result of the cloning of\n     * another snippet (so `this.$target` is a cloned element).\n     *\n     * @abstract\n     * @param {Object} options\n     * @param {boolean} options.isCurrent\n     *        true if the associated snippet is a clone of the main element that\n     *        was cloned (so not a clone of a child of this main element that\n     *        was cloned)\n     */\n    onClone: function (options) {},\n    /**\n     * Called when the associated snippet is moved to another DOM location.\n     *\n     * @abstract\n     */\n    onMove: function () {},\n    /**\n     * Called when the associated snippet is about to be removed from the DOM.\n     *\n     * @abstract\n     * @returns {Promise|undefined}\n     */\n    onRemove: async function () {},\n    /**\n     * Called when the target is shown, only meaningful if the target was hidden\n     * at some point (typically used for 'invisible' snippets).\n     *\n     * @abstract\n     * @returns {Promise|undefined}\n     */\n    onTargetShow: async function () {},\n    /**\n     * Called when the target is hidden (typically used for 'invisible'\n     * snippets).\n     *\n     * @abstract\n     * @returns {Promise|undefined}\n     */\n    onTargetHide: async function () {},\n    /**\n     * Called when the template which contains the associated snippet is about\n     * to be saved.\n     *\n     * @abstract\n     * @return {Promise|undefined}\n     */\n    cleanForSave: async function () {},\n    /**\n     * Called when the associated snippet UI needs to be cleaned (e.g. from\n     * visual effects like previews).\n     * TODO this function will replace `cleanForSave` in the future.\n     *\n     * @abstract\n     * @return {Promise|undefined}\n     */\n    cleanUI: async function () {},\n    /**\n     * Adds the given widget to the known list of user value widgets\n     *\n     * @param {UserValueWidget} widget\n     */\n    registerSubWidget(widget) {\n        this._userValueWidgets.push(widget);\n    },\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * Default option method which allows to select one and only one class in\n     * the option classes set and set it on the associated snippet. The common\n     * case is having a select with each item having a `data-select-class`\n     * value allowing to choose the associated class, or simply an unique\n     * checkbox to allow toggling a unique class.\n     *\n     * @param {boolean|string} previewMode\n     *        - truthy if the option is enabled for preview or if leaving it (in\n     *          that second case, the value is 'reset')\n     *        - false if the option should be activated for good\n     * @param {string} widgetValue\n     * @param {Object} params\n     * @returns {Promise|undefined}\n     */\n    selectClass: function (previewMode, widgetValue, params) {\n        for (const classNames of params.possibleValues) {\n            if (classNames) {\n                this.$target[0].classList.remove(...classNames.trim().split(/\\s+/g));\n            }\n        }\n        if (widgetValue) {\n            this.$target[0].classList.add(...widgetValue.trim().split(/\\s+/g));\n        }\n    },\n    /**\n     * Default option method which allows to select a value and set it on the\n     * associated snippet as a data attribute. The name of the data attribute is\n     * given by the attributeName parameter.\n     *\n     * @param {boolean} previewMode - @see this.selectClass\n     * @param {string} widgetValue\n     * @param {Object} params\n     * @returns {Promise|undefined}\n     */\n    selectDataAttribute: function (previewMode, widgetValue, params) {\n        const value = this._selectAttributeHelper(widgetValue, params);\n        this.$target[0].dataset[params.attributeName] = value;\n    },\n    /**\n     * Default option method which allows to select a value and set it on the\n     * associated snippet as an attribute. The name of the attribute is\n     * given by the attributeName parameter.\n     *\n     * @param {boolean} previewMode - @see this.selectClass\n     * @param {string} widgetValue\n     * @param {Object} params\n     * @returns {Promise|undefined}\n     */\n    selectAttribute: function (previewMode, widgetValue, params) {\n        const value = this._selectAttributeHelper(widgetValue, params);\n        if (value) {\n            this.$target[0].setAttribute(params.attributeName, value);\n        } else {\n            this.$target[0].removeAttribute(params.attributeName);\n        }\n    },\n    /**\n     * Default option method which allows to select a value and set it on the\n     * associated snippet as a property. The name of the property is\n     * given by the propertyName parameter.\n     *\n     * @param {boolean} previewMode - @see this.selectClass\n     * @param {string} widgetValue\n     * @param {Object} params\n     */\n    selectProperty: function (previewMode, widgetValue, params) {\n        if (!params.propertyName) {\n            throw new Error('Property name missing');\n        }\n        const value = this._selectValueHelper(widgetValue, params);\n        this.$target[0][params.propertyName] = value;\n    },\n    /**\n     * Default option method which allows to select a value and set it on the\n     * associated snippet as a css style. The name of the css property is\n     * given by the cssProperty parameter.\n     *\n     * @param {boolean} previewMode - @see this.selectClass\n     * @param {string} widgetValue\n     * @param {Object} params\n     * @param {string} [params.forceStyle] if undefined, the method will not\n     *      set the inline style (and thus even remove it) if the item would\n     *      already have the given style without it (thanks to a CSS rule for\n     *      example). If defined (as a string), it acts as the \"priority\" param\n     *      of @see CSSStyleDeclaration.setProperty: it should be 'important' to\n     *      set the style as important or '' otherwise. Note that if forceStyle\n     *      is undefined, the style is set as important only if required to have\n     *      an effect.\n     * @returns {Promise|undefined}\n     */\n    selectStyle: async function (previewMode, widgetValue, params) {\n        // Disable all transitions for the duration of the method as many\n        // comparisons will be done on the element to know if applying a\n        // property has an effect or not. Also, changing a css property via the\n        // editor should not show any transition as previews would not be done\n        // immediately, which is not good for the user experience.\n        this.$target[0].classList.add('o_we_force_no_transition');\n        const _restoreTransitions = () => this.$target[0].classList.remove('o_we_force_no_transition');\n\n        if (params.cssProperty === 'background-color') {\n            this.$target.trigger('background-color-event', previewMode);\n        }\n\n        // Always reset the inline style first to not put inline style on an\n        // element which already have this style through css stylesheets.\n        let cssProps = weUtils.CSS_SHORTHANDS[params.cssProperty] || [params.cssProperty];\n        for (const cssProp of cssProps) {\n            this.$target[0].style.setProperty(cssProp, '');\n        }\n        if (params.extraClass) {\n            this.$target.removeClass(params.extraClass);\n        }\n        // Plain color and gradient are mutually exclusive as background so in\n        // case we edit a background-color we also have to reset the gradient\n        // part of the background-image property (the opposite is handled by the\n        // fact that editing a gradient as background is done by calling this\n        // method with background-color as property too, so it is automatically\n        // reset anyway).\n        let bgImageParts = undefined;\n        if (params.withGradients && params.cssProperty === 'background-color') {\n            const styles = getComputedStyle(this.$target[0]);\n            bgImageParts = backgroundImageCssToParts(styles['background-image']);\n            delete bgImageParts.gradient;\n            const combined = backgroundImagePartsToCss(bgImageParts);\n            this.$target[0].style.setProperty('background-image', '');\n            applyCSS.call(this, 'background-image', combined, styles);\n        }\n\n        // Only allow to use a color name as a className if we know about the\n        // other potential color names (to remove) and if we know about a prefix\n        // (otherwise we suppose that we should use the actual related color).\n        // Note: color combinations classes are handled by a dedicated method,\n        // as they can be combined with normal classes.\n        if (params.colorNames && params.colorPrefix) {\n            const colorNames = params.colorNames.filter(name => !weUtils.isColorCombinationName(name));\n            const classes = weUtils.computeColorClasses(colorNames, params.colorPrefix);\n            this.$target[0].classList.remove(...classes);\n\n            if (colorNames.includes(widgetValue)) {\n                const originalCSSValue = window.getComputedStyle(this.$target[0])[cssProps[0]];\n                const className = params.colorPrefix + widgetValue;\n                this.$target[0].classList.add(className);\n                if (originalCSSValue !== window.getComputedStyle(this.$target[0])[cssProps[0]]) {\n                    // If applying the class did indeed changed the css\n                    // property we are editing, nothing more has to be done.\n                    // (except adding the extra class)\n                    this.$target.addClass(params.extraClass);\n                    _restoreTransitions();\n                    return;\n                }\n                // Otherwise, it means that class probably does not exist,\n                // we remove it and continue. Especially useful for some\n                // prefixes which only work with some color names but not all.\n                this.$target[0].classList.remove(className);\n            }\n        }\n\n        const styles = window.getComputedStyle(this.$target[0]);\n\n        // At this point, the widget value is either a property/color name or\n        // an actual css property value. If it is a property/color name, we will\n        // apply a css variable as style value.\n        const htmlPropValue = weUtils.getCSSVariableValue(widgetValue);\n        if (htmlPropValue) {\n            widgetValue = `var(--${widgetValue})`;\n        }\n\n        // In case of background-color edition, we could receive a gradient, in\n        // which case the value has to be combined with the potential background\n        // image (real image).\n        if (params.withGradients && params.cssProperty === 'background-color' && weUtils.isColorGradient(widgetValue)) {\n            cssProps = ['background-image'];\n            bgImageParts.gradient = widgetValue;\n            widgetValue = backgroundImagePartsToCss(bgImageParts);\n\n            // Also force the background-color to transparent as otherwise it\n            // won't act as a \"gradient replacing the color combination\n            // background\" but be applied over it (which would be the opposite\n            // of what happens when editing the background color).\n            applyCSS.call(this, 'background-color', 'rgba(0, 0, 0, 0)', styles);\n        }\n\n        // replacing ', ' by ',' to prevent attributes with internal space separators from being split:\n        // eg: \"rgba(55, 12, 47, 1.9) 47px\" should be split as [\"rgba(55,12,47,1.9)\", \"47px\"]\n        const values = widgetValue.replace(/,\\s/g, ',').split(/\\s+/g);\n        while (values.length < cssProps.length) {\n            switch (values.length) {\n                case 1:\n                case 2: {\n                    values.push(values[0]);\n                    break;\n                }\n                case 3: {\n                    values.push(values[1]);\n                    break;\n                }\n                default: {\n                    values.push(values[values.length - 1]);\n                }\n            }\n        }\n\n        let hasUserValue = false;\n        const applyAllCSS = (values) => {\n            for (let i = cssProps.length - 1; i > 0; i--) {\n                hasUserValue = applyCSS.call(this, cssProps[i], values.pop(), styles) || hasUserValue;\n            }\n            hasUserValue = applyCSS.call(this, cssProps[0], values.join(' '), styles) || hasUserValue;\n        }\n\n        applyAllCSS([...values]);\n\n        function applyCSS(cssProp, cssValue, styles) {\n            if (typeof params.forceStyle !== 'undefined') {\n                this.$target[0].style.setProperty(cssProp, cssValue, params.forceStyle);\n                return true;\n            }\n\n            if (!weUtils.areCssValuesEqual(styles.getPropertyValue(cssProp), cssValue, cssProp, this.$target[0])) {\n                this.$target[0].style.setProperty(cssProp, cssValue);\n                // If change had no effect then make it important.\n                // This condition requires extraClass to be set.\n                if (!params.preventImportant && !weUtils.areCssValuesEqual(\n                        styles.getPropertyValue(cssProp), cssValue, cssProp, this.$target[0])) {\n                    this.$target[0].style.setProperty(cssProp, cssValue, 'important');\n                }\n                return true;\n            }\n            return false;\n        }\n\n        if (params.extraClass) {\n            this.$target.toggleClass(params.extraClass, hasUserValue);\n            if (hasUserValue) {\n                // Might have changed because of the class.\n                for (const cssProp of cssProps) {\n                    this.$target[0].style.removeProperty(cssProp);\n                }\n                applyAllCSS(values);\n            }\n        }\n\n        _restoreTransitions();\n    },\n    /**\n     * Sets a color combination.\n     *\n     * @see this.selectClass for parameters\n     */\n    async selectColorCombination(previewMode, widgetValue, params) {\n        if (params.colorNames) {\n            const names = params.colorNames.filter(weUtils.isColorCombinationName);\n            const classes = weUtils.computeColorClasses(names);\n            this.$target[0].classList.remove(...classes);\n\n            if (widgetValue) {\n                this.$target[0].classList.add('o_cc', `o_cc${widgetValue}`);\n            }\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * Override the helper method to search inside the $target element instead\n     * of the UI item element.\n     *\n     * @override\n     */\n    $: function () {\n        return this.$target.find.apply(this.$target, arguments);\n    },\n    /**\n     * Closes all user value widgets.\n     */\n    closeWidgets: function () {\n        this._userValueWidgets.forEach(widget => widget.close());\n    },\n    /**\n     * @param {string} name\n     * @returns {UserValueWidget|null}\n     */\n    findWidget: function (name) {\n        for (const widget of this._userValueWidgets) {\n            if (widget.getName() === name) {\n                return widget;\n            }\n            const depWidget = widget.findWidget(name);\n            if (depWidget) {\n                return depWidget;\n            }\n        }\n        return null;\n    },\n    /**\n     * Sometimes, options may need to notify other options, even in parent\n     * editors. This can be done thanks to the 'option_update' event, which\n     * will then be handled by this function.\n     *\n     * @param {string} name - an identifier for a type of update\n     * @param {*} data\n     */\n    notify: function (name, data) {\n        // We prefer to avoid refactoring this notify mechanism to make it\n        // asynchronous because the upcoming conversion to owl might remove it.\n        if (name === 'target') {\n            this.setTarget(data);\n        }\n    },\n    /**\n     * Sometimes, an option is binded on an element but should in fact apply on\n     * another one. For example, elements which contain slides: we want all the\n     * per-slide options to be in the main menu of the whole snippet. This\n     * function allows to set the option's target.\n     *\n     * Note: the UI is not updated accordindly automatically.\n     *\n     * @param {jQuery} $target - the new target element\n     * @returns {Promise}\n     */\n    setTarget: function ($target) {\n        this.$target = $target;\n    },\n    /**\n     * Updates the UI. For widget update, @see _computeWidgetState.\n     *\n     * @param {boolean} [noVisibility=false]\n     *     If true, only update widget values and their UI, not their visibility\n     *     -> @see updateUIVisibility for toggling visibility only\n     * @param {boolean} [assetsChanged=false]\n     *     If true, widgets might prefer to _rerenderXML instead of calling\n     *     this super implementation\n     * @returns {Promise}\n     */\n    async updateUI({noVisibility, assetsChanged} = {}) {\n        // For each widget, for each of their option method, notify to the\n        // widget the current value they should hold according to the $target's\n        // current state, related for that method.\n        const proms = this._userValueWidgets.map(async widget => {\n            // Update widget value (for each method)\n            const methodsNames = widget.getMethodsNames();\n            for (const methodName of methodsNames) {\n                const params = widget.getMethodsParams(methodName);\n\n                let obj = this;\n                if (params.applyTo) {\n                    const $firstSubTarget = this.$(params.applyTo).eq(0);\n                    if (!$firstSubTarget.length) {\n                        continue;\n                    }\n                    obj = createPropertyProxy(this, '$target', $firstSubTarget);\n                }\n\n                const value = await this._computeWidgetState.call(obj, methodName, params);\n                if (value === undefined) {\n                    continue;\n                }\n                const normalizedValue = this._normalizeWidgetValue(value);\n                await widget.setValue(normalizedValue, methodName);\n            }\n        });\n        await Promise.all(proms);\n\n        if (!noVisibility) {\n            await this.updateUIVisibility();\n        }\n    },\n    /**\n     * Updates the UI visibility - @see _computeVisibility. For widget update,\n     * @see _computeWidgetVisibility.\n     *\n     * @returns {Promise}\n     */\n    updateUIVisibility: async function () {\n        const proms = this._userValueWidgets.map(async widget => {\n            const params = widget.getMethodsParams();\n\n            let obj = this;\n            if (params.applyTo) {\n                const $firstSubTarget = this.$(params.applyTo).eq(0);\n                if (!$firstSubTarget.length) {\n                    widget.toggleVisibility(false);\n                    return;\n                }\n                obj = createPropertyProxy(this, '$target', $firstSubTarget);\n            }\n\n            // Make sure to check the visibility of all sub-widgets. For\n            // simplicity and efficiency, those will be checked with main\n            // widgets params.\n            const allSubWidgets = [widget];\n            let i = 0;\n            while (i < allSubWidgets.length) {\n                allSubWidgets.push(...allSubWidgets[i]._userValueWidgets);\n                i++;\n            }\n            const proms = allSubWidgets.map(async widget => {\n                const show = await this._computeWidgetVisibility.call(obj, widget.getName(), params);\n                if (!show) {\n                    widget.toggleVisibility(false);\n                    return;\n                }\n\n                const dependencies = widget.getDependencies();\n\n                if (dependencies.length === 1 && dependencies[0] === 'fake') {\n                    widget.toggleVisibility(false);\n                    return;\n                }\n\n                const dependenciesData = [];\n                dependencies.forEach(depName => {\n                    const toBeActive = (depName[0] !== '!');\n                    if (!toBeActive) {\n                        depName = depName.substr(1);\n                    }\n\n                    const widget = this._requestUserValueWidgets(depName, true)[0];\n                    if (widget) {\n                        dependenciesData.push({\n                            widget: widget,\n                            toBeActive: toBeActive,\n                        });\n                    }\n                });\n                const dependenciesOK = !dependenciesData.length || dependenciesData.some(depData => {\n                    return (depData.widget.isActive() === depData.toBeActive);\n                });\n\n                widget.toggleVisibility(dependenciesOK);\n            });\n            return Promise.all(proms);\n        });\n\n        const showUI = await this._computeVisibility();\n        this.el.classList.toggle('d-none', !showUI);\n\n        await Promise.all(proms);\n\n        // Hide layouting elements which contains only hidden widgets\n        // TODO improve this, this is hackish to rely on DOM structure here.\n        // Layouting elements should be handled as widgets or other.\n        for (const el of this.$el.find('we-row')) {\n            const $userValueWidget = $(el).find('> div > .o_we_user_value_widget');\n            el.classList.toggle('d-none', $userValueWidget.length && !$userValueWidget.not('.d-none').length);\n        }\n        for (const el of this.$el.find('we-collapse')) {\n            const $el = $(el);\n            el.classList.toggle('d-none', $el.children().first().hasClass('d-none'));\n            const hasNoVisibleElInCollapseMenu = !$el.children().last().children().not('.d-none').length;\n            if (hasNoVisibleElInCollapseMenu) {\n                this._toggleCollapseEl(el, false);\n            }\n            el.querySelector('.o_we_collapse_toggler').classList.toggle('d-none', hasNoVisibleElInCollapseMenu);\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @private\n     * @param {UserValueWidget[]} widgets\n     * @returns {Promise<string>}\n     */\n    async _checkIfWidgetsUpdateNeedWarning(widgets) {\n        const messages = [];\n        for (const widget of widgets) {\n            const message = widget.getMethodsParams().warnMessage;\n            if (message) {\n                messages.push(message);\n            }\n        }\n        return messages.join(' ');\n    },\n    /**\n     * @private\n     * @param {UserValueWidget[]} widgets\n     * @returns {Promise<boolean|string>}\n     */\n    async _checkIfWidgetsUpdateNeedReload(widgets) {\n        return false;\n    },\n    /**\n     * @private\n     * @returns {Promise<boolean>|boolean}\n     */\n    _computeVisibility: async function () {\n        return true;\n    },\n    /**\n     * Returns the string value that should be hold by the widget which is\n     * related to the given method name.\n     *\n     * If the value is irrelevant for a method, it must return undefined.\n     *\n     * @private\n     * @param {string} methodName\n     * @param {Object} params\n     * @returns {Promise<string|undefined>|string|undefined}\n     */\n    _computeWidgetState: async function (methodName, params) {\n        switch (methodName) {\n            case 'selectClass': {\n                let maxNbClasses = 0;\n                let activeClassNames = '';\n                for (const classNames of params.possibleValues) {\n                    if (!classNames) {\n                        continue;\n                    }\n                    const classes = classNames.split(/\\s+/g);\n                    if (params.stateToFirstClass) {\n                        if (this.$target[0].classList.contains(classes[0])) {\n                            return classNames;\n                        } else {\n                            continue;\n                        }\n                    }\n\n                    if (classes.length >= maxNbClasses\n                            && classes.every(className => this.$target[0].classList.contains(className))) {\n                        maxNbClasses = classes.length;\n                        activeClassNames = classNames;\n                    }\n                }\n                return activeClassNames;\n            }\n            case 'selectAttribute':\n            case 'selectDataAttribute': {\n                const attrName = params.attributeName;\n                let attrValue;\n                if (methodName === 'selectAttribute') {\n                    attrValue = this.$target[0].getAttribute(attrName);\n                } else if (methodName === 'selectDataAttribute') {\n                    attrValue = this.$target[0].dataset[attrName];\n                }\n                attrValue = (attrValue || '').trim();\n                if (params.saveUnit && !params.withUnit) {\n                    attrValue = attrValue.split(/\\s+/g).map(v => v + params.saveUnit).join(' ');\n                }\n                return attrValue || params.attributeDefaultValue || '';\n            }\n            case 'selectStyle': {\n                let usedCC = undefined;\n                if (params.colorPrefix && params.colorNames) {\n                    for (const c of params.colorNames) {\n                        const className = weUtils.computeColorClasses([c], params.colorPrefix)[0];\n                        if (this.$target[0].classList.contains(className)) {\n                            if (weUtils.isColorCombinationName(c)) {\n                                usedCC = c;\n                                continue;\n                            }\n                            return c;\n                        }\n                    }\n                }\n\n                // Disable all transitions for the duration of the style check\n                // as we want to know the final value of a property to properly\n                // update the UI.\n                this.$target[0].classList.add('o_we_force_no_transition');\n                const _restoreTransitions = () => this.$target[0].classList.remove('o_we_force_no_transition');\n\n                const styles = window.getComputedStyle(this.$target[0]);\n\n                if (params.withGradients && params.cssProperty === 'background-color') {\n                    // Check if there is a gradient, in that case this is the\n                    // value to be returned, we normally not allow color and\n                    // gradient at the same time (the option would remove one\n                    // if editing the other).\n                    const parts = backgroundImageCssToParts(styles['background-image']);\n                    if (parts.gradient) {\n                        _restoreTransitions();\n                        return parts.gradient;\n                    }\n                }\n\n                const cssProps = weUtils.CSS_SHORTHANDS[params.cssProperty] || [params.cssProperty];\n                const borderWidthCssProps = weUtils.CSS_SHORTHANDS['border-width'];\n                const cssValues = cssProps.map(cssProp => {\n                    let value = styles.getPropertyValue(cssProp).trim();\n                    if (cssProp === 'box-shadow') {\n                        const inset = value.includes('inset');\n                        let values = value.replace(/,\\s/g, ',').replace('inset', '').trim().split(/\\s+/g);\n                        const color = values.find(s => !s.match(/^\\d/));\n                        values = values.join(' ').replace(color, '').trim();\n                        value = `${color} ${values}${inset ? ' inset' : ''}`;\n                    }\n                    if (borderWidthCssProps.includes(cssProp) && value.endsWith('px')) {\n                        // Rounding value up avoids zoom-in issues.\n                        // Zoom-out issues are not an expected use case.\n                        value = `${Math.ceil(parseFloat(value))}px`;\n                    }\n                    return value;\n                });\n                if (cssValues.length === 4 && weUtils.areCssValuesEqual(cssValues[3], cssValues[1], params.cssProperty, this.$target)) {\n                    cssValues.pop();\n                }\n                if (cssValues.length === 3 && weUtils.areCssValuesEqual(cssValues[2], cssValues[0], params.cssProperty, this.$target)) {\n                    cssValues.pop();\n                }\n                if (cssValues.length === 2 && weUtils.areCssValuesEqual(cssValues[1], cssValues[0], params.cssProperty, this.$target)) {\n                    cssValues.pop();\n                }\n\n                _restoreTransitions();\n\n                const value = cssValues.join(' ');\n\n                if (params.cssProperty === 'background-color' && params.withCombinations) {\n                    if (usedCC) {\n                        const ccValue = weUtils.getCSSVariableValue(`o-cc${usedCC}-bg`).trim();\n                        if (weUtils.areCssValuesEqual(value, ccValue)) {\n                            // Prevent to consider that a color is used as CC\n                            // override in case that color is the same as the\n                            // one used in that CC.\n                            return '';\n                        }\n                    } else {\n                        const rgba = convertCSSColorToRgba(value);\n                        if (rgba && rgba.opacity < 0.001) {\n                            // Prevent to consider a transparent color is\n                            // applied as background unless it is to override a\n                            // CC. Simply allows to add a CC on a transparent\n                            // snippet in the first place.\n                            return '';\n                        }\n                    }\n                }\n                // When the default color is the target's \"currentColor\", the\n                // value should be handled correctly by the option.\n                if (value === \"currentColor\") {\n                    return styles.color;\n                }\n\n                return value;\n            }\n            case 'selectColorCombination': {\n                if (params.colorNames) {\n                    for (const c of params.colorNames) {\n                        if (!weUtils.isColorCombinationName(c)) {\n                            continue;\n                        }\n                        const className = weUtils.computeColorClasses([c])[0];\n                        if (this.$target[0].classList.contains(className)) {\n                            return c;\n                        }\n                    }\n                }\n                return '';\n            }\n        }\n    },\n    /**\n     * @private\n     * @param {string} widgetName\n     * @param {Object} params\n     * @returns {Promise<boolean>|boolean}\n     */\n    _computeWidgetVisibility: async function (widgetName, params) {\n        return true;\n    },\n    /**\n     * @private\n     * @param {HTMLElement} el\n     * @returns {Object}\n     */\n    _extraInfoFromDescriptionElement: function (el) {\n        return {\n            title: el.getAttribute('string'),\n            options: {\n                classes: el.classList,\n                dataAttributes: el.dataset,\n                tooltip: el.title,\n                placeholder: el.getAttribute('placeholder'),\n                childNodes: [...el.childNodes],\n            },\n        };\n    },\n    /**\n     * @private\n     * @param {*}\n     * @returns {string}\n     */\n    _normalizeWidgetValue: function (value) {\n        value = `${value}`.trim(); // Force to a trimmed string\n        value = normalizeCSSColor(value); // If is a css color, normalize it\n        return value;\n    },\n    /**\n     * @private\n     * @param {HTMLElement} uiFragment\n     * @returns {Promise}\n     */\n    _renderCustomWidgets: function (uiFragment) {\n        return Promise.resolve();\n    },\n    /**\n     * @private\n     * @param {HTMLElement} uiFragment\n     * @returns {Promise}\n     */\n    _renderCustomXML: function (uiFragment) {\n        return Promise.resolve();\n    },\n    /**\n     * @private\n     * @param {jQuery} [$xml] - default to original xml content\n     * @returns {Promise}\n     */\n    _renderOriginalXML: async function ($xml) {\n        const uiFragment = document.createDocumentFragment();\n        ($xml || this.$originalUIElements).clone(true).appendTo(uiFragment);\n\n        await this._renderCustomXML(uiFragment);\n\n        // Build layouting components first\n        for (const [itemName, build] of [['we-row', _buildRowElement], ['we-collapse', _buildCollapseElement]]) {\n            uiFragment.querySelectorAll(itemName).forEach(el => {\n                const infos = this._extraInfoFromDescriptionElement(el);\n                const groupEl = build(infos.title, infos.options);\n                el.parentNode.insertBefore(groupEl, el);\n                el.parentNode.removeChild(el);\n            });\n        }\n\n        // Load widgets\n        await this._renderXMLWidgets(uiFragment);\n        await this._renderCustomWidgets(uiFragment);\n\n        if (this.isDestroyed()) {\n            // TODO there is probably better to do. This case was found only in\n            // tours, where the editor is left before the widget are fully\n            // loaded (loadMethodsData doesn't work if the widget is destroyed).\n            return uiFragment;\n        }\n\n        const validMethodNames = [];\n        for (const key in this) {\n            validMethodNames.push(key);\n        }\n        this._userValueWidgets.forEach(widget => {\n            widget.loadMethodsData(validMethodNames);\n        });\n\n        return uiFragment;\n    },\n    /**\n     * @private\n     * @param {HTMLElement} parentEl\n     * @param {SnippetOptionWidget|UserValueWidget} parentWidget\n     * @returns {Promise}\n     */\n    _renderXMLWidgets: function (parentEl, parentWidget) {\n        const proms = [...parentEl.children].map(el => {\n            const widgetName = el.tagName.toLowerCase();\n            if (!userValueWidgetsRegistry.hasOwnProperty(widgetName)) {\n                return this._renderXMLWidgets(el, parentWidget);\n            }\n\n            const infos = this._extraInfoFromDescriptionElement(el);\n            const widget = registerUserValueWidget(widgetName, parentWidget || this, infos.title, infos.options, this.$target);\n            return widget.insertAfter(el).then(() => {\n                // Remove the original element afterwards as the insertion\n                // operation may move some of its inner content during\n                // widget start.\n                parentEl.removeChild(el);\n\n                if (widget.isContainer() && !widget.isDestroyed()) {\n                    return this._renderXMLWidgets(widget.el, widget);\n                }\n            });\n        });\n        return Promise.all(proms);\n    },\n    /**\n     * @private\n     * @param {...string} widgetNames\n     * @param {boolean} [allowParentOption=false]\n     * @returns {UserValueWidget[]}\n     */\n    _requestUserValueWidgets: function (...args) {\n        const widgetNames = args;\n        let allowParentOption = false;\n        const lastArg = args[args.length - 1];\n        if (typeof lastArg === 'boolean') {\n            widgetNames.pop();\n            allowParentOption = lastArg;\n        }\n\n        const widgets = [];\n        for (const widgetName of widgetNames) {\n            let widget = null;\n            this.trigger_up('user_value_widget_request', {\n                name: widgetName,\n                onSuccess: _widget => widget = _widget,\n                allowParentOption: allowParentOption,\n            });\n            if (widget) {\n                widgets.push(widget);\n            }\n        }\n        return widgets;\n    },\n    /**\n     * @private\n     * @param {function<Promise<jQuery>>} [callback]\n     * @returns {Promise}\n     */\n    _rerenderXML: async function (callback) {\n        this._userValueWidgets.forEach(widget => widget.destroy());\n        this._userValueWidgets = [];\n        this.$el.empty();\n\n        let $xml = undefined;\n        if (callback) {\n            $xml = await callback.call(this);\n        }\n\n        return this._renderOriginalXML($xml).then(uiFragment => {\n            this.$el.append(uiFragment);\n            return this.updateUI();\n        });\n    },\n    /**\n     * Activates the option associated to the given DOM element.\n     *\n     * @private\n     * @param {boolean|string} previewMode\n     *        - truthy if the option is enabled for preview or if leaving it (in\n     *          that second case, the value is 'reset')\n     *        - false if the option should be activated for good\n     * @param {UserValueWidget} widget - the widget which triggered the option change\n     * @returns {Promise}\n     */\n    _select: async function (previewMode, widget) {\n        let $applyTo = null;\n\n        if (previewMode === true) {\n            this.options.wysiwyg.odooEditor.automaticStepUnactive('preview_option');\n        }\n\n        // Call each option method sequentially\n        for (const methodName of widget.getMethodsNames()) {\n            const widgetValue = widget.getValue(methodName);\n            const params = widget.getMethodsParams(methodName);\n\n            if (params.applyTo) {\n                if (!$applyTo) {\n                    $applyTo = this.$(params.applyTo);\n                }\n                const proms = Array.from($applyTo).map((subTargetEl) => {\n                    const proxy = createPropertyProxy(this, '$target', $(subTargetEl));\n                    return this[methodName].call(proxy, previewMode, widgetValue, params);\n                });\n                await Promise.all(proms);\n            } else {\n                await this[methodName](previewMode, widgetValue, params);\n            }\n        }\n\n        if (previewMode === 'reset' || previewMode === false) {\n            this.options.wysiwyg.odooEditor.automaticStepActive('preview_option');\n        }\n\n        // We trigger the event on elements targeted by apply-to if any as\n        // this.$target could not be in an editable element while the elements\n        // targeted by apply-to are.\n        ($applyTo || this.$target).trigger('content_changed');\n    },\n    /**\n     * Used to handle attribute or data attribute value change\n     *\n     * @see this._selectValueHelper for parameters\n     */\n    _selectAttributeHelper(value, params) {\n        if (!params.attributeName) {\n            throw new Error('Attribute name missing');\n        }\n        return this._selectValueHelper(value, params);\n    },\n    /**\n     * Used to handle value of a select\n     *\n     * @param {string} value\n     * @param {Object} params\n     * @returns {string|undefined}\n     */\n    _selectValueHelper(value, params) {\n        if (params.saveUnit && !params.withUnit) {\n            // Values that come with an unit are saved without unit as\n            // data-attribute unless told otherwise.\n            value = value.split(params.saveUnit).join('');\n        }\n        if (params.extraClass) {\n            this.$target.toggleClass(params.extraClass, params.defaultValue !== value);\n        }\n        return value;\n    },\n    /**\n     * @private\n     * @param {HTMLElement} collapseEl\n     * @param {boolean|undefined} [show]\n     */\n    _toggleCollapseEl(collapseEl, show) {\n        collapseEl.classList.toggle('active', show);\n        collapseEl.querySelector('we-toggler.o_we_collapse_toggler').classList.toggle('active', show);\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * @private\n     * @param {Event} ev\n     */\n    _onCollapseTogglerClick(ev) {\n        const currentCollapseEl = ev.currentTarget.closest('we-collapse');\n        this._toggleCollapseEl(currentCollapseEl);\n        for (const collapseEl of currentCollapseEl.querySelectorAll('we-collapse')) {\n            this._toggleCollapseEl(collapseEl, false);\n        }\n    },\n    /**\n     * Called when a widget notifies a preview/change/reset.\n     *\n     * @private\n     * @param {Event} ev\n     */\n    _onUserValueUpdate: async function (ev) {\n        ev.stopPropagation();\n        const widget = ev.data.widget;\n        const previewMode = ev.data.previewMode;\n\n        // First check if the updated widget or any of the widgets it triggers\n        // will require a reload or a confirmation choice by the user. If it is\n        // the case, warn the user and potentially ask if he agrees to save its\n        // current changes. If not, just do nothing.\n        let requiresReload = false;\n        if (!ev.data.previewMode && !ev.data.isSimulatedEvent) {\n            const linkedWidgets = this._requestUserValueWidgets(...ev.data.triggerWidgetsNames);\n            const widgets = [ev.data.widget].concat(linkedWidgets);\n\n            const warnMessage = await this._checkIfWidgetsUpdateNeedWarning(widgets);\n            if (warnMessage) {\n                const okWarning = await new Promise(resolve => {\n                    this.dialog.add(ConfirmationDialog, {\n                        body: warnMessage,\n                        confirm: () => resolve(true),\n                        cancel: () => resolve(false),\n                    });\n                });\n                if (!okWarning) {\n                    return;\n                }\n            }\n\n            requiresReload = !!await this._checkIfWidgetsUpdateNeedReload(widgets);\n        }\n\n        // Queue action so that we can later skip useless actions.\n        if (!this._actionQueues.get(widget)) {\n            this._actionQueues.set(widget, []);\n        }\n        const currentAction = {previewMode};\n        this._actionQueues.get(widget).push(currentAction);\n\n        // Ask a mutexed snippet update according to the widget value change\n        const shouldRecordUndo = (!previewMode && !ev.data.isSimulatedEvent);\n        if (shouldRecordUndo) {\n            this.options.wysiwyg.odooEditor.unbreakableStepUnactive();\n        }\n        this.trigger_up('snippet_edition_request', {exec: async () => {\n            // If some previous snippet edition in the mutex removed the target from\n            // the DOM, the widget can be destroyed, in that case the edition request\n            // is now useless and can be discarded.\n            if (this.isDestroyed()) {\n                return;\n            }\n            // Filter actions that are counterbalanced by earlier/later actions\n            const actionQueue = this._actionQueues.get(widget).filter(({previewMode}, i, actions) => {\n                const prev = actions[i - 1];\n                const next = actions[i + 1];\n                if (previewMode === true && next && next.previewMode) {\n                    return false;\n                } else if (previewMode === 'reset' && prev && prev.previewMode) {\n                    return false;\n                }\n                return true;\n            });\n            // Skip action if it's been counterbalanced\n            if (!actionQueue.includes(currentAction)) {\n                this._actionQueues.set(widget, actionQueue);\n                return;\n            }\n            this._actionQueues.set(widget, actionQueue.filter(action => action !== currentAction));\n\n            if (ev.data.prepare) {\n                ev.data.prepare();\n            }\n\n            if (previewMode && (widget.$el.closest('[data-no-preview=\"true\"]').length)) {\n                // TODO the flag should be fetched through widget params somehow\n                return;\n            }\n\n            this.__willReload = requiresReload;\n            // Call widget option methods and update $target\n            await this._select(previewMode, widget);\n            this.__willReload = false;\n\n            // If it is not preview mode, the user selected the option for good\n            // (so record the action)\n            if (shouldRecordUndo) {\n                this.options.wysiwyg.odooEditor.historyStep();\n            }\n\n            if (previewMode || requiresReload) {\n                return;\n            }\n\n            await new Promise(resolve => setTimeout(() => {\n                // Will update the UI of the correct widgets for all options\n                // related to the same $target/editor\n                this.trigger_up('snippet_option_update', {\n                    onSuccess: () => resolve(),\n                });\n            // Set timeout needed so that the user event which triggered the\n            // option can bubble first.\n            }));\n        }});\n\n        if (ev.data.isSimulatedEvent) {\n            // If the user value update was simulated through a trigger, we\n            // prevent triggering further widgets. This could be allowed at some\n            // point but does not work correctly in complex website cases (see\n            // customizeWebsite).\n            return;\n        }\n\n        // Check linked widgets: force their value and simulate a notification\n        // It is possible that we don't have the widget, we continue because a\n        // reload might be needed. For example, change template header without\n        // being on a website.page (e.g: /shop).\n        const linkedWidgets = this._requestUserValueWidgets(...ev.data.triggerWidgetsNames);\n        let i = 0;\n        const triggerWidgetsValues = ev.data.triggerWidgetsValues;\n        for (const linkedWidget of linkedWidgets) {\n            const widgetValue = triggerWidgetsValues[i];\n            if (widgetValue !== undefined) {\n                // FIXME right now only make this work supposing it is a\n                // colorpicker widget with big big hacks, this should be\n                // improved a lot\n                const normValue = this._normalizeWidgetValue(widgetValue);\n                if (previewMode === true) {\n                    linkedWidget._previewColor = normValue;\n                } else if (previewMode === false) {\n                    linkedWidget._previewColor = false;\n                    linkedWidget._value = normValue;\n                } else {\n                    linkedWidget._previewColor = false;\n                }\n            }\n\n            linkedWidget.notifyValueChange(previewMode, true);\n            i++;\n        }\n\n        if (requiresReload) {\n            this.trigger_up('request_save', {\n                reloadEditor: true,\n                optionSelector: this.data.selector,\n                url: this.data.reload,\n            });\n        }\n    },\n    /**\n     * @private\n     */\n    _onUserValueWidgetCritical() {\n        this.trigger_up('remove_snippet', {\n            $snippet: this.$target,\n        });\n    },\n});\nconst registry = {};\n\n//::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::\n\nregistry.sizing = SnippetOptionWidget.extend({\n    displayOverlayOptions: true,\n\n    /**\n     * @override\n     */\n    start: function () {\n        const self = this;\n        const def = this._super.apply(this, arguments);\n        let isMobile = weUtils.isMobileView(this.$target[0]);\n\n        this.$handles = this.$overlay.find('.o_handle');\n\n        let resizeValues = this._getSize();\n        this.$handles.on('mousedown', function (ev) {\n            ev.preventDefault();\n            isMobile = weUtils.isMobileView(self.$target[0]);\n\n            // First update size values as some element sizes may not have been\n            // initialized on option start (hidden slides, etc)\n            resizeValues = self._getSize();\n            const $handle = $(ev.currentTarget);\n\n            let compass = false;\n            let XY = false;\n            if ($handle.hasClass('n')) {\n                compass = 'n';\n                XY = 'Y';\n            } else if ($handle.hasClass('s')) {\n                compass = 's';\n                XY = 'Y';\n            } else if ($handle.hasClass('e')) {\n                compass = 'e';\n                XY = 'X';\n            } else if ($handle.hasClass('w')) {\n                compass = 'w';\n                XY = 'X';\n            } else if ($handle.hasClass('nw')) {\n                compass = 'nw';\n                XY = 'YX';\n            } else if ($handle.hasClass('ne')) {\n                compass = 'ne';\n                XY = 'YX';\n            } else if ($handle.hasClass('sw')) {\n                compass = 'sw';\n                XY = 'YX';\n            } else if ($handle.hasClass('se')) {\n                compass = 'se';\n                XY = 'YX';\n            }\n\n            // Don't call the normal resize methods if we are in a grid and\n            // vice-versa.\n            const isGrid = Object.keys(resizeValues).length === 4;\n            const isGridHandle = $handle[0].classList.contains('o_grid_handle');\n            if (isGrid && !isGridHandle || !isGrid && isGridHandle) {\n                return;\n            }\n\n            let resizeVal;\n            if (compass.length > 1) {\n                resizeVal = [resizeValues[compass[0]], resizeValues[compass[1]]];\n            } else {\n                resizeVal = [resizeValues[compass]];\n            }\n\n            if (resizeVal.some(rV => !rV)) {\n                return;\n            }\n\n            // Locking the mutex during the resize. Started here to avoid\n            // empty returns.\n            let resizeResolve;\n            const prom = new Promise(resolve => resizeResolve = () => resolve());\n            self.trigger_up(\"snippet_edition_request\", { exec: () => {\n                self.trigger_up(\"disable_loading_effect\");\n                return prom;\n            }});\n\n            // If we are in grid mode, add a background grid and place it in\n            // front of the other elements.\n            const rowEl = self.$target[0].parentNode;\n            let backgroundGridEl;\n            if (rowEl.classList.contains(\"o_grid_mode\") && !isMobile) {\n                self.options.wysiwyg.odooEditor.observerUnactive('displayBackgroundGrid');\n                backgroundGridEl = gridUtils._addBackgroundGrid(rowEl, 0);\n                gridUtils._setElementToMaxZindex(backgroundGridEl, rowEl);\n                self.options.wysiwyg.odooEditor.observerActive('displayBackgroundGrid');\n            }\n\n            // For loop to handle the cases where it is ne, nw, se or sw. Since\n            // there are two directions, we compute for both directions and we\n            // store the values in an array.\n            const directions = [];\n            for (const [i, resize] of resizeVal.entries()) {\n                const props = {};\n                let current = 0;\n                const cssProperty = resize[2];\n                const cssPropertyValue = parseInt(self.$target.css(cssProperty));\n                resize[0].forEach((val, key) => {\n                    if (self.$target.hasClass(val)) {\n                        current = key;\n                    } else if (parseInt(resize[1][key]) === cssPropertyValue) {\n                        current = key;\n                    }\n                });\n\n                props.resize = resize;\n                props.current = current;\n                props.begin = current;\n                props.beginClass = self.$target.attr('class');\n                props.regClass = new RegExp('\\\\s*' + resize[0][current].replace(/[-]*[0-9]+/, '[-]*[0-9]+'), 'g');\n                props.xy = ev['page' + XY[i]];\n                props.XY = XY[i];\n                props.compass = compass[i];\n\n                directions.push(props);\n            }\n\n            self.options.wysiwyg.odooEditor.automaticStepUnactive('resizing');\n\n            const cursor = $handle.css('cursor') + '-important';\n            const $iframeWindow = $(this.ownerDocument.defaultView);\n            $iframeWindow[0].document.body.classList.add(cursor);\n            self.$overlay.removeClass('o_handlers_idle');\n\n            const bodyMouseMove = function (ev) {\n                ev.preventDefault();\n\n                let changeTotal = false;\n                for (const dir of directions) {\n                    // dd is the number of pixels by which the mouse moved,\n                    // compared to the initial position of the handle.\n                    const dd = ev['page' + dir.XY] - dir.xy + dir.resize[1][dir.begin];\n                    const next = dir.current + (dir.current + 1 === dir.resize[1].length ? 0 : 1);\n                    const prev = dir.current ? (dir.current - 1) : 0;\n\n                    let change = false;\n                    // If the mouse moved to the right/down by at least 2/3 of\n                    // the space between the previous and the next steps, the\n                    // handle is snapped to the next step and the class is\n                    // replaced by the one matching this step.\n                    if (dd > (2 * dir.resize[1][next] + dir.resize[1][dir.current]) / 3) {\n                        self.$target.attr('class', (self.$target.attr('class') || '').replace(dir.regClass, ''));\n                        self.$target.addClass(dir.resize[0][next]);\n                        dir.current = next;\n                        change = true;\n                    }\n                    // Same as above but to the left/up.\n                    if (prev !== dir.current && dd < (2 * dir.resize[1][prev] + dir.resize[1][dir.current]) / 3) {\n                        self.$target.attr('class', (self.$target.attr('class') || '').replace(dir.regClass, ''));\n                        self.$target.addClass(dir.resize[0][prev]);\n                        dir.current = prev;\n                        change = true;\n                    }\n\n                    if (change) {\n                        self._onResize(dir.compass, dir.beginClass, dir.current);\n                    }\n\n                    changeTotal = changeTotal || change;\n                }\n\n                if (changeTotal) {\n                    self.trigger_up('cover_update');\n                    $handle.addClass('o_active');\n                }\n            };\n            const bodyMouseUp = function () {\n                $iframeWindow.off(\"mousemove\", bodyMouseMove);\n                $iframeWindow.off(\"mouseup\", bodyMouseUp);\n                $iframeWindow[0].document.body.classList.remove(cursor);\n                self.$overlay.addClass('o_handlers_idle');\n                $handle.removeClass('o_active');\n\n                // If we are in grid mode, removes the background grid.\n                // Also sync the col-* class with the g-col-* class so the\n                // toggle to normal mode and the mobile view are well done.\n                if (rowEl.classList.contains(\"o_grid_mode\") && !isMobile) {\n                    self.options.wysiwyg.odooEditor.observerUnactive('displayBackgroundGrid');\n                    backgroundGridEl.remove();\n                    self.options.wysiwyg.odooEditor.observerActive('displayBackgroundGrid');\n                    gridUtils._resizeGrid(rowEl);\n\n                    const colClass = [...self.$target[0].classList].find(c => /^col-/.test(c));\n                    const gColClass = [...self.$target[0].classList].find(c => /^g-col-/.test(c));\n                    self.$target[0].classList.remove(colClass);\n                    self.$target[0].classList.add(gColClass.substring(2));\n                }\n\n                self.options.wysiwyg.odooEditor.automaticStepActive('resizing');\n\n                // Freeing the mutex once the resizing is done.\n                resizeResolve();\n                self.trigger_up(\"enable_loading_effect\");\n\n                if (directions.every(dir => dir.begin === dir.current)) {\n                    return;\n                }\n\n                setTimeout(function () {\n                    self.options.wysiwyg.odooEditor.historyStep();\n\n                    self.trigger_up(\"snippet_edition_request\", { exec: async () => {\n                        await new Promise(resolve => {\n                            self.trigger_up(\"snippet_option_update\", { onSuccess: () => resolve() });\n                        });\n                    }});\n                }, 0);\n            };\n            $iframeWindow.on(\"mousemove\", bodyMouseMove);\n            $iframeWindow.on(\"mouseup\", bodyMouseUp);\n        });\n\n        for (const [key, value] of Object.entries(resizeValues)) {\n            this.$handles.filter('.' + key).toggleClass('readonly', !value);\n        }\n        if (!isMobile && this.$target[0].classList.contains(\"o_grid_item\")) {\n            this.$handles.filter('.o_grid_handle').toggleClass('readonly', false);\n        }\n\n        return def;\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    async updateUI() {\n        this._updateSizingHandles();\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    setTarget: function () {\n        this._super(...arguments);\n        // TODO master: _onResize should not be called here, need to check if\n        // updateUI is called when the target is changed\n        this._onResize();\n    },\n    /**\n     * @override\n     */\n    async updateUIVisibility() {\n        await this._super(...arguments);\n\n        const isMobileView = weUtils.isMobileView(this.$target[0]);\n        const isGridOn = this.$target[0].classList.contains(\"o_grid_item\");\n        const isGrid = !isMobileView && isGridOn;\n        if (this.$target[0].parentNode && this.$target[0].parentNode.classList.contains('row')) {\n            // Hiding/showing the correct resize handles if we are in grid mode\n            // or not.\n            for (const handleEl of this.$handles) {\n                const isGridHandle = handleEl.classList.contains('o_grid_handle');\n                handleEl.classList.toggle('d-none', isGrid ^ isGridHandle);\n                // Disabling the vertical resize if we are in mobile view.\n                const isVerticalSizing = handleEl.matches('.n, .s');\n                handleEl.classList.toggle(\"readonly\", isMobileView && isVerticalSizing && isGridOn);\n            }\n\n            // Hiding the move handle in mobile view so we can't drag the\n            // columns.\n            const moveHandleEl = this.$overlay[0].querySelector('.o_move_handle');\n            moveHandleEl.classList.toggle('d-none', isMobileView);\n\n            // Show/hide the buttons to send back/front a grid item.\n            const bringFrontBackEls = this.$overlay[0].querySelectorAll('.o_front_back');\n            bringFrontBackEls.forEach(button => button.classList.toggle(\"d-none\", !isGrid));\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Returns an object mapping one or several cardinal direction (n, e, s, w)\n     * to an Array containing:\n     * 1) A list of classes to toggle when using this cardinal direction\n     * 2) A list of values these classes are supposed to set on a given CSS prop\n     * 3) The mentioned CSS prop\n     *\n     * Note: this object must also be saved in this.grid before being returned.\n     *\n     * @abstract\n     * @private\n     * @returns {Object}\n     */\n    _getSize: function () {},\n    /**\n     * Called when the snippet is being resized and its classes changes.\n     *\n     * @private\n     * @param {string} [compass] - resize direction ('n', 's', 'e' or 'w')\n     * @param {string} [beginClass] - attributes class at the beginning\n     * @param {integer} [current] - current increment in this.grid\n     */\n    _onResize: function (compass, beginClass, current) {\n        this._updateSizingHandles();\n        this._notifyResizeChange();\n    },\n    /**\n     * @private\n     */\n    _updateSizingHandles: function () {\n        var self = this;\n\n        // Adapt the resize handles according to the classes and dimensions\n        var resizeValues = this._getSize();\n        var $handles = this.$overlay.find('.o_handle');\n        for (const [direction, resizeValue] of Object.entries(resizeValues)) {\n            var classes = resizeValue[0];\n            var values = resizeValue[1];\n            var cssProperty = resizeValue[2];\n\n            var $handle = $handles.filter('.' + direction);\n\n            var current = 0;\n            var cssPropertyValue = parseInt(self.$target.css(cssProperty));\n            classes.forEach((className, key) => {\n                if (self.$target.hasClass(className)) {\n                    current = key;\n                } else if (values[key] === cssPropertyValue) {\n                    current = key;\n                }\n            });\n\n            $handle.toggleClass('o_handle_start', current === 0);\n            $handle.toggleClass('o_handle_end', current === classes.length - 1);\n        }\n\n        // Adapt the handles to fit top and bottom sizes\n        this.$overlay.find('.o_handle:not(.o_grid_handle)').filter(\".n, .s\").toArray().forEach(handle => {\n            var $handle = $(handle);\n            var direction = $handle.hasClass('n') ? 'top' : 'bottom';\n            $handle.outerHeight(self.$target.css('padding-' + direction));\n        });\n    },\n    /**\n     * @override\n     */\n    async _notifyResizeChange() {\n        this.$target.trigger('content_changed');\n    },\n});\n\n/**\n * Handles the edition of padding-top and padding-bottom.\n */\nregistry['sizing_y'] = registry.sizing.extend({\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _getSize: function () {\n        var nClass = 'pt';\n        var nProp = 'padding-top';\n        var sClass = 'pb';\n        var sProp = 'padding-bottom';\n        if (this.$target.is('hr')) {\n            nClass = 'mt';\n            nProp = 'margin-top';\n            sClass = 'mb';\n            sProp = 'margin-bottom';\n        }\n\n        var grid = [];\n        for (var i = 0; i <= (256 / 8); i++) {\n            grid.push(i * 8);\n        }\n        grid.splice(1, 0, 4);\n        this.grid = {\n            n: [grid.map(v => nClass + v), grid, nProp],\n            s: [grid.map(v => sClass + v), grid, sProp],\n        };\n        return this.grid;\n    },\n});\nregistry['sizing_x'] = registry.sizing.extend({\n    /**\n     * @override\n     */\n    onClone: function (options) {\n        this._super.apply(this, arguments);\n        // Below condition is added to remove offset of target element only\n        // and not its children to avoid design alteration of a container/block.\n        if (options.isCurrent) {\n            const targetClassList = this.$target[0].classList;\n            const offsetClasses = [...targetClassList]\n                .filter(cls => cls.match(/^offset-(lg-)?([0-9]{1,2})$/));\n            targetClassList.remove(...offsetClasses);\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _getSize: function () {\n        const isMobileView = weUtils.isMobileView(this.$target[0]);\n        const resolutionModifier = isMobileView ? \"\" : \"lg-\";\n        var width = this.$target.closest('.row').width();\n        var gridE = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n        var gridW = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n        this.grid = {\n            e: [\n                gridE.map(v => (`col-${resolutionModifier}${v}`)),\n                gridE.map(v => width / 12 * v),\n                \"width\",\n            ],\n            w: [\n                gridW.map(v => (`offset-${resolutionModifier}${v}`)),\n                gridW.map(v => width / 12 * v),\n                \"margin-left\",\n            ],\n        };\n        return this.grid;\n    },\n    /**\n     * @override\n     */\n    _onResize: function (compass, beginClass, current) {\n        const targetEl = this.$target[0];\n        const isMobileView = weUtils.isMobileView(targetEl);\n        const resolutionModifier = isMobileView ? \"\" : \"lg-\";\n\n        if (compass === 'w' || compass === 'e') {\n            // (?!\\S): following char cannot be a non-space character\n            const offsetRegex = new RegExp(`(?:^|\\\\s+)offset-${resolutionModifier}(\\\\d{1,2})(?!\\\\S)`);\n            const colRegex = new RegExp(`(?:^|\\\\s+)col-${resolutionModifier}(\\\\d{1,2})(?!\\\\S)`);\n\n            const beginOffset = Number(beginClass.match(offsetRegex)?.[1] || 0);\n\n            if (compass === 'w') {\n                // don't change the right border position when we change the offset (replace col size)\n                const beginCol = Number(beginClass.match(colRegex)?.[1] || 12);\n                let offset = Number(this.grid.w[0][current].match(offsetRegex)?.[1] || 0);\n                if (offset < 0) {\n                    offset = 0;\n                }\n                let colSize = beginCol - (offset - beginOffset);\n                if (colSize <= 0) {\n                    colSize = 1;\n                    offset = beginOffset + beginCol - 1;\n                }\n                const offsetColRegex = new RegExp(`${offsetRegex.source}|${colRegex.source}`, \"g\");\n                targetEl.className = targetEl.className.replace(offsetColRegex, \"\");\n                targetEl.classList.add(`col-${resolutionModifier}${colSize > 12 ? 12 : colSize}`);\n\n                if (offset > 0) {\n                    targetEl.classList.add(`offset-${resolutionModifier}${offset}`);\n                }\n                if (isMobileView && offset === 0) {\n                    targetEl.classList.remove(\"offset-lg-0\");\n                } else if ((isMobileView && offset > 0 &&\n                        !targetEl.className.match(/(^|\\s+)offset-lg-\\d{1,2}(?!\\S)/)) ||\n                        (!isMobileView && offset === 0 &&\n                        targetEl.className.match(/(^|\\s+)offset-\\d{1,2}(?!\\S)/))) {\n                    targetEl.classList.add(\"offset-lg-0\");\n                }\n            } else if (beginOffset > 0) {\n                const endCol = Number(this.grid.e[0][current].match(colRegex)?.[1] || 0);\n                // Avoids overflowing the grid to the right if the\n                // column size + the offset exceeds 12.\n                if ((endCol + beginOffset) > 12) {\n                    targetEl.className = targetEl.className.replace(colRegex, \"\");\n                    targetEl.classList.add(`col-${resolutionModifier}${12 - beginOffset}`);\n                }\n            }\n        }\n        this._super.apply(this, arguments);\n    },\n    /**\n     * @override\n     */\n    async _notifyResizeChange() {\n        this.trigger_up('option_update', {\n            optionName: 'StepsConnector',\n            name: 'change_column_size',\n        });\n        this._super.apply(this, arguments);\n    },\n});\n\n/**\n * Handles the sizing in grid mode: edition of grid-{column|row}-{start|end}.\n */\nregistry['sizing_grid'] = registry.sizing.extend({\n    /**\n     * @override\n     */\n    _getSize() {\n        const rowEl = this.$target.closest('.row')[0];\n        const gridProp = gridUtils._getGridProperties(rowEl);\n\n        const rowStart = this.$target[0].style.gridRowStart;\n        const rowEnd = parseInt(this.$target[0].style.gridRowEnd);\n        const columnStart = this.$target[0].style.gridColumnStart;\n        const columnEnd = this.$target[0].style.gridColumnEnd;\n\n        const gridN = [];\n        const gridS = [];\n        for (let i = 1; i < rowEnd + 12; i++) {\n            gridN.push(i);\n            gridS.push(i + 1);\n        }\n        const gridW = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n        const gridE = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];\n\n        this.grid = {\n            n: [gridN.map(v => ('g-height-' + (rowEnd - v))), gridN.map(v => ((gridProp.rowSize + gridProp.rowGap) * (v - 1))), 'grid-row-start'],\n            s: [gridS.map(v => ('g-height-' + (v - rowStart))), gridS.map(v => ((gridProp.rowSize + gridProp.rowGap) * (v - 1))), 'grid-row-end'],\n            w: [gridW.map(v => ('g-col-lg-' + (columnEnd - v))), gridW.map(v => ((gridProp.columnSize + gridProp.columnGap) * (v - 1))), 'grid-column-start'],\n            e: [gridE.map(v => ('g-col-lg-' + (v - columnStart))), gridE.map(v => ((gridProp.columnSize + gridProp.columnGap) * (v - 1))), 'grid-column-end'],\n        };\n\n        return this.grid;\n    },\n    /**\n     * @override\n     */\n    _onResize(compass, beginClass, current) {\n        if (compass === 'n') {\n            const rowEnd = parseInt(this.$target[0].style.gridRowEnd);\n            if (current < 0) {\n                this.$target[0].style.gridRowStart = 1;\n            } else if (current + 1 >= rowEnd) {\n                this.$target[0].style.gridRowStart = rowEnd - 1;\n            } else {\n                this.$target[0].style.gridRowStart = current + 1;\n            }\n        } else if (compass === 's') {\n            const rowStart = parseInt(this.$target[0].style.gridRowStart);\n            const rowEnd = parseInt(this.$target[0].style.gridRowEnd);\n            if (current + 2 <= rowStart) {\n                this.$target[0].style.gridRowEnd = rowStart + 1;\n            } else {\n                this.$target[0].style.gridRowEnd = current + 2;\n            }\n\n            // Updating the grid height.\n            const rowEl = this.$target[0].parentNode;\n            const rowCount = parseInt(rowEl.dataset.rowCount);\n            const backgroundGridEl = rowEl.querySelector('.o_we_background_grid');\n            const backgroundGridRowEnd = parseInt(backgroundGridEl.style.gridRowEnd);\n            let rowMove = 0;\n            if (this.$target[0].style.gridRowEnd > rowEnd && this.$target[0].style.gridRowEnd > rowCount + 1) {\n                rowMove = this.$target[0].style.gridRowEnd - rowEnd;\n            } else if (this.$target[0].style.gridRowEnd < rowEnd && this.$target[0].style.gridRowEnd >= rowCount + 1) {\n                rowMove = this.$target[0].style.gridRowEnd - rowEnd;\n            }\n            backgroundGridEl.style.gridRowEnd = backgroundGridRowEnd + rowMove;\n        } else if (compass === 'w') {\n            const columnEnd = parseInt(this.$target[0].style.gridColumnEnd);\n            if (current < 0) {\n                this.$target[0].style.gridColumnStart = 1;\n            } else if (current + 1 >= columnEnd) {\n                this.$target[0].style.gridColumnStart = columnEnd - 1;\n            } else {\n                this.$target[0].style.gridColumnStart = current + 1;\n            }\n        } else if (compass === 'e') {\n            const columnStart = parseInt(this.$target[0].style.gridColumnStart);\n            if (current + 2 > 13) {\n                this.$target[0].style.gridColumnEnd = 13;\n            } else if (current + 2 <= columnStart) {\n                this.$target[0].style.gridColumnEnd = columnStart + 1;\n            } else {\n                this.$target[0].style.gridColumnEnd = current + 2;\n            }\n        }\n\n        if (compass === 'n' || compass === 's') {\n            const numberRows = this.$target[0].style.gridRowEnd - this.$target[0].style.gridRowStart;\n            this.$target.attr('class', this.$target.attr('class').replace(/\\s*(g-height-)([0-9-]+)/g, ''));\n            this.$target.addClass('g-height-' + numberRows);\n        }\n\n        if (compass === 'w' || compass === 'e') {\n            const numberColumns = this.$target[0].style.gridColumnEnd - this.$target[0].style.gridColumnStart;\n            this.$target.attr('class', this.$target.attr('class').replace(/\\s*(g-col-lg-)([0-9-]+)/g, ''));\n            this.$target.addClass('g-col-lg-' + numberColumns);\n        }\n    },\n});\n\n/**\n * Controls box properties.\n */\nregistry.Box = SnippetOptionWidget.extend({\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * TODO this should be reviewed in master to avoid the need of using the\n     * 'reset' previewMode and having to remember the previous box-shadow value.\n     * We are forced to remember the previous box shadow before applying a new\n     * one as the whole box-shadow value is handled by multiple widgets.\n     *\n     * @see this.selectClass for parameters\n     */\n    async setShadow(previewMode, widgetValue, params) {\n        // Check if the currently configured shadow is not using the same shadow\n        // mode, in which case nothing has to be done.\n        const styles = window.getComputedStyle(this.$target[0]);\n        const currentBoxShadow = styles['box-shadow'] || 'none';\n        const currentMode = currentBoxShadow === 'none'\n            ? ''\n            : currentBoxShadow.includes('inset') ? 'inset' : 'outset';\n        if (currentMode === widgetValue) {\n            return;\n        }\n\n        if (previewMode === true) {\n            this._prevBoxShadow = currentBoxShadow;\n        }\n\n        // Add/remove the shadow class\n        this.$target.toggleClass(params.shadowClass, !!widgetValue);\n\n        // Change the mode of the old box shadow. If no shadow was currently\n        // set then get the shadow value that is supposed to be set according\n        // to the shadow mode. Try to apply it via the selectStyle method so\n        // that it is either ignored because the shadow class had its effect or\n        // forced (to the shadow value or none) if toggling the class is not\n        // enough (e.g. if the item has a default shadow coming from CSS rules,\n        // removing the shadow class won't be enough to remove the shadow but in\n        // most other cases it will).\n        let shadow = 'none';\n        if (previewMode === 'reset') {\n            shadow = this._prevBoxShadow;\n        } else {\n            if (currentBoxShadow === 'none') {\n                shadow = this._getDefaultShadow(widgetValue, params.shadowClass);\n            } else {\n                if (widgetValue === 'outset') {\n                    shadow = currentBoxShadow.replace('inset', '').trim();\n                } else if (widgetValue === 'inset') {\n                    shadow = currentBoxShadow + ' inset';\n                }\n            }\n        }\n        await this.selectStyle(previewMode, shadow, Object.assign({cssProperty: 'box-shadow'}, params));\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _computeWidgetState(methodName, params) {\n        if (methodName === 'setShadow') {\n            const shadowValue = this.$target.css('box-shadow');\n            if (!shadowValue || shadowValue === 'none') {\n                return '';\n            }\n            return this.$target.css('box-shadow').includes('inset') ? 'inset' : 'outset';\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    async _computeWidgetVisibility(widgetName, params) {\n        if (widgetName === 'fake_inset_shadow_opt') {\n            return false;\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * @private\n     * @param {string} type\n     * @param {string} shadowClass\n     * @returns {string}\n     */\n    _getDefaultShadow(type, shadowClass) {\n        if (!type) {\n            return 'none';\n        }\n\n        const el = document.createElement('div');\n        el.classList.add(shadowClass);\n        document.body.appendChild(el);\n        const shadow = `${$(el).css('box-shadow')}${type === 'inset' ? ' inset' : ''}`;\n        el.remove();\n        return shadow;\n    },\n});\n\n\n\nregistry.layout_column = SnippetOptionWidget.extend(ColumnLayoutMixin, {\n    /**\n     * @override\n     */\n    cleanUI() {\n        this._removeGridPreview();\n    },\n    /**\n     * @override\n     */\n    notify(name) {\n        // TODO: left in stable for compatibility. Remove this in master.\n        if (name === \"change_column_size\") {\n            this.updateUI();\n        }\n        this._super(...arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * Changes the number of columns.\n     *\n     * @see this.selectClass for parameters\n     */\n    selectCount: async function (previewMode, widgetValue, params) {\n        // Make sure the \"Custom\" option is read-only.\n        if (widgetValue === \"custom\") {\n            return;\n        }\n        const previousNbColumns = this.$('> .row').children().length;\n        let $row = this.$('> .row');\n        if (!$row.length) {\n            const restoreCursor = preserveCursor(this.$target[0].ownerDocument);\n            resetOuids(this.$target[0]);\n            $row = this.$target.contents().wrapAll($('<div class=\"row\"><div class=\"col-lg-12\"/></div>')).parent().parent();\n            restoreCursor();\n        }\n\n        const nbColumns = parseInt(widgetValue);\n        await this._updateColumnCount($row[0], (nbColumns || 1));\n        // Yield UI thread to wait for event to bubble before activate_snippet is called.\n        // In this case this lets the select handle the click event before we switch snippet.\n        // TODO: make this more generic in activate_snippet event handler.\n        await new Promise(resolve => setTimeout(resolve));\n        if (nbColumns === 0) {\n            const restoreCursor = preserveCursor(this.$target[0].ownerDocument);\n            resetOuids($row[0]);\n            $row.contents().unwrap().contents().unwrap();\n            restoreCursor();\n            this.trigger_up('activate_snippet', {$snippet: this.$target});\n        } else if (previousNbColumns === 0) {\n            this.trigger_up('activate_snippet', {$snippet: this.$('> .row').children().first()});\n        }\n        this.trigger_up('option_update', {\n            optionName: 'StepsConnector',\n            name: 'change_columns',\n        });\n    },\n    /**\n     * Changes the layout (columns or grid).\n     *\n     * @see this.selectClass for parameters\n     */\n    async selectLayout(previewMode, widgetValue, params) {\n        if (widgetValue === \"grid\") {\n            const rowEl = this.$target[0].querySelector('.row');\n            if (!rowEl || !rowEl.classList.contains('o_grid_mode')) { // Prevent toggling grid mode twice.\n                gridUtils._toggleGridMode(this.$target[0]);\n                this.trigger_up('activate_snippet', {$snippet: this.$target});\n            }\n        } else {\n            // Toggle normal mode only if grid mode was activated (as it's in\n            // normal mode by default).\n            const rowEl = this.$target[0].querySelector('.row');\n            if (rowEl && rowEl.classList.contains('o_grid_mode')) {\n                this._toggleNormalMode(rowEl);\n                this.trigger_up('activate_snippet', {$snippet: this.$target});\n            }\n        }\n        this.trigger_up('option_update', {\n            optionName: 'StepsConnector',\n            name: 'change_columns',\n        });\n    },\n    /**\n     * Adds an image, some text or a button in the grid.\n     *\n     * @see this.selectClass for parameters\n     */\n    async addElement(previewMode, widgetValue, params) {\n        const rowEl = this.$target[0].querySelector('.row');\n        const elementType = widgetValue;\n\n        // If it has been less than 15 seconds that we have added an element,\n        // shift the new element right and down by one cell. Otherwise, put it\n        // on the top left corner.\n        const currentTime = new Date().getTime();\n        if (this.lastAddTime && (currentTime - this.lastAddTime) / 1000 < 15) {\n            this.lastStartPosition = [this.lastStartPosition[0] + 1, this.lastStartPosition[1] + 1];\n        } else {\n            this.lastStartPosition = [1, 1]; // [rowStart, columnStart]\n        }\n        this.lastAddTime = currentTime;\n\n        // Create the new column.\n        const newColumnEl = document.createElement('div');\n        newColumnEl.classList.add('o_grid_item');\n        let numberColumns, numberRows;\n\n        if (elementType === 'image') {\n            // Set the columns properties.\n            newColumnEl.classList.add('col-lg-6', 'g-col-lg-6', 'g-height-6', 'o_grid_item_image');\n            numberColumns = 6;\n            numberRows = 6;\n\n            // Create a default image and add it to the new column.\n            const imgEl = document.createElement('img');\n            imgEl.classList.add('img', 'img-fluid', 'mx-auto');\n            imgEl.src = '/web/image/website.s_text_image_default_image';\n            imgEl.alt = '';\n            imgEl.loading = 'lazy';\n\n            newColumnEl.appendChild(imgEl);\n        } else if (elementType === 'text') {\n            newColumnEl.classList.add('col-lg-4', 'g-col-lg-4', 'g-height-2');\n            numberColumns = 4;\n            numberRows = 2;\n\n            // Create default text content.\n            const pEl = document.createElement('p');\n            pEl.classList.add('o_default_snippet_text');\n            pEl.textContent = _t(\"Write something...\");\n\n            newColumnEl.appendChild(pEl);\n        } else if (elementType === 'button') {\n            newColumnEl.classList.add('col-lg-2', 'g-col-lg-2', 'g-height-1');\n            numberColumns = 2;\n            numberRows = 1;\n\n            // Create default button.\n            const aEl = document.createElement('a');\n            aEl.href = '#';\n            aEl.classList.add('mb-2', 'btn', 'btn-primary');\n            aEl.textContent = \"Button\";\n\n            newColumnEl.appendChild(aEl);\n        }\n        // Place the column in the grid.\n        const rowStart = this.lastStartPosition[0];\n        let columnStart = this.lastStartPosition[1];\n        if (columnStart + numberColumns > 13) {\n            columnStart = 1;\n            this.lastStartPosition[1] = columnStart;\n        }\n        newColumnEl.style.gridArea = `${rowStart} / ${columnStart} / ${rowStart + numberRows} / ${columnStart + numberColumns}`;\n\n        // Setting the z-index to the maximum of the grid.\n        gridUtils._setElementToMaxZindex(newColumnEl, rowEl);\n\n        // Add the new column and update the grid height.\n        rowEl.appendChild(newColumnEl);\n        gridUtils._resizeGrid(rowEl);\n\n        // Scroll to the new column if more than half of it is hidden (= out of\n        // the viewport or hidden by an other element).\n        const newColumnPosition = newColumnEl.getBoundingClientRect();\n        const middleX = (newColumnPosition.left + newColumnPosition.right) / 2;\n        const middleY = (newColumnPosition.top + newColumnPosition.bottom) / 2;\n        const sameCoordinatesEl = this.ownerDocument.elementFromPoint(middleX, middleY);\n        if (!sameCoordinatesEl || !newColumnEl.contains(sameCoordinatesEl)) {\n            newColumnEl.scrollIntoView({behavior: \"smooth\", block: \"center\"});\n        }\n        this.trigger_up('activate_snippet', {$snippet: $(newColumnEl)});\n    },\n    /**\n     * @override\n     */\n    async selectStyle(previewMode, widgetValue, params) {\n        await this._super(previewMode, widgetValue, params);\n\n        const rowEl = this.$target[0];\n        const isMobileView = weUtils.isMobileView(rowEl);\n        if ([\"row-gap\", \"column-gap\"].includes(params.cssProperty) && !isMobileView) {\n            // Reset the animation.\n            this._removeGridPreview();\n            void rowEl.offsetWidth; // Trigger a DOM reflow.\n\n            // Add an animated grid preview.\n            this.options.wysiwyg.odooEditor.observerUnactive(\"addGridPreview\");\n            this.gridPreviewEl = gridUtils._addBackgroundGrid(rowEl, 0);\n            this.gridPreviewEl.classList.add(\"o_we_grid_preview\");\n            gridUtils._setElementToMaxZindex(this.gridPreviewEl, rowEl);\n            this.options.wysiwyg.odooEditor.observerActive(\"addGridPreview\");\n            this.removeGridPreview = this._removeGridPreview.bind(this);\n            rowEl.addEventListener(\"animationend\", this.removeGridPreview);\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _computeWidgetState: function (methodName, params) {\n        if (methodName === 'selectCount') {\n            const isMobile = this._isMobile();\n            const columnEls = this.$target[0].querySelector(\":scope > .row\")?.children;\n            return this._getNbColumns(columnEls, isMobile);\n        } else if (methodName === 'selectLayout') {\n            const rowEl = this.$target[0].querySelector('.row');\n            if (rowEl && rowEl.classList.contains('o_grid_mode')) {\n                return \"grid\";\n            } else {\n                return 'normal';\n            }\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    _computeWidgetVisibility(widgetName, params) {\n        if (widgetName === 'zero_cols_opt') {\n            // Note: \"s_allow_columns\" indicates containers which may have\n            // bare content (without columns) and are allowed to have columns.\n            // By extension, we only show the \"None\" option on elements that\n            // were marked as such as they were allowed to have bare content in\n            // the first place.\n            return this.$target.is('.s_allow_columns');\n        } else if (widgetName === \"column_count_opt\") {\n            // Hide the selectCount widget if the `s_nb_column_fixed` class is\n            // on the row.\n            return !this.$target[0].querySelector(\":scope > .row.s_nb_column_fixed\");\n        } else if (widgetName === \"custom_cols_opt\") {\n            // Show \"Custom\" if the user altered the columns in some way (i.e.\n            // by adding offsets or resizing a column). This is only shown as\n            // an indication, but shouldn't be selectable.\n            const isMobile = this._isMobile();\n            return this.$target[0].querySelector(\":scope > .row\") &&\n                this._areColsCustomized(this.$target[0].querySelector(\":scope > .row\").children,\n                isMobile);\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * If the number of columns requested is greater than the number of items,\n     * adds new columns which are clones of the last one. If there are less\n     * columns than the number of items, reorganizes the elements on the right\n     * amount of rows.\n     *\n     * @private\n     * @param {HTMLElement} rowEl - the row in which to update the columns\n     * @param {integer} nbColumns - the number of columns requested\n     */\n    async _updateColumnCount(rowEl, nbColumns) {\n        const isMobile = this._isMobile();\n        // The number of elements per row before the update.\n        const prevNbColumns = this._getNbColumns(rowEl.children, isMobile);\n\n        if (nbColumns === prevNbColumns) {\n            return;\n        }\n        this._resizeColumns(rowEl.children, nbColumns);\n\n        const itemsDelta = nbColumns - rowEl.children.length;\n        if (itemsDelta > 0) {\n            const newItems = [];\n            for (let i = 0; i < itemsDelta; i++) {\n                const lastEl = rowEl.lastElementChild;\n                newItems.push(new Promise(resolve => {\n                    this.trigger_up(\"clone_snippet\", {$snippet: $(lastEl), onSuccess: resolve});\n                }));\n            }\n            await Promise.all(newItems);\n        }\n\n        this.trigger_up('cover_update');\n    },\n    /**\n     * Resizes the columns for the mobile or desktop view.\n     *\n     * @private\n     * @param {HTMLCollection} columnEls - the elements to resize\n     * @param {integer} nbColumns - the number of wanted columns\n     */\n    _resizeColumns(columnEls, nbColumns) {\n        const isMobile = this._isMobile();\n        const itemSize = Math.floor(12 / nbColumns) || 1;\n        const firstItem = this._getFirstItem(columnEls, isMobile);\n        const firstItemOffset = Math.floor((12 - itemSize * nbColumns) / 2);\n\n        const resolutionModifier = isMobile ? \"\" : \"-lg\";\n        const replacingRegex =\n            // (?!\\S): following char cannot be a non-space character\n            new RegExp(`(?:^|\\\\s+)(col|offset)${resolutionModifier}(-\\\\d{1,2})?(?!\\\\S)`, \"g\");\n\n        for (const columnEl of columnEls) {\n            columnEl.className = columnEl.className.replace(replacingRegex, \"\");\n            columnEl.classList.add(`col${resolutionModifier}-${itemSize}`);\n\n            if (firstItemOffset && columnEl === firstItem) {\n                columnEl.classList.add(`offset${resolutionModifier}-${firstItemOffset}`);\n            }\n            const hasMobileOffset = columnEl.className.match(/(^|\\s+)offset-\\d{1,2}(?!\\S)/);\n            const hasDesktopOffset = columnEl.className.match(/(^|\\s+)offset-lg-[1-9][0-1]?(?!\\S)/);\n            columnEl.classList.toggle(\"offset-lg-0\", hasMobileOffset && !hasDesktopOffset);\n        }\n    },\n    /**\n     * Toggles the normal mode.\n     *\n     * @private\n     * @param {Element} rowEl\n     */\n    async _toggleNormalMode(rowEl) {\n        // Removing the grid class\n        rowEl.classList.remove('o_grid_mode');\n        const columnEls = rowEl.children;\n        // Removing the grid previews (if any).\n        await new Promise(resolve => {\n            this.trigger_up(\"clean_ui_request\", {\n                targetEl: this.$target[0].closest(\"section\"),\n                onSuccess: resolve,\n            });\n        });\n\n        for (const columnEl of columnEls) {\n            // Reloading the images.\n            gridUtils._reloadLazyImages(columnEl);\n            // Removing the grid properties.\n            gridUtils._convertToNormalColumn(columnEl);\n        }\n        // Removing the grid properties.\n        delete rowEl.dataset.rowCount;\n        // Kept for compatibility.\n        rowEl.style.removeProperty('--grid-item-padding-x');\n        rowEl.style.removeProperty('--grid-item-padding-y');\n        rowEl.style.removeProperty(\"gap\");\n    },\n    /**\n     * Removes the grid preview that was added when changing the grid gaps.\n     *\n     * @private\n     */\n    _removeGridPreview() {\n        this.options.wysiwyg.odooEditor.observerUnactive(\"removeGridPreview\");\n        this.$target[0].removeEventListener(\"animationend\", this.removeGridPreview);\n        if (this.gridPreviewEl) {\n            this.gridPreviewEl.remove();\n            delete this.gridPreviewEl;\n        }\n        delete this.removeGridPreview;\n        this.options.wysiwyg.odooEditor.observerActive(\"removeGridPreview\");\n    },\n    /**\n     * @returns {boolean}\n     */\n    _isMobile() {\n        return weUtils.isMobileView(this.$target[0]);\n    },\n});\n\nregistry.GridColumns = SnippetOptionWidget.extend({\n    /**\n     * @override\n     */\n    cleanUI() {\n        // Remove the padding highlights.\n        this._removePaddingPreview();\n    },\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    async selectStyle(previewMode, widgetValue, params) {\n        await this._super(...arguments);\n        if ([\"--grid-item-padding-y\", \"--grid-item-padding-x\"].includes(params.cssProperty)) {\n            // Reset the animation.\n            this._removePaddingPreview();\n            void this.$target[0].offsetWidth; // Trigger a DOM reflow.\n\n            // Highlight the padding when changing it, by adding a pseudo-\n            // element with an animated colored border inside the grid item.\n            this.options.wysiwyg.odooEditor.observerUnactive(\"addPaddingPreview\");\n            this.$target[0].classList.add(\"o_we_padding_highlight\");\n            this.options.wysiwyg.odooEditor.observerActive(\"addPaddingPreview\");\n            this.removePaddingPreview = this._removePaddingPreview.bind(this);\n            this.$target[0].addEventListener(\"animationend\", this.removePaddingPreview);\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _computeWidgetVisibility(widgetName, params) {\n        if ([\"grid_padding_y_opt\", \"grid_padding_x_opt\"].includes(widgetName)) {\n            return this.$target[0].parentElement.classList.contains(\"o_grid_mode\");\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * Removes the padding highlights that were added when changing the grid\n     * item padding.\n     *\n     * @private\n     */\n    _removePaddingPreview() {\n        this.options.wysiwyg.odooEditor.observerUnactive(\"removePaddingPreview\");\n        this.$target[0].removeEventListener(\"animationend\", this.removePaddingPreview);\n        this.$target[0].classList.remove(\"o_we_padding_highlight\");\n        delete this.removePaddingPreview;\n        this.options.wysiwyg.odooEditor.observerActive(\"removePaddingPreview\");\n    },\n});\n\nregistry.vAlignment = SnippetOptionWidget.extend({\n    /**\n     * @override\n     */\n    async _computeWidgetState(methodName, params) {\n        const value = await this._super(...arguments);\n        if (methodName === 'selectClass' && !value) {\n            // If there is no `align-items-` class on the row, then the `align-\n            // items-stretch` class is selected, because the behaviors are\n            // equivalent in both situations.\n            return 'align-items-stretch';\n        }\n        return value;\n    },\n});\n\n/**\n * Allows snippets to be moved before the preceding element or after the following.\n */\nregistry.SnippetMove = SnippetOptionWidget.extend(ColumnLayoutMixin, {\n    displayOverlayOptions: true,\n\n    /**\n     * @override\n     */\n    start: function () {\n        var $buttons = this.$el.find('we-button');\n        var $overlayArea = this.$overlay.find('.o_overlay_move_options');\n        // Putting the arrows side by side.\n        $overlayArea.prepend($buttons[1]);\n        $overlayArea.prepend($buttons[0]);\n\n        // Needed for compatibility (with already dropped snippets).\n        const parentEl = this.$target[0].parentElement;\n        if (parentEl.classList.contains(\"row\")) {\n            const columnEls = [...parentEl.children];\n            let orderedColumnEls = columnEls.filter(el => el.style.order);\n\n            // TODO: remove in master once handled by a migration script.\n            // If there is no inline order, make sure that any existing order\n            // class is replaced with inline CSS.\n            if (!orderedColumnEls.length) {\n                for (const el of columnEls) {\n                    const orderClass = el.className.match(/(^|\\s+)(?<cls>order-(?<ord>[0-9]+))(?!\\S)/);\n                    if (orderClass) {\n                        el.classList.remove(orderClass.groups.cls);\n                        el.style.order = orderClass.groups.ord;\n                        orderedColumnEls.push(el);\n                    }\n                }\n            }\n\n            // If the target is a column, check if all the columns are either\n            // mobile ordered or not. If they are not consistent, then we remove\n            // the mobile order classes from all of them, to avoid issues.\n            if (orderedColumnEls.length && orderedColumnEls.length !== columnEls.length) {\n                this._removeMobileOrders(orderedColumnEls);\n            }\n        }\n\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    onClone(options) {\n        this._super.apply(this, arguments);\n        const mobileOrder = this.$target[0].style.order;\n        // If the order has been adapted on mobile, it must be different\n        // for each clone.\n        if (options.isCurrent && mobileOrder) {\n            const siblingEls = this.$target[0].parentElement.children;\n            const cloneEls = [...siblingEls].filter(el => el.style.order === mobileOrder);\n            // For cases in which multiple clones are made at the same time, we\n            // change the order for all clones at once. (e.g.: it happens when\n            // increasing the columns count.) This makes sure the clones get a\n            // mobile order in line with their DOM order.\n            cloneEls.forEach((el, i) => {\n                if (i > 0) {\n                    el.style.order = siblingEls.length - cloneEls.length + i;\n                }\n            });\n        }\n    },\n    /**\n     * @override\n     */\n    onMove() {\n        this._super.apply(this, arguments);\n        // Remove all the mobile order classes after a drag and drop.\n        this._removeMobileOrders(this.$target[0].parentElement.children);\n    },\n    /**\n     * @override\n     */\n    onRemove() {\n        this._super.apply(this, arguments);\n        const targetMobileOrder = this.$target[0].style.order;\n        // If the order has been adapted on mobile, the gap created by the\n        // removed snippet must be filled in.\n        if (targetMobileOrder) {\n            const targetOrder = parseInt(targetMobileOrder);\n            this._fillRemovedItemGap(this.$target[0].parentElement, targetOrder);\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * Moves the snippet around.\n     *\n     * @see this.selectClass for parameters\n     */\n    moveSnippet: function (previewMode, widgetValue, params) {\n        const isMobile = this._isMobile();\n        const isNavItem = this.$target[0].classList.contains('nav-item');\n        const $tabPane = isNavItem ? $(this.$target.find('.nav-link')[0].hash) : null;\n        const moveLeftOrRight = [\"move_left_opt\", \"move_right_opt\"].includes(params.name);\n\n        let siblingEls, mobileOrder;\n        if (moveLeftOrRight) {\n            siblingEls = this.$target[0].parentElement.children;\n            mobileOrder = !!this.$target[0].style.order;\n        }\n        if (moveLeftOrRight && isMobile && !isNavItem) {\n            if (!mobileOrder) {\n                this._addMobileOrders(siblingEls);\n            }\n            this._swapMobileOrders(widgetValue, siblingEls);\n        } else {\n            switch (widgetValue) {\n                case \"prev\": {\n                    // Consider only visible elements.\n                    let prevEl = this.$target[0].previousElementSibling;\n                    while (prevEl && window.getComputedStyle(prevEl).display === \"none\") {\n                        prevEl = prevEl.previousElementSibling;\n                    }\n                    prevEl?.insertAdjacentElement(\"beforebegin\", this.$target[0]);\n                    if (isNavItem) {\n                        $tabPane.prev().before($tabPane);\n                    }\n                    break;\n                }\n                case \"next\": {\n                    // Consider only visible elements.\n                    let nextEl = this.$target[0].nextElementSibling;\n                    while (nextEl && window.getComputedStyle(nextEl).display === \"none\") {\n                        nextEl = nextEl.nextElementSibling;\n                    }\n                    nextEl?.insertAdjacentElement(\"afterend\", this.$target[0]);\n                    if (isNavItem) {\n                        $tabPane.next().after($tabPane);\n                    }\n                    break;\n                }\n            }\n            if (mobileOrder) {\n                this._removeMobileOrders(siblingEls);\n            }\n        }\n        if (!this.$target.is(this.data.noScroll)\n                && (params.name === 'move_up_opt' || params.name === 'move_down_opt')) {\n            const mainScrollingEl = $().getScrollingElement()[0];\n            const elTop = this.$target[0].getBoundingClientRect().top;\n            const heightDiff = mainScrollingEl.offsetHeight - this.$target[0].offsetHeight;\n            const bottomHidden = heightDiff < elTop;\n            const hidden = elTop < 0 || bottomHidden;\n            if (hidden) {\n                dom.scrollTo(this.$target[0], {\n                    extraOffset: 50,\n                    forcedOffset: bottomHidden ? heightDiff - 50 : undefined,\n                    easing: 'linear',\n                    duration: 500,\n                });\n            }\n        }\n        this.trigger_up('option_update', {\n            optionName: 'StepsConnector',\n            name: 'move_snippet',\n        });\n        // Update the \"Invisible Elements\" panel as the order of invisible\n        // snippets could have changed on the page.\n        this.trigger_up(\"update_invisible_dom\");\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    async _computeWidgetVisibility(widgetName, params) {\n        const moveUpOrLeft = widgetName === \"move_up_opt\" || widgetName === \"move_left_opt\";\n        const moveDownOrRight = widgetName === \"move_down_opt\" || widgetName === \"move_right_opt\";\n        const moveLeftOrRight = widgetName === \"move_left_opt\" || widgetName === \"move_right_opt\";\n\n        if (moveUpOrLeft || moveDownOrRight) {\n            // The arrows are not displayed if the target is in a grid and if\n            // not in mobile view.\n            const isMobileView = weUtils.isMobileView(this.$target[0]);\n            if (!isMobileView && this.$target[0].classList.contains(\"o_grid_item\")) {\n                return false;\n            }\n            // On mobile, items' reordering is independent from desktop inside\n            // a snippet (left or right), not at a higher level (up or down).\n            if (moveLeftOrRight && isMobileView) {\n                const targetMobileOrder = this.$target[0].style.order;\n                if (targetMobileOrder) {\n                    const siblingEls = this.$target[0].parentElement.children;\n                    const orderModifier = widgetName === \"move_left_opt\" ? -1 : 1;\n                    let delta = 0;\n                    while (true) {\n                        delta += orderModifier;\n                        const nextOrder = parseInt(targetMobileOrder) + delta;\n                        const siblingEl = [...siblingEls].find(el => el.style.order === nextOrder.toString());\n                        if (!siblingEl) {\n                            break;\n                        }\n                        if (window.getComputedStyle(siblingEl).display === \"none\") {\n                            continue;\n                        }\n                        return true;\n                    }\n                    return false;\n                }\n            }\n            // Consider only visible elements.\n            const direction = moveUpOrLeft ? \"previousElementSibling\" : \"nextElementSibling\";\n            let siblingEl = this.$target[0][direction];\n            while (siblingEl && window.getComputedStyle(siblingEl).display === \"none\") {\n                siblingEl = siblingEl[direction];\n            }\n            return !!siblingEl;\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * Swaps the mobile orders.\n     *\n     * @param {string} widgetValue\n     * @param {HTMLCollection} siblingEls\n     */\n    _swapMobileOrders(widgetValue, siblingEls) {\n        const targetMobileOrder = this.$target[0].style.order;\n        const orderModifier = widgetValue === \"prev\" ? -1 : 1;\n        let delta = 0;\n        while (true) {\n            delta += orderModifier;\n            const newOrder = parseInt(targetMobileOrder) + delta;\n            const comparedEl = [...siblingEls].find(el => el.style.order === newOrder.toString());\n            // TODO In master: remove break.\n            if (!comparedEl) {\n                break;\n            }\n            if (window.getComputedStyle(comparedEl).display === \"none\") {\n                continue;\n            }\n            this.$target[0].style.order = newOrder;\n            comparedEl.style.order = targetMobileOrder;\n            break;\n        }\n    },\n    /**\n     * @returns {Boolean}\n     */\n    _isMobile() {\n        return false;\n    },\n});\n\n/**\n * Allows for media to be replaced.\n */\nregistry.ReplaceMedia = SnippetOptionWidget.extend({\n    init: function () {\n        this._super(...arguments);\n        this._activateLinkTool = this._activateLinkTool.bind(this);\n        this._deactivateLinkTool = this._deactivateLinkTool.bind(this);\n    },\n\n    destroy: function () {\n        this._clearListeners();\n        return this._super(...arguments);\n    },\n\n    /**\n     * @override\n     */\n    onFocus() {\n        this.options.wysiwyg.odooEditor.addEventListener('activate_image_link_tool', this._activateLinkTool);\n        this.options.wysiwyg.odooEditor.addEventListener('deactivate_image_link_tool', this._deactivateLinkTool);\n        // When we start editing an image, rerender the UI to ensure the\n        // we-select that suggests the anchors is in a consistent state.\n        this.rerender = true;\n    },\n    /**\n     * @override\n     */\n    onBlur() {\n        this._clearListeners();\n    },\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * Replaces the media.\n     *\n     * @see this.selectClass for parameters\n     */\n    async replaceMedia() {\n        const sel = this.ownerDocument.getSelection();\n        // Ensure the element is selected before opening the media dialog.\n        if (!sel.rangeCount) {\n            const range = this.ownerDocument.createRange();\n            range.selectNodeContents(this.$target[0]);\n            sel.addRange(range);\n        }\n        // open mediaDialog and replace the media.\n        await this.options.wysiwyg.openMediaDialog({ node:this.$target[0] });\n    },\n    /**\n     * Makes the image a clickable link by wrapping it in an <a>.\n     * This function is also called for the opposite operation.\n     *\n     * @see this.selectClass for parameters\n     */\n    setLink(previewMode, widgetValue, params) {\n        const parentEl = this._searchSupportedParentLinkEl();\n        if (parentEl.tagName !== 'A') {\n            const wrapperEl = document.createElement('a');\n            this.$target[0].after(wrapperEl);\n            wrapperEl.appendChild(this.$target[0]);\n            // TODO Remove when bug fixed in Chrome.\n            if (this.$target[0].getBoundingClientRect().width === 0) {\n                // Chrome lost lazy-loaded image => Force Chrome to display image.\n                const src = this.$target[0].src;\n                this.$target[0].src = '';\n                this.$target[0].src = src;\n            }\n        } else {\n            const fragment = document.createDocumentFragment();\n            fragment.append(...parentEl.childNodes);\n            parentEl.replaceWith(fragment);\n        }\n    },\n    /**\n     * Changes the image link so that the URL is opened on another tab or not\n     * when it is clicked.\n     *\n     * @see this.selectClass for parameters\n     */\n    setNewWindow(previewMode, widgetValue, params) {\n        const linkEl = this._searchSupportedParentLinkEl();\n        if (widgetValue) {\n            linkEl.setAttribute('target', '_blank');\n        } else {\n            linkEl.removeAttribute('target');\n        }\n    },\n    /**\n     * Records the target url of the hyperlink.\n     *\n     * @see this.selectClass for parameters\n     */\n    setUrl(previewMode, widgetValue, params) {\n        const linkEl = this._searchSupportedParentLinkEl();\n        let url = widgetValue;\n        if (!url) {\n            // As long as there is no URL, the image is not considered a link.\n            linkEl.removeAttribute('href');\n            this.$target.trigger('href_changed');\n            return;\n        }\n        if (!url.startsWith('/') && !url.startsWith('#')\n                && !/^([a-zA-Z]*.):.+$/gm.test(url)) {\n            // We permit every protocol (http:, https:, ftp:, mailto:,...).\n            // If none is explicitly specified, we assume it is a http.\n            url = 'http://' + url;\n        }\n        linkEl.setAttribute('href', url);\n        this.rerender = true;\n        this.$target.trigger('href_changed');\n    },\n    /**\n     * @override\n     */\n    async updateUI() {\n        if (this.rerender) {\n            this.rerender = false;\n            await this._rerenderXML();\n            return;\n        }\n        return this._super.apply(this, arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @private\n     */\n    _activateLinkTool() {\n        const parentEl = this._searchSupportedParentLinkEl();\n        if (parentEl.tagName === 'A') {\n            this._requestUserValueWidgets('media_url_opt')[0].focus();\n        } else {\n            this._requestUserValueWidgets('media_link_opt')[0].enable();\n        }\n    },\n    /**\n     * @private\n     */\n    _clearListeners() {\n        this.options.wysiwyg.odooEditor.removeEventListener('activate_image_link_tool', this._activateLinkTool);\n        this.options.wysiwyg.odooEditor.removeEventListener('deactivate_image_link_tool', this._deactivateLinkTool);\n    },\n    /**\n     * @private\n     */\n    _deactivateLinkTool() {\n        const parentEl = this._searchSupportedParentLinkEl();\n        if (parentEl.tagName === 'A') {\n            this._requestUserValueWidgets('media_link_opt')[0].enable();\n        }\n    },\n    /**\n     * @override\n     */\n    _computeWidgetState(methodName, params) {\n        const parentEl = this._searchSupportedParentLinkEl();\n        const linkEl = parentEl.tagName === 'A' ? parentEl : null;\n        switch (methodName) {\n            case 'setLink': {\n                return linkEl ? 'true' : '';\n            }\n            case 'setUrl': {\n                let href = linkEl ? linkEl.getAttribute('href') : '';\n                return href || '';\n            }\n            case 'setNewWindow': {\n                const target = linkEl ? linkEl.getAttribute('target') : '';\n                return target && target === '_blank' ? 'true' : '';\n            }\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    async _computeWidgetVisibility(widgetName, params) {\n        if (widgetName === 'media_link_opt') {\n            if (this.$target[0].matches('img')) {\n                return isImageSupportedForStyle(this.$target[0])\n                    && !this._searchSupportedParentLinkEl().matches(\"a[data-oe-xpath]\");\n            }\n            return !this.$target[0].classList.contains('media_iframe_video');\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * @private\n     * @returns {Element} The \"closest\" element that can be supported as a <a>.\n     */\n    _searchSupportedParentLinkEl() {\n        const parentEl = this.$target[0].parentElement;\n        return parentEl.matches(\"figure\") ? parentEl.parentElement : parentEl;\n    },\n});\n\n/*\n * Abstract option to be extended by the ImageTools and BackgroundOptimize\n * options that handles all the common parts.\n */\nconst ImageHandlerOption = SnippetOptionWidget.extend({\n    /**\n     * @override\n     */\n    init() {\n        this._super(...arguments);\n        this.rpc = this.bindService(\"rpc\");\n    },\n    /**\n     * @override\n     */\n    async willStart() {\n        const _super = this._super.bind(this);\n        await this._initializeImage();\n        return _super(...arguments);\n    },\n    /**\n     * @override\n     */\n    async start() {\n        await this._super(...arguments);\n        const weightEl = document.createElement('span');\n        weightEl.classList.add('o_we_image_weight', 'o_we_tag', 'd-none');\n        weightEl.title = _t(\"Size\");\n        this.$weight = $(weightEl);\n        // Perform the loading of the image info synchronously in order to\n        // avoid an intermediate rendering of the Blocks tab during the\n        // loadImageInfo RPC that obtains the file size.\n        // This does not update the target.\n        await this._applyOptions(false);\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    async updateUI() {\n        await this._super(...arguments);\n\n        if (this._filesize === undefined) {\n            this.$weight.addClass('d-none');\n            await this._applyOptions(false);\n        }\n        if (this._filesize !== undefined) {\n            this.$weight.text(`${this._filesize.toFixed(1)} kb`);\n            this.$weight.removeClass('d-none');\n            this._relocateWeightEl();\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * @see this.selectClass for parameters\n     */\n    selectFormat(previewMode, widgetValue, params) {\n        const values = widgetValue.split(' ');\n        const image = this._getImg();\n        image.dataset.resizeWidth = values[0];\n        if (image.dataset.shape) {\n            // If the image has a shape, modify its originalMimetype attribute.\n            image.dataset.originalMimetype = values[1];\n        } else {\n            // If the image does not have a shape, modify its mimetype\n            // attribute.\n            image.dataset.mimetype = values[1];\n        }\n        return this._applyOptions();\n    },\n    /**\n     * @see this.selectClass for parameters\n     */\n    async setQuality(previewMode, widgetValue, params) {\n        if (previewMode) {\n            return;\n        }\n        this._getImg().dataset.quality = widgetValue;\n        return this._applyOptions();\n    },\n    /**\n     * @see this.selectClass for parameters\n     */\n    glFilter(previewMode, widgetValue, params) {\n        const dataset = this._getImg().dataset;\n        if (widgetValue) {\n            dataset.glFilter = widgetValue;\n        } else {\n            delete dataset.glFilter;\n        }\n        return this._applyOptions();\n    },\n    /**\n     * @see this.selectClass for parameters\n     */\n    customFilter(previewMode, widgetValue, params) {\n        const img = this._getImg();\n        const {filterOptions} = img.dataset;\n        const {filterProperty} = params;\n        if (filterProperty === 'filterColor') {\n            widgetValue = normalizeColor(widgetValue);\n        }\n        const newOptions = Object.assign(JSON.parse(filterOptions || \"{}\"), {[filterProperty]: widgetValue});\n        img.dataset.filterOptions = JSON.stringify(newOptions);\n        return this._applyOptions();\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _computeVisibility() {\n        const src = this._getImg().getAttribute('src');\n        return src && src !== '/';\n    },\n    /**\n     * @override\n     */\n    async _computeWidgetState(methodName, params) {\n        const img = this._getImg();\n        const _super = this._super.bind(this);\n\n        // Make sure image is loaded because we need its naturalWidth\n        await new Promise((resolve, reject) => {\n            if (img.complete) {\n                resolve();\n                return;\n            }\n            img.addEventListener('load', resolve, {once: true});\n            img.addEventListener('error', resolve, {once: true});\n        });\n\n        switch (methodName) {\n            case 'selectFormat':\n                return img.naturalWidth + ' ' + this._getImageMimetype(img);\n            case 'setFilter':\n                return img.dataset.filter;\n            case 'glFilter':\n                return img.dataset.glFilter || \"\";\n            case 'setQuality':\n                return img.dataset.quality || 75;\n            case 'customFilter': {\n                const {filterProperty} = params;\n                const options = JSON.parse(img.dataset.filterOptions || \"{}\");\n                const defaultValue = filterProperty === 'blend' ? 'normal' : 0;\n                return options[filterProperty] || defaultValue;\n            }\n        }\n        return _super(...arguments);\n    },\n    /**\n     * @abstract\n     */\n    _relocateWeightEl() {},\n    /**\n     * @override\n     */\n    async _renderCustomXML(uiFragment) {\n        const img = this._getImg();\n        if (!this.originalSrc || !this._isImageSupportedForProcessing(img)) {\n            return;\n        }\n        const $select = $(uiFragment).find('we-select[data-name=format_select_opt]');\n        (await this._computeAvailableFormats()).forEach(([value, [label, targetFormat]]) => {\n            $select.append(`<we-button data-select-format=\"${Math.round(value)} ${targetFormat}\" class=\"o_we_badge_at_end\">${label} <span class=\"badge rounded-pill text-bg-dark\">${targetFormat.split('/')[1]}</span></we-button>`);\n        });\n\n        if (!['image/jpeg', 'image/webp'].includes(this._getImageMimetype(img))) {\n            const optQuality = uiFragment.querySelector('we-range[data-set-quality]');\n            if (optQuality) {\n                optQuality.remove();\n            }\n        }\n    },\n    /**\n     * Returns a list of valid formats for a given image or an empty list if\n     * there is no mimetypeBeforeConversion data attribute on the image.\n     *\n     * @private\n     */\n    async _computeAvailableFormats() {\n        if (!this.mimetypeBeforeConversion) {\n            return [];\n        }\n        const img = this._getImg();\n        const original = await loadImage(this.originalSrc);\n        const maxWidth = img.dataset.width ? img.naturalWidth : original.naturalWidth;\n        const optimizedWidth = Math.min(maxWidth, this._computeMaxDisplayWidth());\n        this.optimizedWidth = optimizedWidth;\n        const widths = {\n            128: ['128px', 'image/webp'],\n            256: ['256px', 'image/webp'],\n            512: ['512px', 'image/webp'],\n            1024: ['1024px', 'image/webp'],\n            1920: ['1920px', 'image/webp'],\n        };\n        widths[img.naturalWidth] = [_t(\"%spx\", img.naturalWidth), 'image/webp'];\n        widths[optimizedWidth] = [_t(\"%spx (Suggested)\", optimizedWidth), 'image/webp'];\n        const mimetypeBeforeConversion = img.dataset.mimetypeBeforeConversion;\n        widths[maxWidth] = [_t(\"%spx (Original)\", maxWidth), mimetypeBeforeConversion];\n        if (mimetypeBeforeConversion !== \"image/webp\") {\n            // Avoid a key collision by subtracting 0.1 - putting the webp\n            // above the original format one of the same size.\n            widths[maxWidth - 0.1] = [_t(\"%spx\", maxWidth), 'image/webp'];\n        }\n        return Object.entries(widths)\n            .filter(([width]) => width <= maxWidth)\n            .sort(([v1], [v2]) => v1 - v2);\n    },\n    /**\n     * Applies all selected options on the original image.\n     *\n     * @private\n     * @param {boolean} [update=true] If this is false, this does not actually\n     *     modifies the image but only simulates the modifications on it to\n     *     be able to update the filesize UI.\n     */\n    async _applyOptions(update = true) {\n        const img = this._getImg();\n        if (!update && !(img && img.complete)) {\n            return;\n        }\n        if (!this._isImageSupportedForProcessing(img)) {\n            this.originalId = null;\n            this._filesize = undefined;\n            return;\n        }\n        // Do not apply modifications if there is no original src, since it is\n        // needed for it.\n        if (!img.dataset.originalSrc) {\n            delete img.dataset.mimetype;\n            return;\n        }\n        const dataURL = await applyModifications(img, {mimetype: this._getImageMimetype(img)});\n        this._filesize = getDataURLBinarySize(dataURL) / 1024;\n\n        if (update) {\n            img.classList.add('o_modified_image_to_save');\n            const loadedImg = await loadImage(dataURL, img);\n            this._applyImage(loadedImg);\n            // Also apply to carousel thumbnail if applicable.\n            weUtils.forwardToThumbnail(img);\n            return loadedImg;\n        }\n        return img;\n    },\n    /**\n     * Loads the image's attachment info.\n     *\n     * @private\n     */\n    async _loadImageInfo(attachmentSrc = '') {\n        const img = this._getImg();\n        await loadImageInfo(img, this.rpc, attachmentSrc);\n        if (!img.dataset.originalId) {\n            this.originalId = null;\n            this.originalSrc = null;\n            return;\n        }\n        this.originalId = img.dataset.originalId;\n        this.originalSrc = img.dataset.originalSrc;\n        this.mimetypeBeforeConversion = img.dataset.mimetypeBeforeConversion;\n    },\n    /**\n     * Sets the image's width to its suggested size.\n     *\n     * @private\n     */\n    async _autoOptimizeImage() {\n        await this._loadImageInfo();\n        await this._rerenderXML();\n        const img = this._getImg();\n        if (!['image/gif', 'image/svg+xml'].includes(img.dataset.mimetype)) {\n            // Convert to recommended format and width.\n            img.dataset.mimetype = 'image/webp';\n            img.dataset.resizeWidth = this.optimizedWidth;\n        } else if (img.dataset.shape && img.dataset.originalMimetype !== \"image/gif\") {\n            img.dataset.originalMimetype = \"image/webp\";\n            img.dataset.resizeWidth = this.optimizedWidth;\n        }\n        await this._applyOptions();\n        await this.updateUI();\n    },\n    /**\n     * Returns the image that is currently being modified.\n     *\n     * @private\n     * @abstract\n     * @returns {HTMLImageElement} the image to use for modifications\n     */\n    _getImg() {},\n    /**\n     * Computes the image's maximum display width.\n     *\n     * @private\n     * @abstract\n     * @returns {Int} the maximum width at which the image can be displayed\n     */\n    _computeMaxDisplayWidth() {},\n    /**\n     * Use the processed image when it's needed in the DOM.\n     *\n     * @private\n     * @abstract\n     * @param {HTMLImageElement} img\n     */\n    _applyImage(img) {},\n    /**\n     * @private\n     * @param {HTMLImageElement} img\n     * @returns {String} The right mimetype used to apply options on image.\n     */\n    _getImageMimetype(img) {\n        return img.dataset.mimetype;\n    },\n    /**\n     * @private\n     */\n    async _initializeImage() {\n        return this._loadImageInfo();\n    },\n     /**\n     * @private\n     * @param {HTMLImageElement} img\n     * @param {Boolean} [strict=false]\n     * @returns {Boolean}\n     */\n    _isImageSupportedForProcessing(img, strict = false) {\n        return isImageSupportedForProcessing(this._getImageMimetype(img), strict);\n    },\n    /**\n     * @override\n     */\n    _computeWidgetVisibility(widgetName, params) {\n        if (widgetName === \"format_select_opt\" && !this.mimetypeBeforeConversion) {\n            return false;\n        }\n        if (this._isImageProcessingWidget(widgetName, params)) {\n            const img = this._getImg();\n            return this._isImageSupportedForProcessing(img, true);\n        }\n        return isImageSupportedForStyle(this._getImg());\n    },\n    /**\n     * Indicates if an option should be applied only on supported mimetypes.\n     *\n     * @param {String} widgetName\n     * @param {Object} params\n     * @returns {Boolean}\n     */\n    _isImageProcessingWidget(widgetName, params) {\n        return params.optionsPossibleValues.glFilter\n            || 'customFilter' in params.optionsPossibleValues\n            || params.optionsPossibleValues.setQuality\n            || widgetName === 'format_select_opt';\n    },\n});\n\n/**\n * @param {Element} containerEl\n * @param {boolean} labelIsDimension - Optional display imgsize attribute instead of animated\n * @returns {Element}\n */\nconst _addAnimatedShapeLabel = function addAnimatedShapeLabel(containerEl, labelIsDimension = false) {\n    const labelEl = document.createElement('span');\n    labelEl.classList.add('o_we_shape_animated_label');\n    let labelStr = _t(\"Animated\");\n    const spanEl = document.createElement('span');\n    if (labelIsDimension) {\n        const dimensionIcon = document.createElement('i');\n        labelStr = containerEl.dataset.imgSize;\n        dimensionIcon.classList.add('fa', 'fa-expand');\n        labelEl.append(dimensionIcon);\n        spanEl.textContent = labelStr;\n    } else {\n        labelEl.textContent = labelStr[0];\n        spanEl.textContent = labelStr.substr(1);\n    }\n    labelEl.appendChild(spanEl);\n    containerEl.classList.add('position-relative');\n    containerEl.appendChild(labelEl);\n    return labelEl;\n};\n\n/**\n * Controls image width and quality.\n */\nregistry.ImageTools = ImageHandlerOption.extend({\n    MAX_SUGGESTED_WIDTH: 1920,\n\n    /**\n     * @constructor\n     */\n    init() {\n        this.shapeCache = {};\n        this.rpc = this.bindService(\"rpc\");\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    start() {\n        this.$target.on('image_changed.ImageOptimization', this._onImageChanged.bind(this));\n        this.$target.on('image_cropped.ImageOptimization', this._onImageCropped.bind(this));\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    destroy() {\n        this.$target.off('.ImageOptimization');\n        return this._super(...arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * Displays the image cropping tools\n     *\n     * @see this.selectClass for parameters\n     */\n    async crop() {\n        this.trigger_up('disable_loading_effect');\n        const img = this._getImg();\n        const document = this.$el[0].ownerDocument;\n        const imageCropWrapperElement = document.createElement('div');\n        document.body.append(imageCropWrapperElement);\n\n        // Attach the event listener before attaching the component\n        const cropperPromise = new Promise(resolve => {\n            this.$target.one(\"image_cropper_destroyed\", async () => {\n                if (isGif(this._getImageMimetype(img))) {\n                    img.dataset[img.dataset.shape ? \"originalMimetype\" : \"mimetype\"] = \"image/png\";\n                }\n                await this._reapplyCurrentShape();\n                resolve();\n            });\n        });\n\n        const imageCropWrapper = await attachComponent(this, imageCropWrapperElement, ImageCrop, {\n            rpc: this.rpc,\n            activeOnStart: true,\n            media: img,\n            mimetype: this._getImageMimetype(img),\n        });\n\n        await cropperPromise;\n\n        imageCropWrapperElement.remove();\n        imageCropWrapper.destroy();\n        this.trigger_up('enable_loading_effect');\n    },\n    /**\n     * Displays the image transformation tools\n     *\n     * @see this.selectClass for parameters\n     */\n    async transform() {\n        this.trigger_up('hide_overlay');\n        this.trigger_up('disable_loading_effect');\n\n        const document = this.$target[0].ownerDocument;\n        const playState = this.$target[0].style.animationPlayState;\n        const transition = this.$target[0].style.transition;\n        this.$target.transfo({document});\n        const destroyTransfo = () => {\n            this.$target.transfo('destroy');\n            $(document).off('mousedown', mousedown);\n            window.document.removeEventListener('keydown', keydown);\n        }\n        const mousedown = mousedownEvent => {\n            if (!$(mousedownEvent.target).closest('.transfo-container').length) {\n                destroyTransfo();\n                // Restore animation css properties potentially affected by the\n                // jQuery transfo plugin.\n                this.$target[0].style.animationPlayState = playState;\n                this.$target[0].style.transition = transition;\n            }\n        };\n        $(document).on('mousedown', mousedown);\n        const keydown = keydownEvent => {\n            if (keydownEvent.key === 'Escape') {\n                keydownEvent.stopImmediatePropagation();\n                destroyTransfo();\n            }\n        };\n        window.document.addEventListener('keydown', keydown);\n\n        await new Promise(resolve => {\n            document.addEventListener('mouseup', resolve, {once: true});\n        });\n        this.trigger_up('enable_loading_effect');\n    },\n    /**\n     * Resets the image cropping\n     *\n     * @see this.selectClass for parameters\n     */\n    async resetCrop() {\n        const img = this._getImg();\n\n        // Mount the ImageCrop to call the reset method. As we need the state of\n        // the component to be mounted before calling reset, mount it\n        // temporarily into the body.\n        const imageCropWrapperElement = document.createElement('div');\n        document.body.append(imageCropWrapperElement);\n        const imageCropWrapper = await attachComponent(this, imageCropWrapperElement, ImageCrop, {\n            rpc: this.rpc,\n            activeOnStart: true,\n            media: img,\n            mimetype: this._getImageMimetype(img),\n        });\n        await imageCropWrapper.component.mountedPromise;\n        await imageCropWrapper.component.reset();\n        imageCropWrapper.destroy();\n        imageCropWrapperElement.remove();\n\n        await this._reapplyCurrentShape();\n    },\n    /**\n     * Resets the image rotation and translation\n     *\n     * @see this.selectClass for parameters\n     */\n    async resetTransform() {\n        this.$target\n            .attr('style', (this.$target.attr('style') || '')\n            .replace(/[^;]*transform[\\w:]*;?/g, ''));\n    },\n    /**\n     * @see this.selectClass for parameters\n     */\n    async setImgShape(previewMode, widgetValue, params) {\n        const img = this._getImg();\n        const saveData = previewMode === false;\n        if (img.dataset.hoverEffect && !widgetValue) {\n            // When a shape is removed and there is a hover effect on the\n            // image, we then place the \"Square\" shape as the default because a\n            // shape is required for the hover effects to work.\n            const shapeImgSquareWidget = this._requestUserValueWidgets(\"shape_img_square_opt\")[0];\n            widgetValue = shapeImgSquareWidget.getActiveValue(\"setImgShape\");\n        }\n        if (widgetValue) {\n            await this._loadShape(widgetValue);\n            if (previewMode === 'reset' && img.dataset.shapeColors) {\n                // When we reset the shape we need to reapply the colors the\n                // user had selected.\n                await this._applyShapeAndColors(false, img.dataset.shapeColors.split(';'));\n            } else {\n                // If the preview mode === false we want to save the colors\n                // as the user chose their shape\n                await this._applyShapeAndColors(saveData);\n                if (saveData && img.dataset.mimetype !== 'image/svg+xml') {\n                    img.dataset.originalMimetype = img.dataset.mimetype;\n                    img.dataset.mimetype = 'image/svg+xml';\n                }\n                // When the user selects a shape, we remove the data attributes\n                // that are not compatible with this shape.\n                if (saveData) {\n                    if (!this._isTransformableShape()) {\n                        delete img.dataset.shapeFlip;\n                        delete img.dataset.shapeRotate;\n                    }\n                    if (!this._canHaveHoverEffect()) {\n                        delete img.dataset.hoverEffect;\n                        delete img.dataset.hoverEffectColor;\n                        delete img.dataset.hoverEffectStrokeWidth;\n                        delete img.dataset.hoverEffectIntensity;\n                        img.classList.remove(\"o_animate_on_hover\");\n                    }\n                }\n            }\n        } else {\n            // Re-applying the modifications and deleting the shapes\n            img.src = await applyModifications(img, {mimetype: this._getImageMimetype(img)});\n            delete img.dataset.shape;\n            delete img.dataset.shapeColors;\n            delete img.dataset.fileName;\n            delete img.dataset.shapeFlip;\n            delete img.dataset.shapeRotate;\n            if (saveData) {\n                img.dataset.mimetype = img.dataset.originalMimetype;\n                delete img.dataset.originalMimetype;\n            }\n            // Also apply to carousel thumbnail if applicable.\n            weUtils.forwardToThumbnail(img);\n        }\n        img.classList.add('o_modified_image_to_save');\n    },\n    /**\n     * Handles color assignment on the shape. Widget is a color picker.\n     * If no value, we reset to the current color palette.\n     *\n     * @see this.selectClass for parameters\n     */\n    async setImgShapeColor(previewMode, widgetValue, params) {\n        const img = this._getImg();\n        const newColorId = parseInt(params.colorId);\n        const oldColors = img.dataset.shapeColors.split(';');\n        const newColors = oldColors.slice(0);\n        newColors[newColorId] = this._getCSSColorValue(widgetValue === '' ? `o-color-${(newColorId + 1)}` : widgetValue);\n        await this._applyShapeAndColors(true, newColors);\n        img.classList.add('o_modified_image_to_save');\n    },\n    /**\n     * Flips the image shape horizontally.\n     *\n     * @see this.selectClass for parameters\n     */\n    async setImgShapeFlipX(previewMode, widgetValue, params) {\n        await this._setImgShapeFlip(\"x\");\n    },\n    /**\n     * Flips the image shape vertically.\n     *\n     * @see this.selectClass for parameters\n     */\n    async setImgShapeFlipY(previewMode, widgetValue, params) {\n        await this._setImgShapeFlip(\"y\");\n    },\n    /**\n     * Rotates the image shape 90 degrees to the left.\n     *\n     * @see this.selectClass for parameters\n     */\n    async setImgShapeRotateLeft(previewMode, widgetValue, params) {\n        await this._setImgShapeRotate(-90);\n    },\n    /**\n     * Rotates the image shape 90 degrees to the right.\n     *\n     * @see this.selectClass for parameters\n     */\n    async setImgShapeRotateRight(previewMode, widgetValue, params) {\n        await this._setImgShapeRotate(90);\n    },\n    /**\n     * Sets the hover effects of the image shape.\n     *\n     * @see this.selectClass for parameters\n     */\n    async setImgShapeHoverEffect(previewMode, widgetValue, params) {\n        const imgEl = this._getImg();\n        if (previewMode !== \"reset\") {\n            this.prevHoverEffectColor = imgEl.dataset.hoverEffectColor;\n            this.prevHoverEffectIntensity = imgEl.dataset.hoverEffectIntensity;\n            this.prevHoverEffectStrokeWidth = imgEl.dataset.hoverEffectStrokeWidth;\n        }\n        delete imgEl.dataset.hoverEffectColor;\n        delete imgEl.dataset.hoverEffectIntensity;\n        delete imgEl.dataset.hoverEffectStrokeWidth;\n        if (previewMode === true) {\n            if (params.name === \"hover_effect_overlay_opt\") {\n                imgEl.dataset.hoverEffectColor = this._getCSSColorValue(\"black-25\");\n            } else if (params.name === \"hover_effect_outline_opt\") {\n                imgEl.dataset.hoverEffectColor = this._getCSSColorValue(\"primary\");\n                imgEl.dataset.hoverEffectStrokeWidth = 10;\n            } else {\n                imgEl.dataset.hoverEffectIntensity = 20;\n                if (params.name !== \"hover_effect_mirror_blur_opt\") {\n                    imgEl.dataset.hoverEffectColor = \"rgba(0, 0, 0, 0)\";\n                }\n            }\n        } else {\n            if (this.prevHoverEffectColor) {\n                imgEl.dataset.hoverEffectColor = this.prevHoverEffectColor;\n            }\n            if (this.prevHoverEffectIntensity) {\n                imgEl.dataset.hoverEffectIntensity = this.prevHoverEffectIntensity;\n            }\n            if (this.prevHoverEffectStrokeWidth) {\n                imgEl.dataset.hoverEffectStrokeWidth = this.prevHoverEffectStrokeWidth;\n            }\n        }\n        await this._reapplyCurrentShape();\n        // TODO in master, adapt the '_reapplyCurrentShape()' method to add the\n        // 'o_modified_image_to_save' class on the image.\n        imgEl.classList.add(\"o_modified_image_to_save\");\n        // When the hover effects are first activated from the \"animationMode\"\n        // function of the \"WebsiteAnimate\" class, the history was paused to\n        // avoid recording intermediate steps. That's why we unpause it here.\n        if (this.firstHoverEffect) {\n            this.options.wysiwyg.odooEditor.historyUnpauseSteps();\n            delete this.firstHoverEffect;\n        }\n    },\n    /**\n     * @see this.selectClass for parameters\n     */\n    async selectDataAttribute(previewMode, widgetValue, params) {\n        await this._super(...arguments);\n        if ([\"hoverEffectIntensity\", \"hoverEffectStrokeWidth\"].includes(params.attributeName)) {\n            await this._reapplyCurrentShape();\n            this._getImg().classList.add(\"o_modified_image_to_save\");\n        }\n    },\n    /**\n     * Sets the color of hover effects.\n     *\n     * @see this.selectClass for parameters\n     */\n    async setHoverEffectColor(previewMode, widgetValue, params) {\n        const img = this._getImg();\n        let defaultColor = \"rgba(0, 0, 0, 0)\";\n        if (img.dataset.hoverEffect === \"overlay\") {\n            defaultColor = \"black-25\";\n        } else if (img.dataset.hoverEffect === \"outline\") {\n            defaultColor = \"primary\";\n        }\n        img.dataset.hoverEffectColor = this._getCSSColorValue(widgetValue || defaultColor);\n        img.classList.add(\"o_modified_image_to_save\");\n        await this._reapplyCurrentShape();\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    notify(name) {\n        if (name === \"enable_hover_effect\") {\n            this.trigger_up(\"snippet_edition_request\", {exec: () => {\n                // Add the \"square\" shape to the image if it has no shape\n                // because the \"hover effects\" need a shape to work.\n                const imgEl = this._getImg();\n                const shapeName = imgEl.dataset.shape?.split(\"/\")[2];\n                if (!shapeName) {\n                    const shapeImgSquareWidget = this._requestUserValueWidgets(\"shape_img_square_opt\")[0];\n                    shapeImgSquareWidget.enable();\n                    shapeImgSquareWidget.getParent().close(); // FIXME remove this ugly hack asap\n                }\n                // Add the \"Overlay\" hover effect to the shape.\n                this.firstHoverEffect = true;\n                const hoverEffectOverlayWidget = this._requestUserValueWidgets(\"hover_effect_overlay_opt\")[0];\n                hoverEffectOverlayWidget.enable();\n                hoverEffectOverlayWidget.getParent().close(); // FIXME remove this ugly hack asap\n            }});\n        } else if (name === \"disable_hover_effect\") {\n            this._disableHoverEffect();\n        } else {\n            this._super(...arguments);\n        }\n    },\n    /**\n     * @override\n     */\n    async updateUI() {\n        await this._super(...arguments);\n        // Adapts the colorpicker label according to the selected \"On Hover\"\n        // animation.\n        const hoverEffectName = this.$target[0].dataset.hoverEffect;\n        if (hoverEffectName) {\n            const hoverEffectColorWidget = this.findWidget(\"hover_effect_color_opt\");\n            const needToAdaptLabel = [\"image_zoom_in\", \"image_zoom_out\", \"dolly_zoom\"].includes(hoverEffectName);\n            const labelEl = hoverEffectColorWidget.el.querySelector(\"we-title\");\n            if (!this._originalHoverEffectColorLabel) {\n                this._originalHoverEffectColorLabel = labelEl.textContent;\n            }\n            labelEl.textContent = needToAdaptLabel\n                ? _t(\"Overlay\")\n                : this._originalHoverEffectColorLabel;\n        }\n        // Move the \"hover effects\" options to the 'websiteAnimate' options.\n        const hoverEffectsOptionsEl = this.$el[0].querySelector(\"#o_hover_effects_options\");\n        const animationEffectWidget = this._requestUserValueWidgets(\"animation_effect_opt\")[0];\n        if (hoverEffectsOptionsEl && animationEffectWidget) {\n            animationEffectWidget.getParent().$el[0].append(hoverEffectsOptionsEl);\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n\ufffc    * @private\n\ufffc    */\n    _isTransformed() {\n        return this.$target.is('[style*=\"transform\"]');\n    },\n    /**\n\ufffc    * @private\n\ufffc    */\n    _isCropped() {\n        return this.$target.hasClass('o_we_image_cropped');\n    },\n    /**\n     * @override\n     */\n    async _applyOptions() {\n        const img = await this._super(...arguments);\n        if (img && img.dataset.shape) {\n            await this._loadShape(img.dataset.shape);\n            if (/^data:/.test(img.src)) {\n                // Reapplying the shape\n                await this._applyShapeAndColors(true, (img.dataset.shapeColors && img.dataset.shapeColors.split(';')));\n            }\n        }\n        return img;\n    },\n    /**\n     * Loads the shape into cache if not already and sets it in the dataset of\n     * the img\n     *\n     * @param {string} shapeName identifier of the shape\n     */\n    async _loadShape(shapeName) {\n        const [module, directory, fileName] = shapeName.split('/');\n        let shape = this.shapeCache[fileName];\n        if (!shape) {\n            const shapeURL = `/${encodeURIComponent(module)}/static/image_shapes/${encodeURIComponent(directory)}/${encodeURIComponent(fileName)}.svg`;\n            shape = await (await fetch(shapeURL)).text();\n            this.shapeCache[fileName] = shape;\n        }\n        this._getImg().dataset.shape = shapeName;\n    },\n\n    /**\n     * Applies the shape in img.dataset.shape and replaces the previous hex\n     * color values with new ones or current theme\n     * ones then calls _writeShape()\n     *\n     * @param {boolean} save true if the colors need to be saved in the\n     * data-attribute\n     * @param {string[]} [newColors] Array of HEX color code, default\n     * theme colors are applied if not supplied\n     */\n    async _applyShapeAndColors(save, newColors) {\n        const img = this._getImg();\n        let shape = this.shapeCache[img.dataset.shape.split('/')[2]];\n\n        // Map the default palette colors to an array if the shape includes them\n        // If they do not map a NULL, this way we know if a default color is in\n        // the shape\n        const oldColors = Object.values(DEFAULT_PALETTE).map(color => shape.includes(color) ? color : null);\n        if (!newColors) {\n            // If we do not have newColors, we still replace the default\n            // shape's colors by the current palette's\n            newColors = oldColors.map((color, i) => color !== null ? this._getCSSColorValue(`o-color-${(i + 1)}`) : null);\n        }\n        newColors.forEach((color, i) => shape = shape.replace(new RegExp(oldColors[i], 'g'), this._getCSSColorValue(color)));\n        await this._writeShape(shape);\n        if (save) {\n            img.dataset.shapeColors = newColors.join(';');\n        }\n        // Also apply to carousel thumbnail if applicable.\n        weUtils.forwardToThumbnail(img);\n    },\n    /**\n     * Sets the image in the supplied SVG and replace the src with a dataURL\n     *\n     * @param {string} svgText svg file as text\n     * @returns {Promise} resolved once the svg is properly loaded\n     * in the document\n     */\n    async _writeShape(svgText) {\n        const img = this._getImg();\n        let needToRefreshPublicWidgets = false;\n        let hasHoverEffect = false;\n\n        // Add shape animations on hover.\n        if (img.dataset.hoverEffect && this._canHaveHoverEffect()) {\n            // The \"ImageShapeHoverEffet\" public widget needs to restart\n            // (e.g. image replacement).\n            needToRefreshPublicWidgets = true;\n            hasHoverEffect = true;\n        }\n\n        const dataURL = await this.computeShape(svgText, img);\n\n        let clonedImgEl = null;\n        if (hasHoverEffect) {\n            // This is useful during hover effects previews. Without this, in\n            // Chrome, the 'mouse out' animation is triggered very briefly when\n            // previewMode === 'reset' (when transitioning from one hover effect\n            // to another), causing a visual glitch. To avoid this, we hide the\n            // image with its clone when the source is set.\n            clonedImgEl = img.cloneNode(true);\n            this.options.wysiwyg.odooEditor.observerUnactive(\"addClonedImgForHoverEffectPreview\");\n            img.classList.add(\"d-none\");\n            img.insertAdjacentElement(\"afterend\", clonedImgEl);\n            this.options.wysiwyg.odooEditor.observerActive(\"addClonedImgForHoverEffectPreview\");\n        }\n        const loadedImg = await loadImage(dataURL, img);\n        if (hasHoverEffect) {\n            this.options.wysiwyg.odooEditor.observerUnactive(\"removeClonedImgForHoverEffectPreview\");\n            clonedImgEl.remove();\n            img.classList.remove(\"d-none\");\n            this.options.wysiwyg.odooEditor.observerActive(\"removeClonedImgForHoverEffectPreview\");\n        }\n        if (needToRefreshPublicWidgets) {\n            await this._refreshPublicWidgets();\n        }\n        return loadedImg;\n    },\n    /**\n     * Sets the image in the supplied SVG and replace the src with a dataURL\n     *\n     * @param {string} svgText svg text file\n     * @param img JQuery image\n     * @returns {Promise} resolved once the svg is properly loaded\n     * in the document\n     */\n    async computeShape(svgText, img) {\n        const initialImageWidth = img.naturalWidth;\n\n        const svg = new DOMParser().parseFromString(svgText, 'image/svg+xml').documentElement;\n\n        // Modifies the SVG according to the \"flip\" or/and \"rotate\" options.\n        const shapeFlip = img.dataset.shapeFlip || \"\";\n        const shapeRotate = img.dataset.shapeRotate || 0;\n        if ((shapeFlip || shapeRotate) && this._isTransformableShape()) {\n            let shapeTransformValues = [];\n            if (shapeFlip) { // Possible values => \"x\", \"y\", \"xy\"\n                shapeTransformValues.push(`scale${shapeFlip === \"x\" ? \"X\" : shapeFlip === \"y\" ? \"Y\" : \"\"}(-1)`);\n            }\n            if (shapeRotate) { // Possible values => \"90\", \"180\", \"270\"\n                shapeTransformValues.push(`rotate(${shapeRotate}deg)`);\n            }\n            // \"transform-origin: center;\" does not work on \"#filterPath\". But\n            // since its dimension is 1px * 1px the following solution works.\n            const transformOrigin = \"transform-origin: 0.5px 0.5px;\";\n            // Applies the transformation values to the path used to create a\n            // mask over the SVG image.\n            svg.querySelector(\"#filterPath\").setAttribute(\"style\", `transform: ${shapeTransformValues.join(\" \")}; ${transformOrigin}`);\n        }\n\n        // Add shape animations on hover.\n        if (img.dataset.hoverEffect && this._canHaveHoverEffect()) {\n            this._addImageShapeHoverEffect(svg, img);\n        }\n\n        const svgAspectRatio = parseInt(svg.getAttribute('width')) / parseInt(svg.getAttribute('height'));\n        // We will store the image in base64 inside the SVG.\n        // applyModifications will return a dataURL with the current filters\n        // and size options.\n        const options = {\n            mimetype: this._getImageMimetype(img),\n            perspective: svg.dataset.imgPerspective || null,\n            imgAspectRatio: svg.dataset.imgAspectRatio || null,\n            svgAspectRatio: svgAspectRatio,\n        };\n        const imgDataURL = await applyModifications(img, options);\n        svg.removeChild(svg.querySelector('#preview'));\n        svg.querySelectorAll(\"image\").forEach(image => {\n            image.setAttribute(\"xlink:href\", imgDataURL);\n        });\n        // Force natural width & height (note: loading the original image is\n        // needed for Safari where natural width & height of SVG does not return\n        // the correct values).\n        const originalImage = await loadImage(imgDataURL);\n        // If the svg forces the size of the shape we still want to have the resized\n        // width\n        if (!svg.dataset.forcedSize) {\n            svg.setAttribute('width', originalImage.naturalWidth);\n            svg.setAttribute('height', originalImage.naturalHeight);\n        } else {\n            const imageWidth = Math.trunc(img.dataset.resizeWidth || img.dataset.width || initialImageWidth);\n            const newHeight = imageWidth / svgAspectRatio;\n            svg.setAttribute('width', imageWidth);\n            svg.setAttribute('height', newHeight);\n        }\n        // Transform the current SVG in a base64 file to be saved by the server\n        const blob = new Blob([svg.outerHTML], {\n            type: 'image/svg+xml',\n        });\n        const dataURL = await createDataURL(blob);\n        const imgFilename = (img.dataset.originalSrc.split('/').pop()).split('.')[0];\n        img.dataset.fileName = `${imgFilename}.svg`;\n        return dataURL;\n    },\n    /**\n     * @override\n     */\n    _computeMaxDisplayWidth() {\n        const img = this._getImg();\n        const computedStyles = window.getComputedStyle(img);\n        const displayWidth = parseFloat(computedStyles.getPropertyValue('width'));\n        const gutterWidth = parseFloat(computedStyles.getPropertyValue('--o-grid-gutter-width')) || 30;\n\n        // For the logos we don't want to suggest a width too small.\n        if (this.$target[0].closest('nav')) {\n            return Math.round(Math.min(displayWidth * 3, this.MAX_SUGGESTED_WIDTH));\n        // If the image is in a container(-small), it might get bigger on\n        // smaller screens. So we suggest the width of the current image unless\n        // it is smaller than the size of the container on the md breapoint\n        // (which is where our bootstrap columns fallback to full container\n        // width since we only use col-lg-* in Odoo).\n        } else if (img.closest('.container, .o_container_small')) {\n            const mdContainerMaxWidth = parseFloat(computedStyles.getPropertyValue('--o-md-container-max-width')) || 720;\n            const mdContainerInnerWidth = mdContainerMaxWidth - gutterWidth;\n            return Math.round(clamp(displayWidth, mdContainerInnerWidth, this.MAX_SUGGESTED_WIDTH));\n        // If the image is displayed in a container-fluid, it might also get\n        // bigger on smaller screens. The same way, we suggest the width of the\n        // current image unless it is smaller than the max size of the container\n        // on the md breakpoint (which is the LG breakpoint since the container\n        // fluid is full-width).\n        } else if (img.closest('.container-fluid')) {\n            const lgBp = parseFloat(computedStyles.getPropertyValue('--breakpoint-lg')) || 992;\n            const mdContainerFluidMaxInnerWidth = lgBp - gutterWidth;\n            return Math.round(clamp(displayWidth, mdContainerFluidMaxInnerWidth, this.MAX_SUGGESTED_WIDTH));\n        }\n        // If it's not in a container, it's probably not going to change size\n        // depending on breakpoints. We still keep a margin safety.\n        return Math.round(Math.min(displayWidth * 1.5, this.MAX_SUGGESTED_WIDTH));\n    },\n    /**\n     * @override\n     */\n    _getImg() {\n        return this.$target[0];\n    },\n    /**\n     * @override\n     */\n    _relocateWeightEl() {\n        const leftPanelEl = this.$overlay.data('$optionsSection')[0];\n        const titleTextEl = leftPanelEl.querySelector('we-title > span');\n        this.$weight.appendTo(titleTextEl);\n    },\n    /**\n     * @override\n     */\n    async _computeWidgetVisibility(widgetName, params) {\n        if (widgetName.startsWith('img-shape-color')) {\n            const img = this._getImg();\n            const shapeName = img.dataset.shape;\n            const shapeColors = img.dataset.shapeColors;\n            if (!shapeName || !shapeColors) {\n                return false;\n            }\n            const colors = img.dataset.shapeColors.split(';');\n            return colors[parseInt(params.colorId)];\n        }\n        if (params.optionsPossibleValues.resetTransform) {\n            return this._isTransformed();\n        }\n        if (params.optionsPossibleValues.resetCrop) {\n            return this._isCropped();\n        }\n        if (params.optionsPossibleValues.crop) {\n            const img = this._getImg();\n            return isImageSupportedForStyle(img) || this._isImageSupportedForProcessing(img);\n        }\n        if ([\"img_shape_transform_flip_x_opt\", \"img_shape_transform_flip_y_opt\",\n            \"img_shape_transform_rotate_x_opt\", \"img_shape_transform_rotate_y_opt\"].includes(params.name)) {\n            return this._isTransformableShape();\n        }\n        if (widgetName === \"hover_effect_none_opt\") {\n            // The hover effects are removed with the \"WebsiteAnimate\" animation\n            // selector so this option should not be visible.\n            return false;\n        }\n        if (params.optionsPossibleValues.setImgShapeHoverEffect) {\n            const imgEl = this._getImg();\n            return imgEl.classList.contains(\"o_animate_on_hover\") && this._canHaveHoverEffect();\n        }\n        // If \"Description\" or \"Tooltip\" options.\n        if ([\"alt\", \"title\"].includes(params.attributeName)) {\n            return isImageSupportedForStyle(this._getImg());\n        }\n        // The \"Square\" shape is only used for hover effects. It is\n        // automatically set when there is an hover effect and no shape is\n        // chosen by the user. This shape is always hidden in the shape select.\n        if (widgetName === \"shape_img_square_opt\") {\n            return false;\n        }\n        if (widgetName === \"remove_img_shape_opt\") {\n            // Do not show the \"remove shape\" button when the \"square\" shape is\n            // enable. The \"square\" shape is only enable when there is a hover\n            // effect and it is always hidden in the shape select.\n            const shapeImgSquareWidget = this._requestUserValueWidgets(\"shape_img_square_opt\")[0];\n            return !shapeImgSquareWidget.isActive();\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    _computeWidgetState(methodName, params) {\n        switch (methodName) {\n            case 'selectStyle': {\n                if (params.cssProperty === 'width') {\n                    // TODO check how to handle this the right way (here using\n                    // inline style instead of computed because of the messy\n                    // %-px convertion and the messy auto keyword).\n                    const width = this.$target[0].style.width.trim();\n                    if (width[width.length - 1] === '%') {\n                        return `${parseInt(width)}%`;\n                    }\n                    return '';\n                }\n                break;\n            }\n            case 'transform': {\n                return this._isTransformed() ? 'true' : '';\n            }\n            case 'crop': {\n                return this._isCropped() ? 'true' : '';\n            }\n            case 'setImgShape': {\n                return this._getImg().dataset.shape || '';\n            }\n            case 'setImgShapeColor': {\n                const img = this._getImg();\n                return (img.dataset.shapeColors && img.dataset.shapeColors.split(';')[parseInt(params.colorId)]) || '';\n            }\n            case 'setImgShapeFlipX': {\n                const imgEl = this._getImg();\n                return imgEl.dataset.shapeFlip?.includes(\"x\") || \"\";\n            }\n            case 'setImgShapeFlipY': {\n                const imgEl = this._getImg();\n                return imgEl.dataset.shapeFlip?.includes(\"y\") || \"\";\n            }\n            case 'setHoverEffectColor': {\n                const imgEl = this._getImg();\n                return imgEl.dataset.hoverEffectColor || \"\";\n            }\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * Appends the SVG as an image.\n     * Due to the nature of image_shapes' SVGs, it is easier to render them as\n     * img compared to appending their content to the DOM\n     * (which is what the current data-img does)\n     *\n     * @override\n     */\n    async _renderCustomXML(uiFragment) {\n        await this._super(...arguments);\n        uiFragment.querySelectorAll('we-select-page we-button[data-set-img-shape]').forEach(btn => {\n            const image = document.createElement('img');\n            const [moduleName, directory, shapeName] = btn.dataset.setImgShape.split('/');\n            image.src = `/${encodeURIComponent(moduleName)}/static/image_shapes/${encodeURIComponent(directory)}/${encodeURIComponent(shapeName)}.svg`;\n            $(btn).prepend(image);\n\n            if (btn.dataset.animated) {\n                _addAnimatedShapeLabel(btn);\n            } else if (btn.dataset.imgSize) {\n                _addAnimatedShapeLabel(btn, true);\n            }\n        });\n    },\n    /**\n     * @override\n     */\n    _getImageMimetype(img) {\n        if (img.dataset.shape && img.dataset.originalMimetype) {\n            return img.dataset.originalMimetype;\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * Gets the CSS value of a color variable name so it can be used on shapes.\n     *\n     * @param {string} color\n     * @returns {string}\n     */\n    _getCSSColorValue(color) {\n        if (!color || isCSSColor(color)) {\n            return color;\n        }\n        return weUtils.getCSSVariableValue(color);\n    },\n    /**\n     * Overridden to set attachment data on theme images (with default shapes).\n     *\n     * @override\n     * @private\n     */\n    async _initializeImage() {\n        const _super = this._super.bind(this);\n        let img = this._getImg();\n\n        // Check first if the `src` and eventual `data-original-src` attributes\n        // are correct (i.e. the await are not rejected), as they may have been\n        // wrongly hardcoded in some templates.\n        let checkedAttribute = 'src';\n        try {\n            await loadImage(img.src);\n            if (img.dataset.originalSrc) {\n                checkedAttribute = 'originalSrc';\n                await loadImage(img.dataset.originalSrc);\n            }\n        } catch {\n            if (checkedAttribute === 'src') {\n                // If `src` does not exist, replace the image by a placeholder.\n                Object.keys(img.dataset).forEach(key => delete img.dataset[key]);\n                img.dataset.mimetype = 'image/png';\n                const newSrc = '/web/image/web.image_placeholder';\n                img = await loadImage(newSrc, img);\n                return this._loadImageInfo(newSrc);\n            } else {\n                // If `data-original-src` does not exist, remove the `data-\n                // original-*` attributes (they will be set correctly afterwards\n                // in `_loadImageInfo`).\n                delete img.dataset.originalId;\n                delete img.dataset.originalSrc;\n                delete img.dataset.originalMimetype;\n            }\n        }\n\n        let match = img.src.match(/\\/web_editor\\/image_shape\\/(\\w+\\.\\w+)/);\n        if (img.dataset.shape && match) {\n            match = match[1];\n            if (match.endsWith(\"_perspective\")) {\n                // As an image might already have been modified with a\n                // perspective for some customized snippets in themes. We need\n                // to find the original image to set the 'data-original-src'\n                // attribute.\n                match = match.slice(0, -12);\n            }\n            return this._loadImageInfo(`/web/image/${encodeURIComponent(match)}`);\n        }\n        return _super(...arguments);\n    },\n    /**\n     * @override\n     * @private\n     */\n    async _loadImageInfo() {\n        await this._super(...arguments);\n        const img = this._getImg();\n        if (img.dataset.shape) {\n            if (img.dataset.mimetype !== \"image/svg+xml\") {\n                img.dataset.originalMimetype = img.dataset.mimetype;\n            }\n            if (!this._isImageSupportedForProcessing(img)) {\n                delete img.dataset.shape;\n                delete img.dataset.shapeColors;\n                delete img.dataset.fileName;\n                delete img.dataset.originalMimetype;\n                delete img.dataset.shapeFlip;\n                delete img.dataset.shapeRotate;\n                delete img.dataset.hoverEffect;\n                delete img.dataset.hoverEffectColor;\n                delete img.dataset.hoverEffectStrokeWidth;\n                delete img.dataset.hoverEffectIntensity;\n                img.classList.remove(\"o_animate_on_hover\");\n                return;\n            }\n            if (img.dataset.mimetype !== \"image/svg+xml\") {\n                // Image data-mimetype should be changed to SVG since\n                // loadImageInfo() will set the original attachment mimetype on\n                // it.\n                img.dataset.mimetype = \"image/svg+xml\";\n            }\n        }\n    },\n    /**\n     * @private\n     */\n    async _reapplyCurrentShape() {\n        const img = this._getImg();\n        if (img.dataset.shape) {\n            await this._loadShape(img.dataset.shape);\n            await this._applyShapeAndColors(true, (img.dataset.shapeColors && img.dataset.shapeColors.split(';')));\n        }\n    },\n    /**\n     * @override\n     */\n    _isImageProcessingWidget(widgetName, params) {\n        if (widgetName === 'shape_img_opt') {\n            return !isGif(this._getImageMimetype(this._getImg()));\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * Flips the image shape (vertically or/and horizontally).\n     *\n     * @private\n     * @param {string} flipValue image shape flip value\n     */\n    async _setImgShapeFlip(flipValue) {\n        const imgEl = this._getImg();\n        const currentFlipValue = imgEl.dataset.shapeFlip || \"\";\n        const newFlipValue = currentFlipValue.includes(flipValue)\n            ? currentFlipValue.replace(flipValue, \"\")\n            : currentFlipValue + flipValue;\n        if (newFlipValue) {\n            imgEl.dataset.shapeFlip = newFlipValue === \"yx\" ? \"xy\" : newFlipValue;\n        } else {\n            delete imgEl.dataset.shapeFlip;\n        }\n        await this._applyShapeAndColors(true, imgEl.dataset.shapeColors?.split(\";\"));\n        imgEl.classList.add(\"o_modified_image_to_save\");\n    },\n    /**\n     * Rotates the image shape 90 degrees.\n     *\n     * @private\n     * @param {integer} rotation rotation value\n     */\n    async _setImgShapeRotate(rotation) {\n        const imgEl = this._getImg();\n        const currentRotateValue = parseInt(imgEl.dataset.shapeRotate) || 0;\n        const newRotateValue = (currentRotateValue + rotation + 360) % 360;\n        if (newRotateValue) {\n            imgEl.dataset.shapeRotate = newRotateValue;\n        } else {\n            delete imgEl.dataset.shapeRotate;\n        }\n        await this._applyShapeAndColors(true, imgEl.dataset.shapeColors?.split(\";\"));\n        imgEl.classList.add(\"o_modified_image_to_save\");\n    },\n    /**\n     * Checks if the shape is in the \"devices\" category.\n     *\n     * @private\n     * @returns {boolean}\n     */\n    _isDeviceShape() {\n        const imgEl = this._getImg();\n        const shapeName = imgEl.dataset.shape;\n        if (!shapeName) {\n            return false;\n        }\n        const shapeCategory = imgEl.dataset.shape.split(\"/\")[1];\n        return shapeCategory === \"devices\";\n    },\n    /**\n     * Checks if the shape is transformable.\n     *\n     * @private\n     * @returns {boolean}\n     */\n    _isTransformableShape() {\n        const shapeImgWidget = this._requestUserValueWidgets(\"shape_img_opt\")[0];\n        return (shapeImgWidget && !shapeImgWidget.getMethodsParams().noTransform) && !this._isDeviceShape();\n    },\n    /**\n     * Checks if the shape is in animated.\n     *\n     * @private\n     * @returns {boolean}\n     */\n    _isAnimatedShape() {\n        const shapeImgWidget = this._requestUserValueWidgets(\"shape_img_opt\")[0];\n        return shapeImgWidget?.getMethodsParams().animated;\n    },\n    /**\n     * Checks if the shape can have a hover effect.\n     *\n     * @private\n     * @returns {boolean}\n     */\n    _canHaveHoverEffect() {\n        // TODO Remove this comment in master:\n        // Note that this method does not ensure that a shape can be applied,\n        // which is required for hover effects. It should be preferably merged\n        // with the `_isImageSupportedForShapes()` method.\n        return !this._isDeviceShape() && !this._isAnimatedShape();\n    },\n    /**\n     * Adds hover effect to the SVG.\n     *\n     * @private\n     * @param {HTMLElement} svgEl\n     * @param {HTMLImageElement} [img] img element\n     */\n    async _addImageShapeHoverEffect(svgEl, img) {\n        let rgba = null;\n        let rbg = null;\n        let opacity = null;\n        // Add the required parts for the hover effects to the SVG.\n        const hoverEffectName = img.dataset.hoverEffect;\n        if (!this.hoverEffectsSvg) {\n            this.hoverEffectsSvg = await this._getHoverEffects();\n        }\n        const hoverEffectEls = this.hoverEffectsSvg.querySelectorAll(`#${hoverEffectName} > *`);\n        hoverEffectEls.forEach(hoverEffectEl => {\n            svgEl.appendChild(hoverEffectEl.cloneNode(true));\n        });\n        // Modifies the svg according to the chosen hover effect and the value\n        // of the options.\n        const animateEl = svgEl.querySelector(\"animate\");\n        const animateTransformEls = svgEl.querySelectorAll(\"animateTransform\");\n        const animateElValues = animateEl?.getAttribute(\"values\");\n        let animateTransformElValues = animateTransformEls[0]?.getAttribute(\"values\");\n        if (img.dataset.hoverEffectColor) {\n            rgba = convertCSSColorToRgba(img.dataset.hoverEffectColor);\n            rbg = `rgb(${rgba.red},${rgba.green},${rgba.blue})`;\n            opacity = rgba.opacity / 100;\n            if (![\"outline\", \"image_mirror_blur\"].includes(hoverEffectName)) {\n                svgEl.querySelector('[fill=\"hover_effect_color\"]').setAttribute(\"fill\", rbg);\n                animateEl.setAttribute(\"values\", animateElValues.replace(\"hover_effect_opacity\", opacity));\n            }\n        }\n        switch (hoverEffectName) {\n            case \"outline\": {\n                svgEl.querySelector('[stroke=\"hover_effect_color\"]').setAttribute(\"stroke\", rbg);\n                svgEl.querySelector('[stroke-opacity=\"hover_effect_opacity\"]').setAttribute(\"stroke-opacity\", opacity);\n                // The stroke width needs to be multiplied by two because half\n                // of the stroke is invisible since it is centered on the path.\n                const strokeWidth = parseInt(img.dataset.hoverEffectStrokeWidth) * 2;\n                animateEl.setAttribute(\"values\", animateElValues.replace(\"hover_effect_stroke_width\", strokeWidth));\n                break;\n            }\n            case \"image_zoom_in\":\n            case \"image_zoom_out\":\n            case \"dolly_zoom\": {\n                const imageEl = svgEl.querySelector(\"image\");\n                const clipPathEl = svgEl.querySelector(\"#clip-path\");\n                imageEl.setAttribute(\"id\", \"shapeImage\");\n                // Modify the SVG so that the clip-path is not zoomed when the\n                // image is zoomed.\n                imageEl.setAttribute(\"style\", \"transform-origin: center; width: 100%; height: 100%\");\n                imageEl.setAttribute(\"preserveAspectRatio\", \"none\");\n                svgEl.setAttribute(\"viewBox\", \"0 0 1 1\");\n                svgEl.setAttribute(\"preserveAspectRatio\", \"none\");\n                clipPathEl.setAttribute(\"clipPathUnits\", \"userSpaceOnUse\");\n                const clipPathValue = imageEl.getAttribute(\"clip-path\");\n                imageEl.removeAttribute(\"clip-path\");\n                const gEl = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n                gEl.setAttribute(\"clip-path\", clipPathValue);\n                imageEl.parentNode.replaceChild(gEl, imageEl);\n                gEl.appendChild(imageEl);\n                let zoomValue = 1.01 + parseInt(img.dataset.hoverEffectIntensity) / 200;\n                animateTransformEls[0].setAttribute(\"values\", animateTransformElValues.replace(\"hover_effect_zoom\", zoomValue));\n                if (hoverEffectName === \"image_zoom_out\") {\n                    // Set zoom intensity for the image.\n                    const styleAttr = svgEl.querySelector(\"style\");\n                    styleAttr.textContent = styleAttr.textContent.replace(\"hover_effect_zoom\", zoomValue);\n                }\n                if (hoverEffectName === \"dolly_zoom\") {\n                    clipPathEl.setAttribute(\"style\", \"transform-origin: center;\");\n                    // Set zoom intensity for clip-path and overlay.\n                    zoomValue = 0.99 - parseInt(img.dataset.hoverEffectIntensity) / 2000;\n                    animateTransformEls.forEach((animateTransformEl, index) => {\n                        if (index > 0) {\n                            animateTransformElValues = animateTransformEl.getAttribute(\"values\");\n                            animateTransformEl.setAttribute(\"values\", animateTransformElValues.replace(\"hover_effect_zoom\", zoomValue));\n                        }\n                    });\n                }\n                break;\n            }\n            case \"image_mirror_blur\": {\n                const imageEl = svgEl.querySelector(\"image\");\n                imageEl.setAttribute('id', 'shapeImage');\n                imageEl.setAttribute('style', 'transform-origin: center;');\n                const imageMirrorEl = imageEl.cloneNode();\n                imageMirrorEl.setAttribute(\"id\", 'shapeImageMirror');\n                imageMirrorEl.setAttribute(\"filter\", \"url(#blurFilter)\");\n                imageEl.insertAdjacentElement(\"beforebegin\", imageMirrorEl);\n                const zoomValue = 0.99 - parseInt(img.dataset.hoverEffectIntensity) / 200;\n                animateTransformEls[0].setAttribute(\"values\", animateTransformElValues.replace(\"hover_effect_zoom\", zoomValue));\n                break;\n            }\n        }\n    },\n    /**\n     * Gets the hover effects list.\n     *\n     * @private\n     * @returns {HTMLElement}\n     */\n    _getHoverEffects() {\n        const hoverEffectsURL = \"/website/static/src/svg/hover_effects.svg\";\n        return fetch(hoverEffectsURL)\n            .then(response => response.text())\n            .then(text => {\n                const parser = new DOMParser();\n                const xmlDoc = parser.parseFromString(text, \"text/xml\");\n                return xmlDoc.getElementsByTagName(\"svg\")[0];\n            });\n    },\n    /**\n     * Disables the hover effect on the image.\n     *\n     * @private\n     */\n    async _disableHoverEffect() {\n        const imgEl = this._getImg();\n        const shapeName = imgEl.dataset.shape?.split(\"/\")[2];\n        delete imgEl.dataset.hoverEffect;\n        delete imgEl.dataset.hoverEffectColor;\n        delete imgEl.dataset.hoverEffectStrokeWidth;\n        delete imgEl.dataset.hoverEffectIntensity;\n        await this._applyOptions();\n        // If \"Square\" shape, remove it, it doesn't make sense to keep it\n        // without hover effect.\n        if (shapeName === \"geo_square\") {\n            this._requestUserValueWidgets(\"remove_img_shape_opt\")[0].enable();\n        }\n    },\n    /**\n     * @override\n     */\n    async _select(previewMode, widget) {\n        await this._super(...arguments);\n        // This is a special case where we need to override the \"_select\"\n        // function in order to trigger mouse events for hover effects on the\n        // images when previewing the options. This is done here because if it\n        // was done in one of the widget methods, the animation would be\n        // canceled when \"_refreshPublicWidgets\" is executed in the \"_super\"\n        if (widget.$el[0].closest(\"#o_hover_effects_options\")) {\n            const hasSetImgShapeHoverEffectMethod = widget.getMethodsNames().includes(\"setImgShapeHoverEffect\");\n            // We trigger the animation when preview mode is \"false\", except for\n            // the \"setImgShapeHoverEffect\" option, where we trigger it when\n            // preview mode is \"true\".\n            if (previewMode === hasSetImgShapeHoverEffectMethod) {\n                this.$target[0].dispatchEvent(new Event(\"mouseover\"));\n                this.hoverTimeoutId = setTimeout(() => {\n                    this.$target[0].dispatchEvent(new Event(\"mouseout\"));\n                }, 700);\n            } else if (previewMode === \"reset\") {\n                clearTimeout(this.hoverTimeoutId);\n            }\n        }\n    },\n    /**\n     * Checks if a shape can be applied on the target.\n     *\n     * @private\n     * @returns {boolean}\n     */\n    _isImageSupportedForShapes() {\n        const imgEl = this._getImg();\n        return imgEl.dataset.originalId && this._isImageSupportedForProcessing(imgEl);\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Reloads image data and auto-optimizes the new image.\n     *\n     * @private\n     * @param {Event} ev\n     */\n    async _onImageChanged(ev) {\n        this.trigger_up('snippet_edition_request', {exec: async () => {\n            await this._autoOptimizeImage();\n            this.trigger_up('cover_update');\n            if (ev._complete) {\n                ev._complete();\n            }\n        }});\n    },\n    /**\n     * Available widths will change, need to rerender the width select.\n     *\n     * @private\n     * @param {Event} ev\n     */\n    async _onImageCropped(ev) {\n        await this._rerenderXML();\n    },\n});\n\n/**\n * Controls background image width and quality.\n */\nregistry.BackgroundOptimize = ImageHandlerOption.extend({\n    /**\n     * @override\n     */\n    start() {\n        this.$target.on('background_changed.BackgroundOptimize', this._onBackgroundChanged.bind(this));\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    destroy() {\n        this.$target.off('.BackgroundOptimize');\n        return this._super(...arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _getImg() {\n        return this.img;\n    },\n    /**\n     * @override\n     */\n    _computeMaxDisplayWidth() {\n        return 1920;\n    },\n    /**\n     * Initializes this.img to an image with the background image url as src.\n     *\n     * @override\n     */\n    async _loadImageInfo() {\n        this.img = new Image();\n        // In the case of a parallax, the background of the snippet is actually\n        // set on a child <span> and should be focused here. This is necessary\n        // because, at this point, the $target has not yet been updated in the\n        // notify() method (\"option_update\" event), although the event is\n        // properly fired from the parallax.\n        const targetEl = this.$target[0].classList.contains(\"oe_img_bg\")\n            ? this.$target[0] : this.$target[0].querySelector(\":scope > .s_parallax_bg.oe_img_bg\");\n        if (targetEl) {\n            Object.entries(targetEl.dataset).filter(([key]) =>\n                isBackgroundImageAttribute(key)).forEach(([key, value]) => {\n                this.img.dataset[key] = value;\n            });\n            const src = getBgImageURL(targetEl);\n            // Don't set the src if not relative (ie, not local image: cannot be\n            // modified)\n            this.img.src = src.startsWith(\"/\") ? src : \"\";\n        }\n        return await this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    _relocateWeightEl() {\n        this.trigger_up('option_update', {\n            optionNames: ['BackgroundImage'],\n            name: 'add_size_indicator',\n            data: this.$weight,\n        });\n    },\n    /**\n     * @override\n     */\n    _applyImage(img) {\n        const parts = backgroundImageCssToParts(this.$target.css('background-image'));\n        parts.url = `url('${img.getAttribute('src')}')`;\n        const combined = backgroundImagePartsToCss(parts);\n        this.$target.css('background-image', combined);\n        // Apply modification on the DOM HTML element that is currently being\n        // modified.\n        this.$target[0].classList.add(\"o_modified_image_to_save\");\n        // First delete the data attributes relative to the image background\n        // from the target as a data attribute could have been be removed (ex:\n        // glFilter).\n        for (const attribute in this.$target[0].dataset) {\n            if (isBackgroundImageAttribute(attribute)) {\n                delete this.$target[0].dataset[attribute];\n            }\n        }\n        Object.entries(img.dataset).forEach(([key, value]) => {\n            this.$target[0].dataset[key] = value;\n        });\n        this.$target[0].dataset.bgSrc = img.getAttribute(\"src\");\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Reloads image data when the background is changed.\n     *\n     * @private\n     */\n    async _onBackgroundChanged(ev, previewMode) {\n        ev.stopPropagation();\n        if (!previewMode) {\n            this.trigger_up('snippet_edition_request', {exec: async () => {\n                await this._autoOptimizeImage();\n            }});\n        }\n    },\n});\n\nregistry.BackgroundToggler = SnippetOptionWidget.extend({\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * Toggles background image on or off.\n     *\n     * @see this.selectClass for parameters\n     */\n    toggleBgImage(previewMode, widgetValue, params) {\n        if (!widgetValue) {\n            this.$target.find('> .o_we_bg_filter').remove();\n            // TODO: use setWidgetValue instead of calling background directly when possible\n            const [bgImageWidget] = this._requestUserValueWidgets('bg_image_opt');\n            const bgImageOpt = bgImageWidget.getParent();\n            return bgImageOpt.background(false, '', bgImageWidget.getMethodsParams('background'));\n        } else {\n            // TODO: use trigger instead of el.click when possible\n            this._requestUserValueWidgets('bg_image_opt')[0].el.click();\n        }\n    },\n    /**\n     * Toggles background shape on or off.\n     *\n     * @see this.selectClass for parameters\n     */\n    toggleBgShape(previewMode, widgetValue, params) {\n        const [shapeWidget] = this._requestUserValueWidgets('bg_shape_opt');\n        const shapeOption = shapeWidget.getParent();\n        // TODO: open select after shape was selected?\n        // TODO: use setWidgetValue instead of calling shapeOption method directly when possible\n        return shapeOption._toggleShape();\n    },\n    /**\n     * Sets a color filter.\n     *\n     * @see this.selectClass for parameters\n     */\n    async selectFilterColor(previewMode, widgetValue, params) {\n        // Find the filter element.\n        let filterEl = this.$target[0].querySelector(':scope > .o_we_bg_filter');\n\n        // If the filter would be transparent, remove it / don't create it.\n        const rgba = widgetValue && convertCSSColorToRgba(widgetValue);\n        if (!widgetValue || rgba && rgba.opacity < 0.001) {\n            if (filterEl) {\n                filterEl.remove();\n            }\n            return;\n        }\n\n        // Create the filter if necessary.\n        if (!filterEl) {\n            filterEl = document.createElement('div');\n            filterEl.classList.add('o_we_bg_filter');\n            const lastBackgroundEl = this._getLastPreFilterLayerElement();\n            if (lastBackgroundEl) {\n                $(lastBackgroundEl).after(filterEl);\n            } else {\n                this.$target.prepend(filterEl);\n            }\n        }\n\n        // Apply the color on the filter.\n        const obj = createPropertyProxy(this, '$target', $(filterEl));\n        params.cssProperty = 'background-color';\n        return this.selectStyle.call(obj, previewMode, widgetValue, params);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _computeWidgetState(methodName, params) {\n        switch (methodName) {\n            case 'toggleBgImage': {\n                const [bgImageWidget] = this._requestUserValueWidgets('bg_image_opt');\n                const bgImageOpt = bgImageWidget.getParent();\n                return !!bgImageOpt._computeWidgetState('background', bgImageWidget.getMethodsParams('background'));\n            }\n            case 'toggleBgShape': {\n                const [shapeWidget] = this._requestUserValueWidgets('bg_shape_opt');\n                const shapeOption = shapeWidget.getParent();\n                return !!shapeOption._computeWidgetState('shape', shapeWidget.getMethodsParams('shape'));\n            }\n            case 'selectFilterColor': {\n                const filterEl = this.$target[0].querySelector(':scope > .o_we_bg_filter');\n                if (!filterEl) {\n                    return '';\n                }\n                const obj = createPropertyProxy(this, '$target', $(filterEl));\n                params.cssProperty = 'background-color';\n                return this._computeWidgetState.call(obj, 'selectStyle', params);\n            }\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * @private\n     */\n    _getLastPreFilterLayerElement() {\n        return null;\n    },\n});\n\n/**\n * Handles the edition of snippet's background image.\n */\nregistry.BackgroundImage = SnippetOptionWidget.extend({\n    /**\n     * @override\n     */\n    start: function () {\n        this.__customImageSrc = getBgImageURL(this.$target[0]);\n        return this._super(...arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * Handles a background change.\n     *\n     * @see this.selectClass for parameters\n     */\n    background: async function (previewMode, widgetValue, params) {\n        if (previewMode === true) {\n            this.__customImageSrc = getBgImageURL(this.$target[0]);\n        } else if (previewMode === 'reset') {\n            widgetValue = this.__customImageSrc;\n        } else {\n            this.__customImageSrc = widgetValue;\n        }\n\n        this._setBackground(widgetValue);\n\n        if (previewMode !== 'reset') {\n            removeOnImageChangeAttrs.forEach(attr => delete this.$target[0].dataset[attr]);\n            this.$target.trigger('background_changed', [previewMode]);\n        }\n    },\n    /**\n     * Changes the main color of dynamic SVGs.\n     *\n     * @see this.selectClass for parameters\n     */\n    async dynamicColor(previewMode, widgetValue, params) {\n        const currentSrc = getBgImageURL(this.$target[0]);\n        switch (previewMode) {\n            case true:\n                this.previousSrc = currentSrc;\n                break;\n            case 'reset':\n                this._setBackground(this.previousSrc);\n                return;\n        }\n        const newURL = new URL(currentSrc, window.location.origin);\n        newURL.searchParams.set(params.colorName, normalizeColor(widgetValue));\n        const src = newURL.pathname + newURL.search;\n        await loadImage(src);\n        this._setBackground(src);\n        if (!previewMode) {\n            this.previousSrc = src;\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    notify(name, data) {\n        if (name === 'add_size_indicator') {\n            this._requestUserValueWidgets('bg_image_opt')[0].$el.after(data);\n        } else {\n            this._super(...arguments);\n        }\n    },\n    /**\n     * @override\n     */\n    setTarget: function () {\n        // When we change the target of this option we need to transfer the\n        // background-image and the dataset information relative to this image\n        // from the old target to the new one.\n        const oldBgURL = getBgImageURL(this.$target);\n        const isModifiedImage = this.$target[0].classList.contains(\"o_modified_image_to_save\");\n        const filteredOldDataset = Object.entries(this.$target[0].dataset).filter(([key]) => {\n            return isBackgroundImageAttribute(key);\n        });\n        // Delete the dataset information relative to the background-image of\n        // the old target.\n        filteredOldDataset.forEach(([key]) => {\n            delete this.$target[0].dataset[key];\n        });\n        // It is important to delete \".o_modified_image_to_save\" from the old\n        // target as its image source will be deleted.\n        this.$target[0].classList.remove(\"o_modified_image_to_save\");\n        this._setBackground('');\n        this._super(...arguments);\n        if (oldBgURL) {\n            this._setBackground(oldBgURL);\n            filteredOldDataset.forEach(([key, value]) => {\n                this.$target[0].dataset[key] = value;\n            });\n            this.$target[0].classList.toggle(\"o_modified_image_to_save\", isModifiedImage);\n        }\n\n        // TODO should be automatic for all options as equal to the start method\n        this.__customImageSrc = getBgImageURL(this.$target[0]);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _computeWidgetState: function (methodName, params) {\n        switch (methodName) {\n            case 'background':\n                return getBgImageURL(this.$target[0]);\n            case 'dynamicColor':\n                return new URL(getBgImageURL(this.$target[0]), window.location.origin).searchParams.get(params.colorName);\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    _computeWidgetVisibility(widgetName, params) {\n        if ('colorName' in params) {\n            const src = new URL(getBgImageURL(this.$target[0]), window.location.origin);\n            return src.searchParams.has(params.colorName);\n        } else if (widgetName === 'main_color_opt') {\n            const src = new URL(getBgImageURL(this.$target[0]), window.location.origin);\n            return src.origin === window.location.origin && src.pathname.startsWith('/web_editor/shape/');\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * @private\n     * @param {string} backgroundURL\n     */\n    _setBackground(backgroundURL) {\n        const parts = backgroundImageCssToParts(this.$target.css('background-image'));\n        if (backgroundURL) {\n            parts.url = `url('${backgroundURL}')`;\n            this.$target.addClass('oe_img_bg o_bg_img_center o_bg_img_origin_border_box');\n        } else {\n            delete parts.url;\n            this.$target[0].classList.remove(\n                \"oe_img_bg\",\n                \"o_bg_img_center\",\n                \"o_bg_img_origin_border_box\",\n                \"o_modified_image_to_save\",\n            );\n        }\n        const combined = backgroundImagePartsToCss(parts);\n        this.$target.css('background-image', combined);\n        this.options.wysiwyg.odooEditor.editable.focus();\n    },\n});\n\n/**\n * Handles background shapes.\n */\nregistry.BackgroundShape = SnippetOptionWidget.extend({\n    /**\n     * @override\n     */\n    updateUI({assetsChanged} = {}) {\n        if (this.rerender || assetsChanged) {\n            this.rerender = false;\n            return this._rerenderXML();\n        }\n        return this._super.apply(this, arguments);\n    },\n    /**\n     * @override\n     */\n    onBuilt() {\n        // Flip classes should no longer be used but are still present in some\n        // theme snippets.\n        if (this.$target[0].querySelector('.o_we_flip_x, .o_we_flip_y')) {\n            this._handlePreviewState(false, () => {\n                return {flip: this._getShapeData().flip};\n            });\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * Sets the current background shape.\n     *\n     * @see this.selectClass for params\n     */\n    shape(previewMode, widgetValue, params) {\n        this._handlePreviewState(previewMode, () => {\n            return {\n                shape: widgetValue,\n                colors: this._getImplicitColors(widgetValue, this._getShapeData().colors),\n                flip: [],\n                animated: params.animated,\n            };\n        });\n    },\n    /**\n     * Sets the current background shape's colors.\n     *\n     * @see this.selectClass for params\n     */\n    color(previewMode, widgetValue, params) {\n        this._handlePreviewState(previewMode, () => {\n            const {colorName} = params;\n            const {colors: previousColors} = this._getShapeData();\n            const newColor = normalizeColor(widgetValue) || this._getDefaultColors()[colorName];\n            const newColors = Object.assign(previousColors, {[colorName]: newColor});\n            return {colors: newColors};\n        });\n    },\n    /**\n     * Flips the shape on its x axis.\n     *\n     * @see this.selectClass for params\n     */\n    flipX(previewMode, widgetValue, params) {\n        this._flipShape(previewMode, 'x');\n    },\n    /**\n     * Flips the shape on its y axis.\n     *\n     * @see this.selectClass for params\n     */\n    flipY(previewMode, widgetValue, params) {\n        this._flipShape(previewMode, 'y');\n    },\n    /**\n     * Shows/Hides the shape on mobile.\n     *\n     * @see this.selectClass for params\n     */\n    showOnMobile(previewMode, widgetValue, params) {\n        this._handlePreviewState(previewMode, () => {\n            return {showOnMobile: !this._getShapeData().showOnMobile};\n        });\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _computeWidgetState(methodName, params) {\n        switch (methodName) {\n            case 'shape': {\n                return this._getShapeData().shape;\n            }\n            case 'color': {\n                const {shape, colors: customColors} = this._getShapeData();\n                const colors = Object.assign(this._getDefaultColors(), customColors);\n                const color = shape && colors[params.colorName];\n                return color || '';\n            }\n            case 'flipX': {\n                // Compat: flip classes are no longer used but may be present in client db\n                const hasFlipClass = this.$target.find('> .o_we_shape.o_we_flip_x').length !== 0;\n                return hasFlipClass || this._getShapeData().flip.includes('x');\n            }\n            case 'flipY': {\n                // Compat: flip classes are no longer used but may be present in client db\n                const hasFlipClass = this.$target.find('> .o_we_shape.o_we_flip_y').length !== 0;\n                return hasFlipClass || this._getShapeData().flip.includes('y');\n            }\n            case 'showOnMobile': {\n                return this._getShapeData().showOnMobile;\n            }\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    _renderCustomXML(uiFragment) {\n        Object.keys(this._getDefaultColors()).map(colorName => {\n            uiFragment.querySelector('[data-name=\"colors\"]')\n                .prepend($(`<we-colorpicker data-color=\"true\" data-color-name=\"${colorName}\"></we-colorpicker>`)[0]);\n        });\n\n        // Inventory shape URLs per class.\n        const style = window.getComputedStyle(this.$target[0]);\n        const palette = [1, 2, 3, 4, 5].map(n => style.getPropertyValue(`--o-cc${n}-bg`)).join();\n        if (palette !== this._lastShapePalette) {\n            this._lastShapePalette = palette;\n            this._shapeBackgroundImagePerClass = {};\n            for (const styleSheet of this.$target[0].ownerDocument.styleSheets) {\n                if (styleSheet.href && new URL(styleSheet.href).host !== location.host) {\n                    // In some browsers, if a stylesheet is loaded from a different domain\n                    // accessing cssRules results in a SecurityError.\n                    continue;\n                }\n                for (const rule of [...styleSheet.cssRules]) {\n                    if (rule.selectorText && rule.selectorText.startsWith(\".o_we_shape.\")) {\n                        this._shapeBackgroundImagePerClass[rule.selectorText] = rule.style.backgroundImage;\n                    }\n                }\n            }\n        }\n\n        uiFragment.querySelectorAll('we-select-pager we-button[data-shape]').forEach(btn => {\n            const btnContent = document.createElement('div');\n            btnContent.classList.add('o_we_shape_btn_content', 'position-relative', 'border-dark');\n            const btnContentInnerDiv = document.createElement('div');\n            btnContentInnerDiv.classList.add('o_we_shape');\n            btnContent.appendChild(btnContentInnerDiv);\n\n            if (btn.dataset.animated) {\n                _addAnimatedShapeLabel(btnContent);\n            }\n\n            const {shape} = btn.dataset;\n            const shapeEl = btnContent.querySelector('.o_we_shape');\n            const shapeClassName = `o_${shape.replace(/\\//g, '_')}`;\n            shapeEl.classList.add(shapeClassName);\n            // Match current palette.\n            const shapeBackgroundImage = this._shapeBackgroundImagePerClass[`.o_we_shape.${shapeClassName}`];\n            shapeEl.style.setProperty(\"background-image\", shapeBackgroundImage);\n            btn.append(btnContent);\n        });\n        return uiFragment;\n    },\n    /**\n     * Flips the shape on its x/y axis.\n     *\n     * @param {boolean} previewMode\n     * @param {'x'|'y'} axis the axis of the shape that should be flipped.\n     */\n    _flipShape(previewMode, axis) {\n        this._handlePreviewState(previewMode, () => {\n            const flip = new Set(this._getShapeData().flip);\n            if (flip.has(axis)) {\n                flip.delete(axis);\n            } else {\n                flip.add(axis);\n            }\n            return {flip: [...flip]};\n        });\n    },\n    /**\n     * Inserts or removes the given container at the right position in the\n     * document.\n     *\n     * @param {HTMLElement} [newContainer] container to insert, null to remove\n     */\n    _insertShapeContainer(newContainer) {\n        const target = this.$target[0];\n\n        const shapeContainer = target.querySelector(':scope > .o_we_shape');\n        if (shapeContainer) {\n            this._removeShapeEl(shapeContainer);\n        }\n        if (newContainer) {\n            const preShapeLayerElement = this._getLastPreShapeLayerElement();\n            if (preShapeLayerElement) {\n                $(preShapeLayerElement).after(newContainer);\n            } else {\n                this.$target.prepend(newContainer);\n            }\n        }\n        return newContainer;\n    },\n    /**\n     * Creates and inserts a container for the shape with the right classes.\n     *\n     * @param {string} shape the shape name for which to create a container\n     */\n    _createShapeContainer(shape) {\n        const shapeContainer = this._insertShapeContainer(document.createElement('div'));\n        this.$target[0].style.position = 'relative';\n        shapeContainer.className = `o_we_shape o_${shape.replace(/\\//g, '_')}`;\n        return shapeContainer;\n    },\n    /**\n     * Handles everything related to saving state before preview and restoring\n     * it after a preview or locking in the changes when not in preview.\n     *\n     * @param {boolean} previewMode\n     * @param {function} computeShapeData function to compute the new shape data.\n     */\n    _handlePreviewState(previewMode, computeShapeData) {\n        const target = this.$target[0];\n\n        let changedShape = false;\n        if (previewMode === 'reset') {\n            this._insertShapeContainer(this.prevShapeContainer);\n            if (this.prevShape) {\n                target.dataset.oeShapeData = this.prevShape;\n            } else {\n                delete target.dataset.oeShapeData;\n            }\n            return;\n        } else {\n            if (previewMode === true) {\n                const shapeContainer = target.querySelector(':scope > .o_we_shape');\n                this.prevShapeContainer = shapeContainer && shapeContainer.cloneNode(true);\n                this.prevShape = target.dataset.oeShapeData;\n            }\n            const curShapeData = target.dataset.oeShapeData || {};\n            const newShapeData = computeShapeData();\n            const {shape: curShape} = curShapeData;\n            changedShape = newShapeData.shape !== curShape;\n            this._markShape(newShapeData);\n            if (previewMode === false && changedShape) {\n                // Need to rerender for correct number of colorpickers\n                this.rerender = true;\n            }\n        }\n\n        // Updates/removes the shape container as needed and gives it the\n        // correct background shape\n        const json = target.dataset.oeShapeData;\n        const {shape, colors, flip = [], animated = 'false', showOnMobile} = json ? JSON.parse(json) : {};\n        let shapeContainer = target.querySelector(':scope > .o_we_shape');\n        if (!shape) {\n            return this._insertShapeContainer(null);\n        }\n        // When changing shape we want to reset the shape container (for transparency color)\n        if (changedShape) {\n            shapeContainer = this._createShapeContainer(shape);\n        }\n        // Compat: remove old flip classes as flipping is now done inside the svg\n        shapeContainer.classList.remove('o_we_flip_x', 'o_we_flip_y');\n\n        shapeContainer.classList.toggle('o_we_animated', animated === 'true');\n\n        if (colors || flip.length) {\n            // Custom colors/flip, overwrite shape that is set by the class\n            $(shapeContainer).css('background-image', `url(\"${this._getShapeSrc()}\")`);\n            shapeContainer.style.backgroundPosition = '';\n            if (flip.length) {\n                let [xPos, yPos] = $(shapeContainer)\n                    .css('background-position')\n                    .split(' ')\n                    .map(p => parseFloat(p));\n                // -X + 2*Y is a symmetry of X around Y, this is a symmetry around 50%\n                xPos = flip.includes('x') ? -xPos + 100 : xPos;\n                yPos = flip.includes('y') ? -yPos + 100 : yPos;\n                shapeContainer.style.backgroundPosition = `${xPos}% ${yPos}%`;\n            }\n        } else {\n            // Remove custom bg image and let the shape class set the bg shape\n            $(shapeContainer).css('background-image', '');\n            $(shapeContainer).css('background-position', '');\n        }\n        shapeContainer.classList.toggle('o_shape_show_mobile', !!showOnMobile);\n        if (previewMode === false) {\n            this.prevShapeContainer = shapeContainer.cloneNode(true);\n            this.prevShape = target.dataset.oeShapeData;\n        }\n    },\n    /**\n     * @private\n     * @param {HTMLElement} shapeEl\n     */\n    _removeShapeEl(shapeEl) {\n        shapeEl.remove();\n    },\n    /**\n     * Overwrites shape properties with the specified data.\n     *\n     * @private\n     * @param {Object} newData an object with the new data\n     */\n    _markShape(newData) {\n        const defaultColors = this._getDefaultColors();\n        const shapeData = Object.assign(this._getShapeData(), newData);\n        const areColorsDefault = Object.entries(shapeData.colors).every(([colorName, colorValue]) => {\n            return defaultColors[colorName] && colorValue.toLowerCase() === defaultColors[colorName].toLowerCase();\n        });\n        if (areColorsDefault) {\n            delete shapeData.colors;\n        }\n        if (!shapeData.shape) {\n            delete this.$target[0].dataset.oeShapeData;\n        } else {\n            this.$target[0].dataset.oeShapeData = JSON.stringify(shapeData);\n        }\n    },\n    /**\n     * @private\n     */\n    _getLastPreShapeLayerElement() {\n        const $filterEl = this.$target.find('> .o_we_bg_filter');\n        if ($filterEl.length) {\n            return $filterEl[0];\n        }\n        return null;\n    },\n    /**\n     * Returns the src of the shape corresponding to the current parameters.\n     *\n     * @private\n     */\n    _getShapeSrc() {\n        const {shape, colors, flip} = this._getShapeData();\n        if (!shape) {\n            return '';\n        }\n        const searchParams = Object.entries(colors)\n            .map(([colorName, colorValue]) => {\n                const encodedCol = encodeURIComponent(colorValue);\n                return `${colorName}=${encodedCol}`;\n            });\n        if (flip.length) {\n            searchParams.push(`flip=${encodeURIComponent(flip.sort().join(''))}`);\n        }\n        return `/web_editor/shape/${encodeURIComponent(shape)}.svg?${searchParams.join('&')}`;\n    },\n    /**\n     * Retrieves current shape data from the target's dataset.\n     *\n     * @private\n     * @param {HTMLElement} [target=this.$target[0]] the target on which to read\n     *   the shape data.\n     */\n    _getShapeData(target = this.$target[0]) {\n        const defaultData = {\n            shape: '',\n            colors: this._getDefaultColors($(target)),\n            flip: [],\n            showOnMobile: false,\n        };\n        const json = target.dataset.oeShapeData;\n        return json ? Object.assign(defaultData, JSON.parse(json.replace(/'/g, '\"'))) : defaultData;\n    },\n    /**\n     * Returns the default colors for the currently selected shape.\n     *\n     * @private\n     * @param {jQueryElement} [$target=this.$target] the target on which to read\n     *   the shape data.\n     */\n    _getDefaultColors($target = this.$target) {\n        const $shapeContainer = $target.find('> .o_we_shape')\n            .clone()\n            .addClass('d-none')\n            // Needs to be in document for bg-image class to take effect\n            .appendTo(this.$target[0].ownerDocument.body);\n        const shapeContainer = $shapeContainer[0];\n        $shapeContainer.css('background-image', '');\n        const shapeSrc = shapeContainer && getBgImageURL(shapeContainer);\n        $shapeContainer.remove();\n        if (!shapeSrc) {\n            return {};\n        }\n        const url = new URL(shapeSrc, window.location.origin);\n        return Object.fromEntries(url.searchParams.entries());\n    },\n    /**\n     * Returns the default colors for the a shape in the selector.\n     *\n     * @private\n     * @param {String} shapeId identifier of the shape\n     */\n    _getShapeDefaultColors(shapeId) {\n        const $shapeContainer = this.$el.find(\".o_we_bg_shape_menu we-button[data-shape='\" + shapeId + \"'] div.o_we_shape\");\n        const shapeContainer = $shapeContainer[0];\n        const shapeSrc = shapeContainer && getBgImageURL(shapeContainer);\n        const url = new URL(shapeSrc, window.location.origin);\n        return Object.fromEntries(url.searchParams.entries());\n    },\n    /**\n     * Returns the implicit colors for the currently selected shape.\n     *\n     * The implicit colors are use upon shape selection. They are computed as:\n     * - the default colors\n     * - patched with each set of colors of previous siblings shape\n     * - patched with the colors of the previously selected shape\n     * - filtered to only keep the colors involved in the current shape\n     *\n     * @private\n     * @param {String} shape identifier of the selected shape\n     * @param {Object} previousColors colors of the shape before its replacement\n     */\n    _getImplicitColors(shape, previousColors) {\n        const defaultColors = this._getShapeDefaultColors(shape);\n        let colors = previousColors || {};\n        let sibling = this.$target[0].previousElementSibling;\n        while (sibling) {\n            colors = Object.assign(this._getShapeData(sibling).colors || {}, colors);\n            sibling = sibling.previousElementSibling;\n        }\n        const defaultKeys = Object.keys(defaultColors);\n        colors = Object.assign(defaultColors, colors);\n        return pick(colors, ...defaultKeys);\n    },\n    /**\n     * Toggles whether there is a shape or not, to be called from bg toggler.\n     *\n     * @private\n     */\n    _toggleShape() {\n        if (this._getShapeData().shape) {\n            return this._handlePreviewState(false, () => ({shape: ''}));\n        } else {\n            const target = this.$target[0];\n            const previousSibling = target.previousElementSibling;\n            const [shapeWidget] = this._requestUserValueWidgets('bg_shape_opt');\n            const possibleShapes = shapeWidget.getMethodsParams('shape').possibleValues;\n            let shapeToSelect;\n            if (previousSibling) {\n                const previousShape = this._getShapeData(previousSibling).shape;\n                shapeToSelect = possibleShapes.find((shape, i) => {\n                    return possibleShapes[i - 1] === previousShape;\n                });\n            }\n            // If there is no previous sibling, if the previous sibling had the\n            // last shape selected or if the previous shape could not be found\n            // in the possible shapes, default to the first shape. ([0] being no\n            // shapes selected.)\n            if (!shapeToSelect) {\n                shapeToSelect = possibleShapes[1];\n            }\n            // Only show on mobile by default if toggled from mobile view\n            const showOnMobile = weUtils.isMobileView(this.$target[0]);\n            this.trigger_up('snippet_edition_request', {exec: () => {\n                // options for shape will only be available after _toggleShape() returned\n                this._requestUserValueWidgets('bg_shape_opt')[0].enable();\n            }});\n            this._createShapeContainer(shapeToSelect);\n            return this._handlePreviewState(false, () => (\n                {\n                    shape: shapeToSelect,\n                    colors: this._getImplicitColors(shapeToSelect),\n                    showOnMobile,\n                }\n            ));\n        }\n    },\n});\n\n/**\n * Handles the edition of snippets' background image position.\n */\nregistry.BackgroundPosition = SnippetOptionWidget.extend({\n    /**\n     * @override\n     */\n    start: function () {\n        this._super.apply(this, arguments);\n\n        this._initOverlay();\n\n        // Resize overlay content on window resize because background images\n        // change size, and on carousel slide because they sometimes take up\n        // more space and move elements around them.\n        $(window).on('resize.bgposition', () => this._dimensionOverlay());\n    },\n    /**\n     * @override\n     */\n    destroy: function () {\n        this._toggleBgOverlay(false);\n        $(window).off('.bgposition');\n        this._super.apply(this, arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * Sets the background type (cover/repeat pattern).\n     *\n     * @see this.selectClass for params\n     */\n    backgroundType: function (previewMode, widgetValue, params) {\n        this.$target.toggleClass('o_bg_img_opt_repeat', widgetValue === 'repeat-pattern');\n        this.$target.css('background-position', '');\n        this.$target.css('background-size', widgetValue !== 'repeat-pattern' ? '' : '100px');\n    },\n    /**\n     * Saves current background position and enables overlay.\n     *\n     * @see this.selectClass for params\n     */\n    backgroundPositionOverlay: async function (previewMode, widgetValue, params) {\n        // Updates the internal image\n        await new Promise(resolve => {\n            this.img = document.createElement('img');\n            this.img.addEventListener('load', () => resolve());\n            this.img.src = getBgImageURL(this.$target[0]);\n        });\n\n        const position = this.$target.css('background-position').split(' ').map(v => parseInt(v));\n        const delta = this._getBackgroundDelta();\n        // originalPosition kept in % for when movement in one direction doesn't make sense\n        this.originalPosition = {\n            left: position[0],\n            top: position[1],\n        };\n        // Convert % values to pixels for current position because mouse movement is in pixels\n        this.currentPosition = {\n            left: position[0] / 100 * delta.x || 0,\n            top: position[1] / 100 * delta.y || 0,\n        };\n        // Make sure the element is in a visible area.\n        const rect = this.$target[0].getBoundingClientRect();\n        const viewportTop = $(window).scrollTop();\n        const viewportBottom = viewportTop + $(window).height();\n        const visibleHeight = rect.top < viewportTop\n            ? Math.max(0, Math.min(viewportBottom, rect.bottom) - viewportTop) // Starts above\n            : rect.top < viewportBottom\n                ? Math.min(viewportBottom, rect.bottom) - rect.top // Starts inside\n                : 0; // Starts after\n        if (visibleHeight < 200) {\n            await dom.scrollTo(this.$target[0], {extraOffset: 50});\n        }\n        this._toggleBgOverlay(true);\n    },\n    /**\n     * @override\n     */\n    selectStyle: function (previewMode, widgetValue, params) {\n        if (params.cssProperty === 'background-size'\n                && !this.$target.hasClass('o_bg_img_opt_repeat')) {\n            // Disable the option when the image is in cover mode, otherwise\n            // the background-size: auto style may be forced.\n            return;\n        }\n        this._super(...arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _computeVisibility: function () {\n        return this._super(...arguments) && !!getBgImageURL(this.$target[0]);\n    },\n    /**\n     * @override\n     */\n    _computeWidgetState: function (methodName, params) {\n        if (methodName === 'backgroundType') {\n            return this.$target.css('background-repeat') === 'repeat' ? 'repeat-pattern' : 'cover';\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * Initializes the overlay, binds events to the buttons, inserts it in\n     * the DOM.\n     *\n     * @private\n     */\n    _initOverlay: function () {\n        this.$backgroundOverlay = $(renderToElement('web_editor.background_position_overlay'));\n        this.$overlayContent = this.$backgroundOverlay.find('.o_we_overlay_content');\n        this.$overlayBackground = this.$overlayContent.find('.o_overlay_background');\n\n        this.$backgroundOverlay.on('click', '.o_btn_apply', () => {\n            this.$target.css('background-position', this.$bgDragger.css('background-position'));\n            this._toggleBgOverlay(false);\n        });\n        this.$backgroundOverlay.on('click', '.o_btn_discard', () => {\n            this._toggleBgOverlay(false);\n        });\n\n        this.$backgroundOverlay.insertAfter(this.$overlay);\n    },\n    /**\n     * Sets the overlay in the right place so that the draggable background\n     * renders over the target, and size the background item like the target.\n     *\n     * @private\n     */\n    _dimensionOverlay: function () {\n        if (!this.$backgroundOverlay.is('.oe_active')) {\n            return;\n        }\n        // TODO: change #wrapwrap after web_editor rework.\n        const $wrapwrap = $(this.ownerDocument.body).find(\"#wrapwrap\");\n        const targetOffset = this.$target.offset();\n\n        this.$backgroundOverlay.css({\n            width: $wrapwrap.innerWidth(),\n            height: $wrapwrap.innerHeight(),\n        });\n\n        this.$overlayContent.offset(targetOffset);\n\n        this.$bgDragger.css({\n            width: `${this.$target.innerWidth()}px`,\n            height: `${this.$target.innerHeight()}px`,\n        });\n\n        const topPos = Math.max(0, $(window).scrollTop() - this.$target.offset().top);\n        this.$overlayContent.find('.o_we_overlay_buttons').css('top', `${topPos}px`);\n    },\n    /**\n     * Toggles the overlay's display and renders a background clone inside of it.\n     *\n     * @private\n     * @param {boolean} activate toggle the overlay on (true) or off (false)\n     */\n    _toggleBgOverlay: function (activate) {\n        if (!this.$backgroundOverlay || this.$backgroundOverlay.is('.oe_active') === activate) {\n            return;\n        }\n\n        if (!activate) {\n            this.$backgroundOverlay.removeClass('oe_active');\n            this.trigger_up('unblock_preview_overlays');\n            this.trigger_up('activate_snippet', {$snippet: this.$target});\n\n            $(document).off('click.bgposition');\n            if (this.$bgDragger) {\n                this.$bgDragger.tooltip('dispose');\n            }\n            return;\n        }\n\n        this.trigger_up('hide_overlay');\n        this.trigger_up('activate_snippet', {\n            $snippet: this.$target,\n            previewMode: true,\n        });\n        this.trigger_up('block_preview_overlays');\n\n        // Create empty clone of $target with same display size, make it draggable and give it a tooltip.\n        this.$bgDragger = this.$target.clone().empty();\n        // Prevent clone from being seen as editor if target is editor (eg. background on root tag)\n        this.$bgDragger.removeClass('o_editable');\n        // Some CSS child selector rules will not be applied since the clone has a different container from $target.\n        // The background-attachment property should be the same in both $target & $bgDragger, this will keep the\n        // preview more \"wysiwyg\" instead of getting different result when bg position saved (e.g. parallax snippet)\n        // TODO: improve this to copy all style from $target and override it with overlay related style (copying all\n        // css into $bgDragger will not work since it will change overlay content style too).\n        this.$bgDragger.css('background-attachment', this.$target.css('background-attachment'));\n        this.$bgDragger.on('mousedown', this._onDragBackgroundStart.bind(this));\n        this.$bgDragger.tooltip({\n            title: 'Click and drag the background to adjust its position!',\n            trigger: 'manual',\n            container: this.$backgroundOverlay\n        });\n\n        // Replace content of overlayBackground, activate the overlay and give it the right dimensions.\n        this.$overlayBackground.empty().append(this.$bgDragger);\n        this.$backgroundOverlay.addClass('oe_active');\n        this._dimensionOverlay();\n        this.$bgDragger.tooltip('show');\n\n        // Needs to be deferred or the click event that activated the overlay deactivates it as well.\n        // This is caused by the click event which we are currently handling bubbling up to the document.\n        window.setTimeout(() => $(document).on('click.bgposition', this._onDocumentClicked.bind(this)), 0);\n    },\n    /**\n     * Returns the difference between the target's size and the background's\n     * rendered size. Background position values in % are a percentage of this.\n     *\n     * @private\n     */\n    _getBackgroundDelta: function () {\n        const bgSize = this.$target.css('background-size');\n        if (bgSize !== 'cover') {\n            let [width, height] = bgSize.split(' ');\n            if (width === 'auto' && (height === 'auto' || !height)) {\n                return {\n                    x: this.$target.outerWidth() - this.img.naturalWidth,\n                    y: this.$target.outerHeight() - this.img.naturalHeight,\n                };\n            }\n            // At least one of width or height is not auto, so we can use it to calculate the other if it's not set\n            [width, height] = [parseInt(width), parseInt(height)];\n            return {\n                x: this.$target.outerWidth() - (width || (height * this.img.naturalWidth / this.img.naturalHeight)),\n                y: this.$target.outerHeight() - (height || (width * this.img.naturalHeight / this.img.naturalWidth)),\n            };\n        }\n\n        const renderRatio = Math.max(\n            this.$target.outerWidth() / this.img.naturalWidth,\n            this.$target.outerHeight() / this.img.naturalHeight\n        );\n\n        return {\n            x: this.$target.outerWidth() - Math.round(renderRatio * this.img.naturalWidth),\n            y: this.$target.outerHeight() - Math.round(renderRatio * this.img.naturalHeight),\n        };\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Drags the overlay's background image, copied to target on \"Apply\".\n     *\n     * @private\n     */\n    _onDragBackgroundStart: function (ev) {\n        ev.preventDefault();\n        this.$bgDragger.addClass('o_we_grabbing');\n        const $document = $(this.$target[0].ownerDocument);\n        $document.on('mousemove.bgposition', this._onDragBackgroundMove.bind(this));\n        $document.one('mouseup', () => {\n            this.$bgDragger.removeClass('o_we_grabbing');\n            $document.off('mousemove.bgposition');\n        });\n    },\n    /**\n     * Drags the overlay's background image, copied to target on \"Apply\".\n     *\n     * @private\n     */\n    _onDragBackgroundMove: function (ev) {\n        ev.preventDefault();\n\n        const delta = this._getBackgroundDelta();\n        this.currentPosition.left = clamp(this.currentPosition.left + ev.originalEvent.movementX, [0, delta.x]);\n        this.currentPosition.top = clamp(this.currentPosition.top + ev.originalEvent.movementY, [0, delta.y]);\n\n        const percentPosition = {\n            left: this.currentPosition.left / delta.x * 100,\n            top: this.currentPosition.top / delta.y * 100,\n        };\n        // In cover mode, one delta will be 0 and dividing by it will yield Infinity.\n        // Defaulting to originalPosition in that case (can't be dragged)\n        percentPosition.left = isFinite(percentPosition.left) ? percentPosition.left : this.originalPosition.left;\n        percentPosition.top = isFinite(percentPosition.top) ? percentPosition.top : this.originalPosition.top;\n\n        this.$bgDragger.css('background-position', `${percentPosition.left}% ${percentPosition.top}%`);\n\n        function clamp(val, bounds) {\n            // We sort the bounds because when one dimension of the rendered background is\n            // larger than the container, delta is negative, and we want to use it as lower bound\n            bounds = bounds.sort();\n            return Math.max(bounds[0], Math.min(val, bounds[1]));\n        }\n    },\n    /**\n     * Deactivates the overlay if the user clicks outside of it.\n     *\n     * @private\n     */\n    _onDocumentClicked: function (ev) {\n        if (!$(ev.target).closest('.o_we_background_position_overlay').length) {\n            this._toggleBgOverlay(false);\n        }\n    },\n});\n\n/**\n * Marks color levels of any element that may get or has a color classes. This\n * is done for the specific main colorpicker option so that those are marked on\n * snippet drop (so that base snippet definition do not need to care about that)\n * and on first focus (for compatibility).\n */\nregistry.ColoredLevelBackground = registry.BackgroundToggler.extend({\n    /**\n     * @override\n     */\n    start: function () {\n        this._markColorLevel();\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    onBuilt: function () {\n        this._markColorLevel();\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Adds a specific class indicating the element is colored so that nested\n     * color classes work (we support one-level). Removing it is not useful,\n     * technically the class can be added on anything that *may* receive a color\n     * class: this does not come with any CSS rule.\n     *\n     * @private\n     */\n    _markColorLevel: function () {\n        this.options.wysiwyg.odooEditor.observerUnactive('_markColorLevel');\n        this.$target.addClass('o_colored_level');\n        this.options.wysiwyg.odooEditor.observerActive('_markColorLevel');\n    },\n});\n\nregistry.ContainerWidth = SnippetOptionWidget.extend({\n    /**\n     * @override\n     */\n    cleanForSave: function () {\n        this.$target.removeClass('o_container_preview');\n    },\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    selectClass: async function (previewMode, widgetValue, params) {\n        await this._super(...arguments);\n        if (previewMode === 'reset') {\n            this.$target.removeClass('o_container_preview');\n        } else if (previewMode) {\n            this.$target.addClass('o_container_preview');\n        }\n        this.trigger_up('option_update', {\n            optionName: 'StepsConnector',\n            name: 'change_container_width',\n        });\n    },\n});\n\n/**\n * Allows to replace a text value with the name of a database record.\n * @todo replace this mechanism with real backend m2o field ?\n */\nregistry.many2one = SnippetOptionWidget.extend({\n    init() {\n        this._super(...arguments);\n        this.orm = this.bindService(\"orm\");\n    },\n\n    /**\n     * @override\n     */\n    async willStart() {\n        const {oeMany2oneModel, oeMany2oneId} = this.$target[0].dataset;\n        this.fields = ['name', 'display_name'];\n        return Promise.all([\n            this._super(...arguments),\n            this.orm.read(oeMany2oneModel, [parseInt(oeMany2oneId)], this.fields).then(([initialRecord]) => {\n                this.initialRecord = initialRecord;\n            }),\n        ]);\n    },\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * @see this.selectClass for params\n     */\n    async changeRecord(previewMode, widgetValue, params) {\n        const target = this.$target[0];\n        if (previewMode === 'reset') {\n            // Have to set the jQ data because it's used to update the record in other\n            // parts of the page, but have to set the dataset because used for saving.\n            this.$target.data('oeMany2oneId', this.prevId);\n            target.dataset.oeMany2oneId = this.prevId;\n            this.$target.empty().append(this.$prevContents);\n            return this._rerenderContacts(this.prevId, this.prevRecordName);\n        }\n\n        const record = JSON.parse(params.recordData);\n        if (previewMode === true) {\n            this.prevId = parseInt(target.dataset.oeMany2oneId);\n            this.$prevContents = this.$target.contents();\n            this.prevRecordName = this.prevRecordName || this.initialRecord.name;\n        }\n\n        this.$target.data('oeMany2oneId', record.id);\n        target.dataset.oeMany2oneId = record.id;\n\n        if (target.dataset.oeType !== 'contact') {\n            target.textContent = record.name;\n        }\n        await this._rerenderContacts(record.id, record.name);\n\n        if (previewMode === false) {\n            this.prevId = record.id;\n            this.$prevContents = this.$target.contents();\n            this.prevRecordName = record.name;\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _computeWidgetState(methodName, params) {\n        if (methodName === 'changeRecord') {\n            return this.$target[0].dataset.oeMany2oneId;\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    async _renderCustomXML(uiFragment) {\n        const many2oneWidget = document.createElement('we-many2one');\n        many2oneWidget.dataset.changeRecord = '';\n\n        const model = this.$target[0].dataset.oeMany2oneModel;\n        const [{name: modelName}] = await this.orm.searchRead(\"ir.model\", [['model', '=', model]], ['name']);\n        many2oneWidget.setAttribute('String', modelName);\n        many2oneWidget.dataset.model = model;\n        many2oneWidget.dataset.fields = JSON.stringify(this.fields);\n        uiFragment.appendChild(many2oneWidget);\n    },\n    /**\n     * @private\n     */\n    async _rerenderContacts(contactId, defaultText) {\n        // Rerender this same field in other places in the page (with different\n        // contact-options). Many2ones with the same contact options will just\n        // copy the HTML of the current m2o on content_changed. Not sure why we\n        // only do this for contacts, or why we do this here instead of in the\n        // wysiwyg like we do for replacing text on content_changed\n        const selector = [\n            `[data-oe-model=\"${this.$target.data('oe-model')}\"]`,\n            `[data-oe-id=\"${this.$target.data('oe-id')}\"]`,\n            `[data-oe-field=\"${this.$target.data('oe-field')}\"]`,\n            `[data-oe-contact-options!='${this.$target[0].dataset.oeContactOptions}']`,\n        ].join('');\n        let $toRerender = $(selector);\n        if (this.$target[0].dataset.oeType === 'contact') {\n            $toRerender = $toRerender.add(this.$target);\n        }\n        await Promise.all($toRerender\n            .attr('data-oe-many2one-id', contactId).data('oe-many2one-id', contactId)\n            .map(async (i, node) => {\n                if (node.dataset.oeType === 'contact') {\n                    const html = await this.orm.call(\n                        \"ir.qweb.field.contact\",\n                        \"get_record_to_html\",\n                        [[contactId]],\n                        {options: JSON.parse(node.dataset.oeContactOptions)}\n                    );\n                    $(node).html(html);\n                } else {\n                    node.textContent = defaultText;\n                }\n            }));\n    },\n});\n/**\n * Allows to display a warning message on outdated snippets.\n */\nregistry.VersionControl = SnippetOptionWidget.extend({\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * Replaces an outdated snippet by its new version.\n     */\n    async replaceSnippet() {\n        // Getting the new block version.\n        let newBlockEl;\n        const snippet = this.$target[0].dataset.snippet;\n        this.trigger_up(\"find_snippet_template\", {\n            snippet: this.$target[0],\n            callback: (snippetTemplate) => {\n                newBlockEl = snippetTemplate.querySelector(`[data-snippet=${snippet}]`).cloneNode(true);\n            },\n        });\n        // Replacing the block.\n        this.options.wysiwyg.odooEditor.historyPauseSteps();\n        this.$target[0].classList.add(\"d-none\"); // Hiding the block to replace it smoothly.\n        this.$target[0].insertAdjacentElement(\"beforebegin\", newBlockEl);\n        // Initializing the new block as if it was dropped: the mutex needs to\n        // be free for that so we wait for it first.\n        this.options.wysiwyg.waitForEmptyMutexAction().then(async () => {\n            await this.options.wysiwyg.snippetsMenu.callPostSnippetDrop($(newBlockEl));\n            await new Promise(resolve => {\n                this.trigger_up(\"remove_snippet\",\n                    {$snippet: this.$target, onSuccess: resolve, shouldRecordUndo: false}\n                );\n            });\n            this.options.wysiwyg.odooEditor.historyUnpauseSteps();\n            newBlockEl.classList.remove(\"oe_snippet_body\");\n            this.options.wysiwyg.odooEditor.historyStep();\n        });\n    },\n    /**\n     * Allows to still access the options of an outdated block, despite the\n     * warning.\n     */\n    discardAlert() {\n        const alertEl = this.$el[0].querySelector(\"we-alert\");\n        const optionsSectionEl = this.$overlay.data(\"$optionsSection\")[0];\n        alertEl.remove();\n        optionsSectionEl.classList.remove(\"o_we_outdated_block_options\");\n        // Preventing the alert to reappear at each render.\n        controlledSnippets.add(this.$target[0].dataset.snippet);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _renderCustomXML(uiFragment) {\n        const snippetName = this.$target[0].dataset.snippet;\n        // Do not display the alert if it was previously discarded.\n        if (controlledSnippets.has(snippetName)) {\n            return;\n        }\n        this.trigger_up(\"get_snippet_versions\", {\n            snippetName: snippetName,\n            onSuccess: snippetVersions => {\n                const isUpToDate = snippetVersions && [\"vjs\", \"vcss\", \"vxml\"].every(key => this.$target[0].dataset[key] === snippetVersions[key]);\n                if (!isUpToDate) {\n                    uiFragment.prepend(renderToElement(\"web_editor.outdated_block_message\"));\n                    // Hide the other options, to only have the alert displayed.\n                    const optionsSectionEl = this.$overlay.data(\"$optionsSection\")[0];\n                    optionsSectionEl.classList.add(\"o_we_outdated_block_options\");\n                }\n            },\n        });\n    },\n});\n\n/**\n * Handle the save of a snippet as a template that can be reused later\n */\nregistry.SnippetSave = SnippetOptionWidget.extend({\n    isTopOption: true,\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * @see this.selectClass for parameters\n     */\n    saveSnippet: function (previewMode, widgetValue, params) {\n        return new Promise(resolve => {\n            this.dialog.add(ConfirmationDialog, {\n                body: _t(\"To save a snippet, we need to save all your previous modifications and reload the page.\"),\n                cancel: () => resolve(false),\n                confirmLabel: _t(\"Save and Reload\"),\n                confirm: () => {\n                    const isButton = this.$target[0].matches(\"a.btn\");\n                    const snippetKey = !isButton ? this.$target[0].dataset.snippet : \"s_button\";\n                    let thumbnailURL;\n                    this.trigger_up('snippet_thumbnail_url_request', {\n                        key: snippetKey,\n                        onSuccess: url => thumbnailURL = url,\n                    });\n                    let context;\n                    this.trigger_up('context_get', {\n                        callback: ctx => context = ctx,\n                    });\n                    this.trigger_up('request_save', {\n                        reloadEditor: true,\n                        invalidateSnippetCache: true,\n                        onSuccess: async () => {\n                            const defaultSnippetName = !isButton\n                                ? _t(\"Custom %s\", this.data.snippetName)\n                                : _t(\"Custom Button\");\n                            const targetCopyEl = this.$target[0].cloneNode(true);\n                            targetCopyEl.classList.add('s_custom_snippet');\n                            // when cloning the snippets which has o_snippet_invisible, o_snippet_mobile_invisible or\n                            // o_snippet_desktop_invisible class will be hidden because of d-none class added on it,\n                            // so we needs to remove `d-none` explicity in such case from the target.\n                            const isTargetHidden = [\n                                \"o_snippet_invisible\",\n                                \"o_snippet_mobile_invisible\",\n                                \"o_snippet_desktop_invisible\"\n                            ].some(className => this.$target[0].classList.contains(className));\n                            if (isTargetHidden) {\n                                targetCopyEl.classList.remove(\"d-none\");\n                            }\n                            delete targetCopyEl.dataset.name;\n                            if (isButton) {\n                                targetCopyEl.classList.remove(\"mb-2\");\n                                targetCopyEl.classList.add(\"o_snippet_drop_in_only\", \"s_custom_button\");\n                            }\n                            // By the time onSuccess is called after request_save, the\n                            // current widget has been destroyed and is orphaned, so this._rpc\n                            // will not work as it can't trigger_up. For this reason, we need\n                            // to bypass the service provider and use the global RPC directly\n\n                            // Get editable parent TODO find proper method to get it directly\n                            let editableParentEl;\n                            for (const parentEl of this.options.getContentEditableAreas()) {\n                                if (parentEl.contains(this.$target[0])) {\n                                    editableParentEl = parentEl;\n                                    break;\n                                }\n                            }\n                            context['model'] = editableParentEl.dataset.oeModel;\n                            context['field'] = editableParentEl.dataset.oeField;\n                            context['resId'] = editableParentEl.dataset.oeId;\n                            await jsonrpc(`/web/dataset/call_kw/ir.ui.view/save_snippet`, {\n                                model: \"ir.ui.view\",\n                                method: \"save_snippet\",\n                                args: [],\n                                kwargs: {\n                                    'name': defaultSnippetName,\n                                    'arch': targetCopyEl.outerHTML,\n                                    'template_key': this.options.snippets,\n                                    'snippet_key': snippetKey,\n                                    'thumbnail_url': thumbnailURL,\n                                    'context': context,\n                                },\n                            });\n                        },\n                    });\n                    resolve(true);\n                },\n            });\n        });\n    },\n});\n\n/**\n * Handles the dynamic colors for dynamic SVGs.\n */\nregistry.DynamicSvg = SnippetOptionWidget.extend({\n    /**\n     * @override\n     */\n    start() {\n        this.$target.on('image_changed.DynamicSvg', this._onImageChanged.bind(this));\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    destroy() {\n        this.$target.off('.DynamicSvg');\n        return this._super(...arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * Sets the dynamic SVG's dynamic color.\n     *\n     * @see this.selectClass for params\n     */\n    async color(previewMode, widgetValue, params) {\n        const target = this.$target[0];\n        switch (previewMode) {\n            case true:\n                this.previousSrc = target.getAttribute('src');\n                break;\n            case 'reset':\n                target.src = this.previousSrc;\n                return;\n        }\n        const newURL = new URL(target.src, window.location.origin);\n        newURL.searchParams.set(params.colorName, normalizeColor(widgetValue));\n        const src = newURL.pathname + newURL.search;\n        await loadImage(src);\n        target.src = src;\n        if (!previewMode) {\n            this.previousSrc = src;\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _computeWidgetState(methodName, params) {\n        switch (methodName) {\n            case 'color':\n                return new URL(this.$target[0].src, window.location.origin).searchParams.get(params.colorName);\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    _computeWidgetVisibility(widgetName, params) {\n        if ('colorName' in params) {\n            return new URL(this.$target[0].src, window.location.origin).searchParams.get(params.colorName);\n        }\n        return this._super(...arguments);\n    },\n    /**\n     * @override\n     */\n    _computeVisibility(methodName, params) {\n        return this.$target.is(\"img[src^='/web_editor/shape/']\");\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _onImageChanged(methodName, params) {\n        return this.updateUI();\n    },\n});\n\n/**\n * Allows to handle snippets with a list of items.\n */\nregistry.MultipleItems = SnippetOptionWidget.extend({\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * @see this.selectClass for parameters\n     */\n    async addItem(previewMode, widgetValue, params) {\n        const $target = this.$(params.item);\n        const addBeforeItem = params.addBefore === 'true';\n        if ($target.length) {\n            await new Promise(resolve => {\n                this.trigger_up('clone_snippet', {\n                    $snippet: $target,\n                    onSuccess: resolve,\n                });\n            });\n            if (addBeforeItem) {\n                $target.before($target.next());\n            }\n            if (params.selectItem !== 'false') {\n                this.trigger_up('activate_snippet', {\n                    $snippet: addBeforeItem ? $target.prev() : $target.next(),\n                });\n            }\n            this._addItemCallback($target);\n        }\n    },\n    /**\n     * @see this.selectClass for parameters\n     */\n    async removeItem(previewMode, widgetValue, params) {\n        const $target = this.$(params.item);\n        if ($target.length) {\n            await new Promise(resolve => {\n                this.trigger_up('remove_snippet', {\n                    $snippet: $target,\n                    onSuccess: resolve,\n                });\n            });\n            this._removeItemCallback($target);\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Allows to add behaviour when item added.\n     *\n     * @private\n     * @abstract\n     * @param {jQueryElement} $target\n     */\n    _addItemCallback($target) {},\n    /**\n     * @private\n     * @abstract\n     * @param {jQueryElement} $target\n     */\n    _removeItemCallback($target) {},\n});\n\nregistry.SelectTemplate = SnippetOptionWidget.extend({\n    custom_events: Object.assign({}, SnippetOptionWidget.prototype.custom_events, {\n        'user_value_widget_opening': '_onWidgetOpening',\n    }),\n\n    /**\n     * @constructor\n     */\n    init() {\n        this._super(...arguments);\n        this.containerSelector = '';\n        this.selectTemplateWidgetName = '';\n        this.orm = this.bindService(\"orm\");\n    },\n    /**\n     * @constructor\n     */\n    async start() {\n        this.containerEl = this.containerSelector ? this.$target.find(this.containerSelector)[0] : this.$target[0];\n        this._templates = {};\n        return this._super(...arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Options\n    //--------------------------------------------------------------------------\n\n    /**\n     * Changes the snippet layout.\n     *\n     * @see this.selectClass for parameters\n     */\n    async selectTemplate(previewMode, widgetValue, params) {\n        await this._templatesLoading;\n\n        if (previewMode === 'reset') {\n            if (!this.beforePreviewNodes) {\n                // FIXME should not be necessary: only needed because we have a\n                // strange 'reset' sent after a non-preview\n                return;\n            }\n\n            // Empty the container and restore the original content\n            while (this.containerEl.lastChild) {\n                this.containerEl.removeChild(this.containerEl.lastChild);\n            }\n            for (const node of this.beforePreviewNodes) {\n                this.containerEl.appendChild(node);\n            }\n            this.beforePreviewNodes = null;\n            return;\n        }\n\n        if (!this.beforePreviewNodes) {\n            // We are about the apply a template on non-previewed content,\n            // save that content's nodes.\n            this.beforePreviewNodes = [...this.containerEl.childNodes];\n        }\n        // Empty the container and add the template content\n        while (this.containerEl.lastChild) {\n            this.containerEl.removeChild(this.containerEl.lastChild);\n        }\n        this.containerEl.insertAdjacentHTML('beforeend', this._templates[widgetValue]);\n\n        if (!previewMode) {\n            // The original content to keep saved has to be retrieved just\n            // before the preview (if we save it now, we might miss other items\n            // added by other options or custo).\n            this.beforePreviewNodes = null;\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Retrieves a template either from cache or through RPC.\n     *\n     * @private\n     * @param {string} xmlid\n     * @returns {string}\n     */\n    async _getTemplate(xmlid) {\n        if (!this._templates[xmlid]) {\n            this._templates[xmlid] = await this.orm.call(\n                \"ir.ui.view\",\n                \"render_public_asset\",\n                [`${xmlid}`, {}],\n                { context: this.options.context }\n            );\n        }\n        return this._templates[xmlid];\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onWidgetOpening(ev) {\n        if (this._templatesLoading || ev.target.getName() !== this.selectTemplateWidgetName) {\n            return;\n        }\n        const templateParams = ev.target.getMethodsParams('selectTemplate');\n        const proms = templateParams.possibleValues.map(async xmlid => {\n            if (!xmlid) {\n                return;\n            }\n            // TODO should be better and retrieve all rendering in one RPC (but\n            // those ~10 RPC are only done once per edit mode if the option is\n            // opened, so I guess this is acceptable).\n            await this._getTemplate(xmlid);\n        });\n        this._templatesLoading = Promise.all(proms);\n    },\n});\n\n/*\n * Abstract option to be extended by the Carousel and gallery options (through\n * the \"CarouselHandler\" option) that handles all the common parts (reordering\n * of elements).\n */\nregistry.GalleryHandler = SnippetOptionWidget.extend({\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * Handles reordering of items.\n     *\n     * @override\n     */\n    notify(name, data) {\n        this._super(...arguments);\n        if (name === \"reorder_items\") {\n            const itemsEls = this._getItemsGallery();\n            const oldPosition = itemsEls.indexOf(data.itemEl);\n            if (oldPosition === 0 && data.position === \"prev\") {\n                data.position = \"last\";\n            } else if (oldPosition === itemsEls.length - 1 && data.position === \"next\") {\n                data.position = \"first\";\n            }\n            itemsEls.splice(oldPosition, 1);\n            switch (data.position) {\n                case \"first\":\n                    itemsEls.unshift(data.itemEl);\n                    break;\n                case \"prev\":\n                    itemsEls.splice(Math.max(oldPosition - 1, 0), 0, data.itemEl);\n                    break;\n                case \"next\":\n                    itemsEls.splice(oldPosition + 1, 0, data.itemEl);\n                    break;\n                case \"last\":\n                    itemsEls.push(data.itemEl);\n                    break;\n            }\n            this._reorderItems(itemsEls, itemsEls.indexOf(data.itemEl));\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Called to get the items of the gallery sorted by index if any (see\n     * gallery option) or by the order on the DOM otherwise.\n     *\n     * @abstract\n     * @returns {HTMLElement[]}\n     */\n    _getItemsGallery() {},\n    /**\n     * Called to reorder the items of the gallery.\n     *\n     * @abstract\n     * @param {HTMLElement[]} itemsEls - the items to reorder.\n     * @param {integer} newItemPosition - the new position of the moved items.\n     */\n    _reorderItems(itemsEls, newItemPosition) {},\n});\n\n/*\n * Abstract option to be extended by the Carousel and gallery options that\n * handles the update of the carousel indicator.\n */\nregistry.CarouselHandler = registry.GalleryHandler.extend({\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Update the carousel indicator.\n     *\n     * @private\n     * @param {integer} position - the position of the indicator to activate on\n     * the carousel.\n     */\n    _updateIndicatorAndActivateSnippet(position) {\n        const carouselEl = this.$target[0].classList.contains(\"carousel\") ? this.$target[0]\n            : this.$target[0].querySelector(\".carousel\");\n        carouselEl.classList.remove(\"slide\");\n        $(carouselEl).carousel(position);\n        const indicatorEls = this.$target[0].querySelectorAll(\".carousel-indicators li\");\n        indicatorEls.forEach((indicatorEl, i) => {\n            indicatorEl.classList.toggle(\"active\", i === position);\n        });\n        this.trigger_up(\"activate_snippet\", {\n            $snippet: $(this.$target[0].querySelector(\".carousel-item.active img\")),\n            ifInactiveOptions: true,\n        });\n        carouselEl.classList.add(\"slide\");\n        // Prevent the carousel from automatically sliding afterwards.\n        $(carouselEl).carousel(\"pause\");\n    },\n});\n\n\nexport default {\n    SnippetOptionWidget: SnippetOptionWidget,\n    snippetOptionRegistry: registry,\n\n    NULL_ID: NULL_ID,\n    UserValueWidget: UserValueWidget,\n    userValueWidgetsRegistry: userValueWidgetsRegistry,\n    UnitUserValueWidget: UnitUserValueWidget,\n\n    addTitleAndAllowedAttributes: _addTitleAndAllowedAttributes,\n    buildElement: _buildElement,\n    buildTitleElement: _buildTitleElement,\n    buildRowElement: _buildRowElement,\n    buildCollapseElement: _buildCollapseElement,\n\n    addAnimatedShapeLabel: _addAnimatedShapeLabel,\n\n    // Other names for convenience\n    Class: SnippetOptionWidget,\n    registry: registry,\n    serviceCached,\n    clearServiceCache,\n    clearControlledSnippets,\n};\n", "/** @odoo-module **/\n\nimport { _t } from \"@web/core/l10n/translation\";\nimport snippetsEditor from \"@web_editor/js/editor/snippets.editor\";\n\nexport const MassMailingSnippetsMenu = snippetsEditor.SnippetsMenu.extend({\n    events: Object.assign({}, snippetsEditor.SnippetsMenu.prototype.events, {\n        'click .o_we_customize_design_btn': '_onDesignTabClick',\n    }),\n    custom_events: Object.assign({}, snippetsEditor.SnippetsMenu.prototype.custom_events, {\n        drop_zone_over: '_onDropZoneOver',\n        drop_zone_out: '_onDropZoneOut',\n        drop_zone_start: '_onDropZoneStart',\n        drop_zone_stop: '_onDropZoneStop',\n    }),\n    tabs: Object.assign({}, snippetsEditor.SnippetsMenu.prototype.tabs, {\n        DESIGN: 'design',\n    }),\n    optionsTabStructure: [\n        ['design-options', _t(\"Design Options\")],\n    ],\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    start: function () {\n        return this._super(...arguments).then(() => {\n            this.$editable = this.options.wysiwyg.getEditable();\n        });\n    },\n    /**\n     * @override\n     */\n    callPostSnippetDrop: async function ($target) {\n        $target.find('img[loading=lazy]').removeAttr('loading');\n        return this._super(...arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _computeSnippetTemplates: function (html) {\n        const $html = $(`<div>${html}</div>`);\n        $html.find('img').attr('loading', 'lazy');\n        return this._super($html.html().trim());\n    },\n    /**\n     * @override\n     */\n    _patchForComputeSnippetTemplates: function ($html) {\n        // TODO: Remove in master and remove the background filter from the snippet\n        const cover_snippet = $html.find(\"[data-oe-type='snippet'] [data-snippet='s_cover']\");\n        if (cover_snippet.length) {\n            cover_snippet[0].querySelector('.o_we_bg_filter.bg-black-50').remove();\n            cover_snippet[0].querySelector('h1').classList.remove(\"text-white\");\n            cover_snippet[0].querySelector('p').classList.remove(\"text-white\");\n        }\n        return this._super($html);\n    },\n    /**\n     * @override\n     */\n    _onClick: function (ev) {\n        this._super(...arguments);\n        var srcElement = ev.target || (ev.originalEvent && (ev.originalEvent.target || ev.originalEvent.originalTarget)) || ev.srcElement;\n        // When we select something and move our cursor too far from the editable area, we get the\n        // entire editable area as the target, which causes the tab to shift from OPTIONS to BLOCK.\n        // To prevent unnecessary tab shifting, we provide a selection for this specific case.\n        if (srcElement.classList.contains('o_mail_wrapper') || srcElement.querySelector('.o_mail_wrapper')) {\n            const selection = this.options.wysiwyg.odooEditor.document.getSelection();\n            if (selection.anchorNode) {\n                const parent = selection.anchorNode.parentElement;\n                if (parent) {\n                    srcElement = parent;\n                }\n                this._activateSnippet($(srcElement));\n            }\n        }\n    },\n    /**\n     * @override\n     */\n    _insertDropzone: function ($hook) {\n        const $hookParent = $hook.parent();\n        const $dropzone = this._super(...arguments);\n        $dropzone.attr('data-editor-message', $hookParent.attr('data-editor-message'));\n        $dropzone.attr('data-editor-sub-message', $hookParent.attr('data-editor-sub-message'));\n        return $dropzone;\n    },\n    /**\n     * @override\n     */\n    _updateRightPanelContent: function ({content, tab}) {\n        this._super(...arguments);\n        this.$('.o_we_customize_design_btn').toggleClass('active', tab === this.tabs.DESIGN);\n    },\n\n    //--------------------------------------------------------------------------\n    // Handler\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _onDropZoneOver: function () {\n        this.$editable.find('.o_editable').css('background-color', '');\n    },\n    /**\n     * @override\n     */\n    _onDropZoneOut: function () {\n        const $oEditable = this.$editable.find('.o_editable');\n        if ($oEditable.find('.oe_drop_zone.oe_insert:not(.oe_vertical):only-child').length) {\n            $oEditable[0].style.setProperty('background-color', 'transparent', 'important');\n        }\n    },\n    /**\n     * @override\n     */\n    _onDropZoneStart: function () {\n        const $oEditable = this.$editable.find('.o_editable');\n        if ($oEditable.find('.oe_drop_zone.oe_insert:not(.oe_vertical):only-child').length) {\n            $oEditable[0].style.setProperty('background-color', 'transparent', 'important');\n        }\n    },\n    /**\n     * @override\n     */\n    _onDropZoneStop: function () {\n        const $oEditable = this.$editable.find('.o_editable');\n        $oEditable.css('background-color', '');\n        if (!$oEditable.find('.oe_drop_zone.oe_insert:not(.oe_vertical):only-child').length) {\n            $oEditable.attr('contenteditable', true);\n        }\n        // Refocus again to save updates when calling `_onWysiwygBlur`\n        this.$editable.focus();\n    },\n    /**\n     * @override\n     */\n    _onSnippetRemoved: function () {\n        this._super(...arguments);\n        const $oEditable = this.$editable.find('.o_editable');\n        if (!$oEditable.children().length) {\n            $oEditable.empty(); // remove any superfluous whitespace\n            $oEditable.attr('contenteditable', false);\n        }\n    },\n    /**\n     * @private\n     */\n    async _onDesignTabClick() {\n        // Note: nothing async here but start the loading effect asap\n        let releaseLoader;\n        try {\n            const promise = new Promise(resolve => releaseLoader = resolve);\n            this._execWithLoadingEffect(() => promise, false, 0);\n            // loader is added to the DOM synchronously\n            await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));\n            // ensure loader is rendered: first call asks for the (already done) DOM update,\n            // second call happens only after rendering the first \"updates\"\n\n            if (!this.topFakeOptionEl) {\n                let el;\n                for (const [elementName, title] of this.optionsTabStructure) {\n                    const newEl = document.createElement(elementName);\n                    newEl.dataset.name = title;\n                    if (el) {\n                        el.appendChild(newEl);\n                    } else {\n                        this.topFakeOptionEl = newEl;\n                    }\n                    el = newEl;\n                }\n                this.bottomFakeOptionEl = el;\n                this.el.appendChild(this.topFakeOptionEl);\n            }\n\n            // Need all of this in that order so that:\n            // - the element is visible and can be enabled and the onFocus method is\n            //   called each time.\n            // - the element is hidden afterwards so it does not take space in the\n            //   DOM, same as the overlay which may make a scrollbar appear.\n            this.topFakeOptionEl.classList.remove('d-none');\n            const editorPromise = this._activateSnippet($(this.bottomFakeOptionEl));\n            releaseLoader(); // because _activateSnippet uses the same mutex as the loader\n            releaseLoader = undefined;\n            const editor = await editorPromise;\n            this.topFakeOptionEl.classList.add('d-none');\n            editor.toggleOverlay(false);\n\n            this._updateRightPanelContent({\n                tab: this.tabs.DESIGN,\n            });\n        } catch (e) {\n            // Normally the loading effect is removed in case of error during the action but here\n            // the actual activity is happening outside of the action, the effect must therefore\n            // be cleared in case of error as well\n            if (releaseLoader) {\n                releaseLoader();\n            }\n            throw e;\n        }\n    },\n});\n\n"], "file": "/web/assets/955d469/web_editor.assets_legacy_wysiwyg.js", "sourceRoot": "../../../"}